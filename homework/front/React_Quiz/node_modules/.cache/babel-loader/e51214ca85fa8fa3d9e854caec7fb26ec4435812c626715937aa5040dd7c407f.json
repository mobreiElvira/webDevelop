{"ast":null,"code":"import { useRef } from 'react';\nimport warning from \"@rc-component/util/es/warning\";\n/**\n * Keep input cursor in the correct position if possible.\n * Is this necessary since we have `formatter` which may mass the content?\n */\nexport default function useCursor(input, focused) {\n  const selectionRef = useRef(null);\n  function recordCursor() {\n    // Record position\n    try {\n      const {\n        selectionStart: start,\n        selectionEnd: end,\n        value\n      } = input;\n      const beforeTxt = value.substring(0, start);\n      const afterTxt = value.substring(end);\n      selectionRef.current = {\n        start,\n        end,\n        value,\n        beforeTxt,\n        afterTxt\n      };\n    } catch (e) {\n      // Fix error in Chrome:\n      // Failed to read the 'selectionStart' property from 'HTMLInputElement'\n      // http://stackoverflow.com/q/21177489/3040605\n    }\n  }\n\n  /**\n   * Restore logic:\n   *  1. back string same\n   *  2. start string same\n   */\n  function restoreCursor() {\n    if (input && selectionRef.current && focused) {\n      try {\n        const {\n          value\n        } = input;\n        const {\n          beforeTxt,\n          afterTxt,\n          start\n        } = selectionRef.current;\n        let startPos = value.length;\n        if (value.startsWith(beforeTxt)) {\n          startPos = beforeTxt.length;\n        } else if (value.endsWith(afterTxt)) {\n          startPos = value.length - selectionRef.current.afterTxt.length;\n        } else {\n          const beforeLastChar = beforeTxt[start - 1];\n          const newIndex = value.indexOf(beforeLastChar, start - 1);\n          if (newIndex !== -1) {\n            startPos = newIndex + 1;\n          }\n        }\n        input.setSelectionRange(startPos, startPos);\n      } catch (e) {\n        warning(false, \"Something warning of cursor restore. Please fire issue about this: \".concat(e.message));\n      }\n    }\n  }\n  return [recordCursor, restoreCursor];\n}","map":{"version":3,"names":["useRef","warning","useCursor","input","focused","selectionRef","recordCursor","selectionStart","start","selectionEnd","end","value","beforeTxt","substring","afterTxt","current","e","restoreCursor","startPos","length","startsWith","endsWith","beforeLastChar","newIndex","indexOf","setSelectionRange","concat","message"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/input-number/es/hooks/useCursor.js"],"sourcesContent":["import { useRef } from 'react';\nimport warning from \"@rc-component/util/es/warning\";\n/**\n * Keep input cursor in the correct position if possible.\n * Is this necessary since we have `formatter` which may mass the content?\n */\nexport default function useCursor(input, focused) {\n  const selectionRef = useRef(null);\n  function recordCursor() {\n    // Record position\n    try {\n      const {\n        selectionStart: start,\n        selectionEnd: end,\n        value\n      } = input;\n      const beforeTxt = value.substring(0, start);\n      const afterTxt = value.substring(end);\n      selectionRef.current = {\n        start,\n        end,\n        value,\n        beforeTxt,\n        afterTxt\n      };\n    } catch (e) {\n      // Fix error in Chrome:\n      // Failed to read the 'selectionStart' property from 'HTMLInputElement'\n      // http://stackoverflow.com/q/21177489/3040605\n    }\n  }\n\n  /**\n   * Restore logic:\n   *  1. back string same\n   *  2. start string same\n   */\n  function restoreCursor() {\n    if (input && selectionRef.current && focused) {\n      try {\n        const {\n          value\n        } = input;\n        const {\n          beforeTxt,\n          afterTxt,\n          start\n        } = selectionRef.current;\n        let startPos = value.length;\n        if (value.startsWith(beforeTxt)) {\n          startPos = beforeTxt.length;\n        } else if (value.endsWith(afterTxt)) {\n          startPos = value.length - selectionRef.current.afterTxt.length;\n        } else {\n          const beforeLastChar = beforeTxt[start - 1];\n          const newIndex = value.indexOf(beforeLastChar, start - 1);\n          if (newIndex !== -1) {\n            startPos = newIndex + 1;\n          }\n        }\n        input.setSelectionRange(startPos, startPos);\n      } catch (e) {\n        warning(false, `Something warning of cursor restore. Please fire issue about this: ${e.message}`);\n      }\n    }\n  }\n  return [recordCursor, restoreCursor];\n}"],"mappings":"AAAA,SAASA,MAAM,QAAQ,OAAO;AAC9B,OAAOC,OAAO,MAAM,+BAA+B;AACnD;AACA;AACA;AACA;AACA,eAAe,SAASC,SAASA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAChD,MAAMC,YAAY,GAAGL,MAAM,CAAC,IAAI,CAAC;EACjC,SAASM,YAAYA,CAAA,EAAG;IACtB;IACA,IAAI;MACF,MAAM;QACJC,cAAc,EAAEC,KAAK;QACrBC,YAAY,EAAEC,GAAG;QACjBC;MACF,CAAC,GAAGR,KAAK;MACT,MAAMS,SAAS,GAAGD,KAAK,CAACE,SAAS,CAAC,CAAC,EAAEL,KAAK,CAAC;MAC3C,MAAMM,QAAQ,GAAGH,KAAK,CAACE,SAAS,CAACH,GAAG,CAAC;MACrCL,YAAY,CAACU,OAAO,GAAG;QACrBP,KAAK;QACLE,GAAG;QACHC,KAAK;QACLC,SAAS;QACTE;MACF,CAAC;IACH,CAAC,CAAC,OAAOE,CAAC,EAAE;MACV;MACA;MACA;IAAA;EAEJ;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASC,aAAaA,CAAA,EAAG;IACvB,IAAId,KAAK,IAAIE,YAAY,CAACU,OAAO,IAAIX,OAAO,EAAE;MAC5C,IAAI;QACF,MAAM;UACJO;QACF,CAAC,GAAGR,KAAK;QACT,MAAM;UACJS,SAAS;UACTE,QAAQ;UACRN;QACF,CAAC,GAAGH,YAAY,CAACU,OAAO;QACxB,IAAIG,QAAQ,GAAGP,KAAK,CAACQ,MAAM;QAC3B,IAAIR,KAAK,CAACS,UAAU,CAACR,SAAS,CAAC,EAAE;UAC/BM,QAAQ,GAAGN,SAAS,CAACO,MAAM;QAC7B,CAAC,MAAM,IAAIR,KAAK,CAACU,QAAQ,CAACP,QAAQ,CAAC,EAAE;UACnCI,QAAQ,GAAGP,KAAK,CAACQ,MAAM,GAAGd,YAAY,CAACU,OAAO,CAACD,QAAQ,CAACK,MAAM;QAChE,CAAC,MAAM;UACL,MAAMG,cAAc,GAAGV,SAAS,CAACJ,KAAK,GAAG,CAAC,CAAC;UAC3C,MAAMe,QAAQ,GAAGZ,KAAK,CAACa,OAAO,CAACF,cAAc,EAAEd,KAAK,GAAG,CAAC,CAAC;UACzD,IAAIe,QAAQ,KAAK,CAAC,CAAC,EAAE;YACnBL,QAAQ,GAAGK,QAAQ,GAAG,CAAC;UACzB;QACF;QACApB,KAAK,CAACsB,iBAAiB,CAACP,QAAQ,EAAEA,QAAQ,CAAC;MAC7C,CAAC,CAAC,OAAOF,CAAC,EAAE;QACVf,OAAO,CAAC,KAAK,wEAAAyB,MAAA,CAAwEV,CAAC,CAACW,OAAO,CAAE,CAAC;MACnG;IACF;EACF;EACA,OAAO,CAACrB,YAAY,EAAEW,aAAa,CAAC;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}