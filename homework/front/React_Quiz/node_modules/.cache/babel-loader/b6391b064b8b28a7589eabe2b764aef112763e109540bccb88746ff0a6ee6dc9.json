{"ast":null,"code":"import _objectWithoutProperties from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"children\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n/* eslint-disable no-lonely-if */\n/**\n * Legacy code. Should avoid to use if you are new to import these code.\n */\n\nimport warning from \"@rc-component/util/es/warning\";\nimport React from 'react';\nimport TreeNode from \"./TreeNode\";\nimport getEntity from \"./utils/keyUtil\";\nexport { getPosition, isTreeNode } from \"./utils/treeUtil\";\nexport function arrDel(list, value) {\n  if (!list) return [];\n  const clone = list.slice();\n  const index = clone.indexOf(value);\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n  return clone;\n}\nexport function arrAdd(list, value) {\n  const clone = (list || []).slice();\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getDragChildrenKeys(dragNodeKey, keyEntities) {\n  // not contains self\n  // self for left or right drag\n  const dragChildrenKeys = [];\n  const entity = getEntity(keyEntities, dragNodeKey);\n  function dig() {\n    let list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    list.forEach(_ref => {\n      let {\n        key,\n        children\n      } = _ref;\n      dragChildrenKeys.push(key);\n      dig(children);\n    });\n  }\n  dig(entity.children);\n  return dragChildrenKeys;\n}\nexport function isLastChild(treeNodeEntity) {\n  if (treeNodeEntity.parent) {\n    const posArr = posToArr(treeNodeEntity.pos);\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\n  }\n  return false;\n}\nexport function isFirstChild(treeNodeEntity) {\n  const posArr = posToArr(treeNodeEntity.pos);\n  return Number(posArr[posArr.length - 1]) === 0;\n}\n\n// Only used when drag, not affect SSR.\nexport function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {\n  var _abstractDropNodeEnti;\n  const {\n    clientX,\n    clientY\n  } = event;\n  const {\n    top,\n    height\n  } = event.target.getBoundingClientRect();\n  // optional chain for testing\n  const horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);\n  const rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;\n\n  // Filter the expanded keys to exclude the node that not has children currently (like async nodes).\n  const filteredExpandKeys = expandKeys.filter(key => {\n    var _keyEntities$key;\n    return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;\n  });\n\n  // find abstract drop node by horizontal offset\n  let abstractDropNodeEntity = getEntity(keyEntities, targetNodeProps.eventKey);\n  if (clientY < top + height / 2) {\n    // first half, set abstract drop node to previous node\n    const nodeIndex = flattenedNodes.findIndex(flattenedNode => flattenedNode.key === abstractDropNodeEntity.key);\n    const prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\n    const prevNodeKey = flattenedNodes[prevNodeIndex].key;\n    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);\n  }\n  const initialAbstractDropNodeKey = abstractDropNodeEntity.key;\n  const abstractDragOverEntity = abstractDropNodeEntity;\n  const dragOverNodeKey = abstractDropNodeEntity.key;\n  let dropPosition = 0;\n  let dropLevelOffset = 0;\n\n  // Only allow cross level drop when dragging on a non-expanded node\n  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {\n    for (let i = 0; i < rawDropLevelOffset; i += 1) {\n      if (isLastChild(abstractDropNodeEntity)) {\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\n        dropLevelOffset += 1;\n      } else {\n        break;\n      }\n    }\n  }\n  const abstractDragDataNode = dragNodeProps.data;\n  const abstractDropDataNode = abstractDropNodeEntity.node;\n  let dropAllowed = true;\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\n    dragNode: abstractDragDataNode,\n    dropNode: abstractDropDataNode,\n    dropPosition: -1\n  }) && abstractDropNodeEntity.key === targetNodeProps.eventKey) {\n    // first half of first node in first level\n    dropPosition = -1;\n  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {\n    // drop on expanded node\n    // only allow drop inside\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 0\n    })) {\n      dropPosition = 0;\n    } else {\n      dropAllowed = false;\n    }\n  } else if (dropLevelOffset === 0) {\n    if (rawDropLevelOffset > -1.5) {\n      // | Node     | <- abstractDropNode\n      // | -^-===== | <- mousePosition\n      // 1. try drop after\n      // 2. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    } else {\n      // | Node     | <- abstractDropNode\n      // | ---==^== | <- mousePosition\n      // whether it has children or doesn't has children\n      // always\n      // 1. try drop inside\n      // 2. try drop after\n      // 3. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 0\n      })) {\n        dropPosition = 0;\n      } else if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    }\n  } else {\n    // | Node1 | <- abstractDropNode\n    //      |  Node2  |\n    // --^--|----=====| <- mousePosition\n    // 1. try insert after Node1\n    // 2. do not allow drop\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 1\n    })) {\n      dropPosition = 1;\n    } else {\n      dropAllowed = false;\n    }\n  }\n  return {\n    dropPosition,\n    dropLevelOffset,\n    dropTargetKey: abstractDropNodeEntity.key,\n    dropTargetPos: abstractDropNodeEntity.pos,\n    dragOverNodeKey,\n    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,\n    dropAllowed\n  };\n}\n\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  const {\n    multiple\n  } = props;\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n  return selectedKeys;\n}\nconst internalProcessProps = props => props;\nexport function convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n  const {\n    processProps = internalProcessProps\n  } = processor || {};\n  const list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(_ref2 => {\n    let {\n        children\n      } = _ref2,\n      props = _objectWithoutProperties(_ref2, _excluded);\n    const childrenNodes = convertDataToTree(children, processor);\n    return /*#__PURE__*/React.createElement(TreeNode, _extends({\n      key: props.key\n    }, processProps(props)), childrenNodes);\n  });\n}\n\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  }\n\n  // Convert keys to object format\n  let keyProps;\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (typeof keys === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n  return keyProps;\n}\n\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\nexport function conductExpandParent(keyList, keyEntities) {\n  const expandedKeys = new Set();\n  function conductUp(key) {\n    if (expandedKeys.has(key)) return;\n    const entity = getEntity(keyEntities, key);\n    if (!entity) return;\n    expandedKeys.add(key);\n    const {\n      parent,\n      node\n    } = entity;\n    if (node.disabled) return;\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n  (keyList || []).forEach(key => {\n    conductUp(key);\n  });\n  return [...expandedKeys];\n}","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","warning","React","TreeNode","getEntity","getPosition","isTreeNode","arrDel","list","value","clone","slice","index","indexOf","splice","arrAdd","push","posToArr","pos","split","getDragChildrenKeys","dragNodeKey","keyEntities","dragChildrenKeys","entity","dig","undefined","forEach","_ref","children","isLastChild","treeNodeEntity","parent","posArr","Number","isFirstChild","calcDropPosition","event","dragNodeProps","targetNodeProps","indent","startMousePosition","allowDrop","flattenedNodes","expandKeys","direction","_abstractDropNodeEnti","clientX","clientY","top","height","getBoundingClientRect","horizontalMouseOffset","x","rawDropLevelOffset","filteredExpandKeys","filter","_keyEntities$key","abstractDropNodeEntity","eventKey","nodeIndex","findIndex","flattenedNode","prevNodeIndex","prevNodeKey","initialAbstractDropNodeKey","abstractDragOverEntity","dragOverNodeKey","dropPosition","dropLevelOffset","includes","abstractDragDataNode","data","abstractDropDataNode","node","dropAllowed","level","dragNode","dropNode","dropTargetKey","dropTargetPos","dropContainerKey","calcSelectedKeys","selectedKeys","props","multiple","internalProcessProps","convertDataToTree","treeData","processor","processProps","Array","isArray","map","_ref2","_objectWithoutProperties","_excluded","childrenNodes","createElement","parseCheckedKeys","keys","keyProps","checkedKeys","halfCheckedKeys","checked","halfChecked","conductExpandParent","keyList","expandedKeys","Set","conductUp","has","add","disabled"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/tree/es/util.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n/* eslint-disable no-lonely-if */\n/**\n * Legacy code. Should avoid to use if you are new to import these code.\n */\n\nimport warning from \"@rc-component/util/es/warning\";\nimport React from 'react';\nimport TreeNode from \"./TreeNode\";\nimport getEntity from \"./utils/keyUtil\";\nexport { getPosition, isTreeNode } from \"./utils/treeUtil\";\nexport function arrDel(list, value) {\n  if (!list) return [];\n  const clone = list.slice();\n  const index = clone.indexOf(value);\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n  return clone;\n}\nexport function arrAdd(list, value) {\n  const clone = (list || []).slice();\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getDragChildrenKeys(dragNodeKey, keyEntities) {\n  // not contains self\n  // self for left or right drag\n  const dragChildrenKeys = [];\n  const entity = getEntity(keyEntities, dragNodeKey);\n  function dig(list = []) {\n    list.forEach(({\n      key,\n      children\n    }) => {\n      dragChildrenKeys.push(key);\n      dig(children);\n    });\n  }\n  dig(entity.children);\n  return dragChildrenKeys;\n}\nexport function isLastChild(treeNodeEntity) {\n  if (treeNodeEntity.parent) {\n    const posArr = posToArr(treeNodeEntity.pos);\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\n  }\n  return false;\n}\nexport function isFirstChild(treeNodeEntity) {\n  const posArr = posToArr(treeNodeEntity.pos);\n  return Number(posArr[posArr.length - 1]) === 0;\n}\n\n// Only used when drag, not affect SSR.\nexport function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {\n  const {\n    clientX,\n    clientY\n  } = event;\n  const {\n    top,\n    height\n  } = event.target.getBoundingClientRect();\n  // optional chain for testing\n  const horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * ((startMousePosition?.x || 0) - clientX);\n  const rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;\n\n  // Filter the expanded keys to exclude the node that not has children currently (like async nodes).\n  const filteredExpandKeys = expandKeys.filter(key => keyEntities[key]?.children?.length);\n\n  // find abstract drop node by horizontal offset\n  let abstractDropNodeEntity = getEntity(keyEntities, targetNodeProps.eventKey);\n  if (clientY < top + height / 2) {\n    // first half, set abstract drop node to previous node\n    const nodeIndex = flattenedNodes.findIndex(flattenedNode => flattenedNode.key === abstractDropNodeEntity.key);\n    const prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\n    const prevNodeKey = flattenedNodes[prevNodeIndex].key;\n    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);\n  }\n  const initialAbstractDropNodeKey = abstractDropNodeEntity.key;\n  const abstractDragOverEntity = abstractDropNodeEntity;\n  const dragOverNodeKey = abstractDropNodeEntity.key;\n  let dropPosition = 0;\n  let dropLevelOffset = 0;\n\n  // Only allow cross level drop when dragging on a non-expanded node\n  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {\n    for (let i = 0; i < rawDropLevelOffset; i += 1) {\n      if (isLastChild(abstractDropNodeEntity)) {\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\n        dropLevelOffset += 1;\n      } else {\n        break;\n      }\n    }\n  }\n  const abstractDragDataNode = dragNodeProps.data;\n  const abstractDropDataNode = abstractDropNodeEntity.node;\n  let dropAllowed = true;\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\n    dragNode: abstractDragDataNode,\n    dropNode: abstractDropDataNode,\n    dropPosition: -1\n  }) && abstractDropNodeEntity.key === targetNodeProps.eventKey) {\n    // first half of first node in first level\n    dropPosition = -1;\n  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {\n    // drop on expanded node\n    // only allow drop inside\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 0\n    })) {\n      dropPosition = 0;\n    } else {\n      dropAllowed = false;\n    }\n  } else if (dropLevelOffset === 0) {\n    if (rawDropLevelOffset > -1.5) {\n      // | Node     | <- abstractDropNode\n      // | -^-===== | <- mousePosition\n      // 1. try drop after\n      // 2. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    } else {\n      // | Node     | <- abstractDropNode\n      // | ---==^== | <- mousePosition\n      // whether it has children or doesn't has children\n      // always\n      // 1. try drop inside\n      // 2. try drop after\n      // 3. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 0\n      })) {\n        dropPosition = 0;\n      } else if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    }\n  } else {\n    // | Node1 | <- abstractDropNode\n    //      |  Node2  |\n    // --^--|----=====| <- mousePosition\n    // 1. try insert after Node1\n    // 2. do not allow drop\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 1\n    })) {\n      dropPosition = 1;\n    } else {\n      dropAllowed = false;\n    }\n  }\n  return {\n    dropPosition,\n    dropLevelOffset,\n    dropTargetKey: abstractDropNodeEntity.key,\n    dropTargetPos: abstractDropNodeEntity.pos,\n    dragOverNodeKey,\n    dropContainerKey: dropPosition === 0 ? null : abstractDropNodeEntity.parent?.key || null,\n    dropAllowed\n  };\n}\n\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  const {\n    multiple\n  } = props;\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n  return selectedKeys;\n}\nconst internalProcessProps = props => props;\nexport function convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n  const {\n    processProps = internalProcessProps\n  } = processor || {};\n  const list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(({\n    children,\n    ...props\n  }) => {\n    const childrenNodes = convertDataToTree(children, processor);\n    return /*#__PURE__*/React.createElement(TreeNode, _extends({\n      key: props.key\n    }, processProps(props)), childrenNodes);\n  });\n}\n\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  }\n\n  // Convert keys to object format\n  let keyProps;\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (typeof keys === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n  return keyProps;\n}\n\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\nexport function conductExpandParent(keyList, keyEntities) {\n  const expandedKeys = new Set();\n  function conductUp(key) {\n    if (expandedKeys.has(key)) return;\n    const entity = getEntity(keyEntities, key);\n    if (!entity) return;\n    expandedKeys.add(key);\n    const {\n      parent,\n      node\n    } = entity;\n    if (node.disabled) return;\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n  (keyList || []).forEach(key => {\n    conductUp(key);\n  });\n  return [...expandedKeys];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}