{"ast":null,"code":"import { getFocusNodeList } from \"@rc-component/util/es/Dom/focus\";\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport raf from \"@rc-component/util/es/raf\";\nimport * as React from 'react';\nimport { getMenuId } from \"../context/IdContext\";\n// destruct to reduce minify size\nconst {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  ENTER,\n  ESC,\n  HOME,\n  END\n} = KeyCode;\nconst ArrowKeys = [UP, DOWN, LEFT, RIGHT];\nfunction getOffset(mode, isRootLevel, isRtl, which) {\n  var _offsets;\n  const prev = 'prev';\n  const next = 'next';\n  const children = 'children';\n  const parent = 'parent';\n\n  // Inline enter is special that we use unique operation\n  if (mode === 'inline' && which === ENTER) {\n    return {\n      inlineTrigger: true\n    };\n  }\n  const inline = {\n    [UP]: prev,\n    [DOWN]: next\n  };\n  const horizontal = {\n    [LEFT]: isRtl ? next : prev,\n    [RIGHT]: isRtl ? prev : next,\n    [DOWN]: children,\n    [ENTER]: children\n  };\n  const vertical = {\n    [UP]: prev,\n    [DOWN]: next,\n    [ENTER]: children,\n    [ESC]: parent,\n    [LEFT]: isRtl ? children : parent,\n    [RIGHT]: isRtl ? parent : children\n  };\n  const offsets = {\n    inline,\n    horizontal,\n    vertical,\n    inlineSub: inline,\n    horizontalSub: vertical,\n    verticalSub: vertical\n  };\n  const type = (_offsets = offsets[\"\".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets === void 0 ? void 0 : _offsets[which];\n  switch (type) {\n    case prev:\n      return {\n        offset: -1,\n        sibling: true\n      };\n    case next:\n      return {\n        offset: 1,\n        sibling: true\n      };\n    case parent:\n      return {\n        offset: -1,\n        sibling: false\n      };\n    case children:\n      return {\n        offset: 1,\n        sibling: false\n      };\n    default:\n      return null;\n  }\n}\nfunction findContainerUL(element) {\n  let current = element;\n  while (current) {\n    if (current.getAttribute('data-menu-list')) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n\n  // Normally should not reach this line\n  /* istanbul ignore next */\n  return null;\n}\n\n/**\n * Find focused element within element set provided\n */\nfunction getFocusElement(activeElement, elements) {\n  let current = activeElement || document.activeElement;\n  while (current) {\n    if (elements.has(current)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return null;\n}\n\n/**\n * Get focusable elements from the element set under provided container\n */\nexport function getFocusableElements(container, elements) {\n  const list = getFocusNodeList(container, true);\n  return list.filter(ele => elements.has(ele));\n}\nfunction getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {\n  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  // Key on the menu item will not get validate parent container\n  if (!parentQueryContainer) {\n    return null;\n  }\n\n  // List current level menu item elements\n  const sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);\n\n  // Find next focus index\n  const count = sameLevelFocusableMenuElementList.length;\n  let focusIndex = sameLevelFocusableMenuElementList.findIndex(ele => focusMenuElement === ele);\n  if (offset < 0) {\n    if (focusIndex === -1) {\n      focusIndex = count - 1;\n    } else {\n      focusIndex -= 1;\n    }\n  } else if (offset > 0) {\n    focusIndex += 1;\n  }\n  focusIndex = (focusIndex + count) % count;\n\n  // Focus menu item\n  return sameLevelFocusableMenuElementList[focusIndex];\n}\nexport const refreshElements = (keys, id) => {\n  const elements = new Set();\n  const key2element = new Map();\n  const element2key = new Map();\n  keys.forEach(key => {\n    const element = document.querySelector(\"[data-menu-id='\".concat(getMenuId(id, key), \"']\"));\n    if (element) {\n      elements.add(element);\n      element2key.set(element, key);\n      key2element.set(key, element);\n    }\n  });\n  return {\n    elements,\n    key2element,\n    element2key\n  };\n};\nexport function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {\n  const rafRef = React.useRef();\n  const activeRef = React.useRef();\n  activeRef.current = activeKey;\n  const cleanRaf = () => {\n    raf.cancel(rafRef.current);\n  };\n  React.useEffect(() => () => {\n    cleanRaf();\n  }, []);\n  return e => {\n    const {\n      which\n    } = e;\n    if ([...ArrowKeys, ENTER, ESC, HOME, END].includes(which)) {\n      const keys = getKeys();\n      let refreshedElements = refreshElements(keys, id);\n      const {\n        elements,\n        key2element,\n        element2key\n      } = refreshedElements;\n\n      // First we should find current focused MenuItem/SubMenu element\n      const activeElement = key2element.get(activeKey);\n      const focusMenuElement = getFocusElement(activeElement, elements);\n      const focusMenuKey = element2key.get(focusMenuElement);\n      const offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);\n\n      // Some mode do not have fully arrow operation like inline\n      if (!offsetObj && which !== HOME && which !== END) {\n        return;\n      }\n\n      // Arrow prevent default to avoid page scroll\n      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {\n        e.preventDefault();\n      }\n      const tryFocus = menuElement => {\n        if (menuElement) {\n          let focusTargetElement = menuElement;\n\n          // Focus to link instead of menu item if possible\n          const link = menuElement.querySelector('a');\n          if (link !== null && link !== void 0 && link.getAttribute('href')) {\n            focusTargetElement = link;\n          }\n          const targetKey = element2key.get(menuElement);\n          triggerActiveKey(targetKey);\n\n          /**\n           * Do not `useEffect` here since `tryFocus` may trigger async\n           * which makes React sync update the `activeKey`\n           * that force render before `useRef` set the next activeKey\n           */\n          cleanRaf();\n          rafRef.current = raf(() => {\n            if (activeRef.current === targetKey) {\n              focusTargetElement.focus();\n            }\n          });\n        }\n      };\n      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {\n        // ========================== Sibling ==========================\n        // Find walkable focus menu element container\n        let parentQueryContainer;\n        if (!focusMenuElement || mode === 'inline') {\n          parentQueryContainer = containerRef.current;\n        } else {\n          parentQueryContainer = findContainerUL(focusMenuElement);\n        }\n\n        // Get next focus element\n        let targetElement;\n        const focusableElements = getFocusableElements(parentQueryContainer, elements);\n        if (which === HOME) {\n          targetElement = focusableElements[0];\n        } else if (which === END) {\n          targetElement = focusableElements[focusableElements.length - 1];\n        } else {\n          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);\n        }\n        // Focus menu item\n        tryFocus(targetElement);\n\n        // ======================= InlineTrigger =======================\n      } else if (offsetObj.inlineTrigger) {\n        // Inline trigger no need switch to sub menu item\n        triggerAccessibilityOpen(focusMenuKey);\n        // =========================== Level ===========================\n      } else if (offsetObj.offset > 0) {\n        triggerAccessibilityOpen(focusMenuKey, true);\n        cleanRaf();\n        rafRef.current = raf(() => {\n          // Async should resync elements\n          refreshedElements = refreshElements(keys, id);\n          const controlId = focusMenuElement.getAttribute('aria-controls');\n          const subQueryContainer = document.getElementById(controlId);\n\n          // Get sub focusable menu item\n          const targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);\n\n          // Focus menu item\n          tryFocus(targetElement);\n        }, 5);\n      } else if (offsetObj.offset < 0) {\n        const keyPath = getKeyPath(focusMenuKey, true);\n        const parentKey = keyPath[keyPath.length - 2];\n        const parentMenuElement = key2element.get(parentKey);\n\n        // Focus menu item\n        triggerAccessibilityOpen(parentKey, false);\n        tryFocus(parentMenuElement);\n      }\n    }\n\n    // Pass origin key down event\n    originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e);\n  };\n}","map":{"version":3,"names":["getFocusNodeList","KeyCode","raf","React","getMenuId","LEFT","RIGHT","UP","DOWN","ENTER","ESC","HOME","END","ArrowKeys","getOffset","mode","isRootLevel","isRtl","which","_offsets","prev","next","children","parent","inlineTrigger","inline","horizontal","vertical","offsets","inlineSub","horizontalSub","verticalSub","type","concat","offset","sibling","findContainerUL","element","current","getAttribute","parentElement","getFocusElement","activeElement","elements","document","has","getFocusableElements","container","list","filter","ele","getNextFocusElement","parentQueryContainer","focusMenuElement","arguments","length","undefined","sameLevelFocusableMenuElementList","count","focusIndex","findIndex","refreshElements","keys","id","Set","key2element","Map","element2key","forEach","key","querySelector","add","set","useAccessibility","activeKey","containerRef","getKeys","getKeyPath","triggerActiveKey","triggerAccessibilityOpen","originOnKeyDown","rafRef","useRef","activeRef","cleanRaf","cancel","useEffect","e","includes","refreshedElements","get","focusMenuKey","offsetObj","preventDefault","tryFocus","menuElement","focusTargetElement","link","targetKey","focus","targetElement","focusableElements","controlId","subQueryContainer","getElementById","keyPath","parentKey","parentMenuElement"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/menu/es/hooks/useAccessibility.js"],"sourcesContent":["import { getFocusNodeList } from \"@rc-component/util/es/Dom/focus\";\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport raf from \"@rc-component/util/es/raf\";\nimport * as React from 'react';\nimport { getMenuId } from \"../context/IdContext\";\n// destruct to reduce minify size\nconst {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  ENTER,\n  ESC,\n  HOME,\n  END\n} = KeyCode;\nconst ArrowKeys = [UP, DOWN, LEFT, RIGHT];\nfunction getOffset(mode, isRootLevel, isRtl, which) {\n  const prev = 'prev';\n  const next = 'next';\n  const children = 'children';\n  const parent = 'parent';\n\n  // Inline enter is special that we use unique operation\n  if (mode === 'inline' && which === ENTER) {\n    return {\n      inlineTrigger: true\n    };\n  }\n  const inline = {\n    [UP]: prev,\n    [DOWN]: next\n  };\n  const horizontal = {\n    [LEFT]: isRtl ? next : prev,\n    [RIGHT]: isRtl ? prev : next,\n    [DOWN]: children,\n    [ENTER]: children\n  };\n  const vertical = {\n    [UP]: prev,\n    [DOWN]: next,\n    [ENTER]: children,\n    [ESC]: parent,\n    [LEFT]: isRtl ? children : parent,\n    [RIGHT]: isRtl ? parent : children\n  };\n  const offsets = {\n    inline,\n    horizontal,\n    vertical,\n    inlineSub: inline,\n    horizontalSub: vertical,\n    verticalSub: vertical\n  };\n  const type = offsets[`${mode}${isRootLevel ? '' : 'Sub'}`]?.[which];\n  switch (type) {\n    case prev:\n      return {\n        offset: -1,\n        sibling: true\n      };\n    case next:\n      return {\n        offset: 1,\n        sibling: true\n      };\n    case parent:\n      return {\n        offset: -1,\n        sibling: false\n      };\n    case children:\n      return {\n        offset: 1,\n        sibling: false\n      };\n    default:\n      return null;\n  }\n}\nfunction findContainerUL(element) {\n  let current = element;\n  while (current) {\n    if (current.getAttribute('data-menu-list')) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n\n  // Normally should not reach this line\n  /* istanbul ignore next */\n  return null;\n}\n\n/**\n * Find focused element within element set provided\n */\nfunction getFocusElement(activeElement, elements) {\n  let current = activeElement || document.activeElement;\n  while (current) {\n    if (elements.has(current)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return null;\n}\n\n/**\n * Get focusable elements from the element set under provided container\n */\nexport function getFocusableElements(container, elements) {\n  const list = getFocusNodeList(container, true);\n  return list.filter(ele => elements.has(ele));\n}\nfunction getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offset = 1) {\n  // Key on the menu item will not get validate parent container\n  if (!parentQueryContainer) {\n    return null;\n  }\n\n  // List current level menu item elements\n  const sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);\n\n  // Find next focus index\n  const count = sameLevelFocusableMenuElementList.length;\n  let focusIndex = sameLevelFocusableMenuElementList.findIndex(ele => focusMenuElement === ele);\n  if (offset < 0) {\n    if (focusIndex === -1) {\n      focusIndex = count - 1;\n    } else {\n      focusIndex -= 1;\n    }\n  } else if (offset > 0) {\n    focusIndex += 1;\n  }\n  focusIndex = (focusIndex + count) % count;\n\n  // Focus menu item\n  return sameLevelFocusableMenuElementList[focusIndex];\n}\nexport const refreshElements = (keys, id) => {\n  const elements = new Set();\n  const key2element = new Map();\n  const element2key = new Map();\n  keys.forEach(key => {\n    const element = document.querySelector(`[data-menu-id='${getMenuId(id, key)}']`);\n    if (element) {\n      elements.add(element);\n      element2key.set(element, key);\n      key2element.set(key, element);\n    }\n  });\n  return {\n    elements,\n    key2element,\n    element2key\n  };\n};\nexport function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {\n  const rafRef = React.useRef();\n  const activeRef = React.useRef();\n  activeRef.current = activeKey;\n  const cleanRaf = () => {\n    raf.cancel(rafRef.current);\n  };\n  React.useEffect(() => () => {\n    cleanRaf();\n  }, []);\n  return e => {\n    const {\n      which\n    } = e;\n    if ([...ArrowKeys, ENTER, ESC, HOME, END].includes(which)) {\n      const keys = getKeys();\n      let refreshedElements = refreshElements(keys, id);\n      const {\n        elements,\n        key2element,\n        element2key\n      } = refreshedElements;\n\n      // First we should find current focused MenuItem/SubMenu element\n      const activeElement = key2element.get(activeKey);\n      const focusMenuElement = getFocusElement(activeElement, elements);\n      const focusMenuKey = element2key.get(focusMenuElement);\n      const offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);\n\n      // Some mode do not have fully arrow operation like inline\n      if (!offsetObj && which !== HOME && which !== END) {\n        return;\n      }\n\n      // Arrow prevent default to avoid page scroll\n      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {\n        e.preventDefault();\n      }\n      const tryFocus = menuElement => {\n        if (menuElement) {\n          let focusTargetElement = menuElement;\n\n          // Focus to link instead of menu item if possible\n          const link = menuElement.querySelector('a');\n          if (link?.getAttribute('href')) {\n            focusTargetElement = link;\n          }\n          const targetKey = element2key.get(menuElement);\n          triggerActiveKey(targetKey);\n\n          /**\n           * Do not `useEffect` here since `tryFocus` may trigger async\n           * which makes React sync update the `activeKey`\n           * that force render before `useRef` set the next activeKey\n           */\n          cleanRaf();\n          rafRef.current = raf(() => {\n            if (activeRef.current === targetKey) {\n              focusTargetElement.focus();\n            }\n          });\n        }\n      };\n      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {\n        // ========================== Sibling ==========================\n        // Find walkable focus menu element container\n        let parentQueryContainer;\n        if (!focusMenuElement || mode === 'inline') {\n          parentQueryContainer = containerRef.current;\n        } else {\n          parentQueryContainer = findContainerUL(focusMenuElement);\n        }\n\n        // Get next focus element\n        let targetElement;\n        const focusableElements = getFocusableElements(parentQueryContainer, elements);\n        if (which === HOME) {\n          targetElement = focusableElements[0];\n        } else if (which === END) {\n          targetElement = focusableElements[focusableElements.length - 1];\n        } else {\n          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);\n        }\n        // Focus menu item\n        tryFocus(targetElement);\n\n        // ======================= InlineTrigger =======================\n      } else if (offsetObj.inlineTrigger) {\n        // Inline trigger no need switch to sub menu item\n        triggerAccessibilityOpen(focusMenuKey);\n        // =========================== Level ===========================\n      } else if (offsetObj.offset > 0) {\n        triggerAccessibilityOpen(focusMenuKey, true);\n        cleanRaf();\n        rafRef.current = raf(() => {\n          // Async should resync elements\n          refreshedElements = refreshElements(keys, id);\n          const controlId = focusMenuElement.getAttribute('aria-controls');\n          const subQueryContainer = document.getElementById(controlId);\n\n          // Get sub focusable menu item\n          const targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);\n\n          // Focus menu item\n          tryFocus(targetElement);\n        }, 5);\n      } else if (offsetObj.offset < 0) {\n        const keyPath = getKeyPath(focusMenuKey, true);\n        const parentKey = keyPath[keyPath.length - 2];\n        const parentMenuElement = key2element.get(parentKey);\n\n        // Focus menu item\n        triggerAccessibilityOpen(parentKey, false);\n        tryFocus(parentMenuElement);\n      }\n    }\n\n    // Pass origin key down event\n    originOnKeyDown?.(e);\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}