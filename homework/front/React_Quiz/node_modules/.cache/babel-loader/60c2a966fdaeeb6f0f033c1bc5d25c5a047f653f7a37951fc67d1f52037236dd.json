{"ast":null,"code":"import * as React from 'react';\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { UnstableContext } from \"../context\";\n/** Drag to delete offset. It's a user experience number for dragging out */\nconst REMOVE_DIST = 130;\nfunction getPosition(e) {\n  const obj = 'targetTouches' in e ? e.targetTouches[0] : e;\n  return {\n    pageX: obj.pageX,\n    pageY: obj.pageY\n  };\n}\nfunction useDrag(containerRef, direction, rawValues, min, max, formatValue, triggerChange, finishChange, offsetValues, editable, minCount) {\n  const [draggingValue, setDraggingValue] = React.useState(null);\n  const [draggingIndex, setDraggingIndex] = React.useState(-1);\n  const [draggingDelete, setDraggingDelete] = React.useState(false);\n  const [cacheValues, setCacheValues] = React.useState(rawValues);\n  const [originValues, setOriginValues] = React.useState(rawValues);\n  const mouseMoveEventRef = React.useRef(null);\n  const mouseUpEventRef = React.useRef(null);\n  const touchEventTargetRef = React.useRef(null);\n  const {\n    onDragStart,\n    onDragChange\n  } = React.useContext(UnstableContext);\n  useLayoutEffect(() => {\n    if (draggingIndex === -1) {\n      setCacheValues(rawValues);\n    }\n  }, [rawValues, draggingIndex]);\n\n  // Clean up event\n  React.useEffect(() => () => {\n    document.removeEventListener('mousemove', mouseMoveEventRef.current);\n    document.removeEventListener('mouseup', mouseUpEventRef.current);\n    if (touchEventTargetRef.current) {\n      touchEventTargetRef.current.removeEventListener('touchmove', mouseMoveEventRef.current);\n      touchEventTargetRef.current.removeEventListener('touchend', mouseUpEventRef.current);\n    }\n  }, []);\n  const flushValues = (nextValues, nextValue, deleteMark) => {\n    // Perf: Only update state when value changed\n    if (nextValue !== undefined) {\n      setDraggingValue(nextValue);\n    }\n    setCacheValues(nextValues);\n    let changeValues = nextValues;\n    if (deleteMark) {\n      changeValues = nextValues.filter((_, i) => i !== draggingIndex);\n    }\n    triggerChange(changeValues);\n    if (onDragChange) {\n      onDragChange({\n        rawValues: nextValues,\n        deleteIndex: deleteMark ? draggingIndex : -1,\n        draggingIndex,\n        draggingValue: nextValue\n      });\n    }\n  };\n  const updateCacheValue = useEvent((valueIndex, offsetPercent, deleteMark) => {\n    if (valueIndex === -1) {\n      // >>>> Dragging on the track\n      const startValue = originValues[0];\n      const endValue = originValues[originValues.length - 1];\n      const maxStartOffset = min - startValue;\n      const maxEndOffset = max - endValue;\n\n      // Get valid offset\n      let offset = offsetPercent * (max - min);\n      offset = Math.max(offset, maxStartOffset);\n      offset = Math.min(offset, maxEndOffset);\n\n      // Use first value to revert back of valid offset (like steps marks)\n      const formatStartValue = formatValue(startValue + offset);\n      offset = formatStartValue - startValue;\n      const cloneCacheValues = originValues.map(val => val + offset);\n      flushValues(cloneCacheValues);\n    } else {\n      // >>>> Dragging on the handle\n      const offsetDist = (max - min) * offsetPercent;\n\n      // Always start with the valueIndex origin value\n      const cloneValues = [...cacheValues];\n      cloneValues[valueIndex] = originValues[valueIndex];\n      const next = offsetValues(cloneValues, offsetDist, valueIndex, 'dist');\n      flushValues(next.values, next.value, deleteMark);\n    }\n  });\n  const onStartMove = (e, valueIndex, startValues) => {\n    e.stopPropagation();\n\n    // 如果是点击 track 触发的，需要传入变化后的初始值，而不能直接用 rawValues\n    const initialValues = startValues || rawValues;\n    const originValue = initialValues[valueIndex];\n    setDraggingIndex(valueIndex);\n    setDraggingValue(originValue);\n    setOriginValues(initialValues);\n    setCacheValues(initialValues);\n    setDraggingDelete(false);\n    const {\n      pageX: startX,\n      pageY: startY\n    } = getPosition(e);\n\n    // We declare it here since closure can't get outer latest value\n    let deleteMark = false;\n\n    // Internal trigger event\n    if (onDragStart) {\n      onDragStart({\n        rawValues: initialValues,\n        draggingIndex: valueIndex,\n        draggingValue: originValue\n      });\n    }\n\n    // Moving\n    const onMouseMove = event => {\n      event.preventDefault();\n      const {\n        pageX: moveX,\n        pageY: moveY\n      } = getPosition(event);\n      const offsetX = moveX - startX;\n      const offsetY = moveY - startY;\n      const {\n        width,\n        height\n      } = containerRef.current.getBoundingClientRect();\n      let offSetPercent;\n      let removeDist;\n      switch (direction) {\n        case 'btt':\n          offSetPercent = -offsetY / height;\n          removeDist = offsetX;\n          break;\n        case 'ttb':\n          offSetPercent = offsetY / height;\n          removeDist = offsetX;\n          break;\n        case 'rtl':\n          offSetPercent = -offsetX / width;\n          removeDist = offsetY;\n          break;\n        default:\n          offSetPercent = offsetX / width;\n          removeDist = offsetY;\n      }\n\n      // Check if need mark remove\n      deleteMark = editable ? Math.abs(removeDist) > REMOVE_DIST && minCount < cacheValues.length : false;\n      setDraggingDelete(deleteMark);\n      updateCacheValue(valueIndex, offSetPercent, deleteMark);\n    };\n\n    // End\n    const onMouseUp = event => {\n      event.preventDefault();\n      document.removeEventListener('mouseup', onMouseUp);\n      document.removeEventListener('mousemove', onMouseMove);\n      if (touchEventTargetRef.current) {\n        touchEventTargetRef.current.removeEventListener('touchmove', mouseMoveEventRef.current);\n        touchEventTargetRef.current.removeEventListener('touchend', mouseUpEventRef.current);\n      }\n      mouseMoveEventRef.current = null;\n      mouseUpEventRef.current = null;\n      touchEventTargetRef.current = null;\n      finishChange(deleteMark);\n      setDraggingIndex(-1);\n      setDraggingDelete(false);\n    };\n    document.addEventListener('mouseup', onMouseUp);\n    document.addEventListener('mousemove', onMouseMove);\n    e.currentTarget.addEventListener('touchend', onMouseUp);\n    e.currentTarget.addEventListener('touchmove', onMouseMove);\n    mouseMoveEventRef.current = onMouseMove;\n    mouseUpEventRef.current = onMouseUp;\n    touchEventTargetRef.current = e.currentTarget;\n  };\n\n  // Only return cache value when it mapping with rawValues\n  const returnValues = React.useMemo(() => {\n    const sourceValues = [...rawValues].sort((a, b) => a - b);\n    const targetValues = [...cacheValues].sort((a, b) => a - b);\n    const counts = {};\n    targetValues.forEach(val => {\n      counts[val] = (counts[val] || 0) + 1;\n    });\n    sourceValues.forEach(val => {\n      counts[val] = (counts[val] || 0) - 1;\n    });\n    const maxDiffCount = editable ? 1 : 0;\n    const diffCount = Object.values(counts).reduce((prev, next) => prev + Math.abs(next), 0);\n    return diffCount <= maxDiffCount ? cacheValues : rawValues;\n  }, [rawValues, cacheValues, editable]);\n  return [draggingIndex, draggingValue, draggingDelete, returnValues, onStartMove];\n}\nexport default useDrag;","map":{"version":3,"names":["React","useEvent","useLayoutEffect","UnstableContext","REMOVE_DIST","getPosition","e","obj","targetTouches","pageX","pageY","useDrag","containerRef","direction","rawValues","min","max","formatValue","triggerChange","finishChange","offsetValues","editable","minCount","draggingValue","setDraggingValue","useState","draggingIndex","setDraggingIndex","draggingDelete","setDraggingDelete","cacheValues","setCacheValues","originValues","setOriginValues","mouseMoveEventRef","useRef","mouseUpEventRef","touchEventTargetRef","onDragStart","onDragChange","useContext","useEffect","document","removeEventListener","current","flushValues","nextValues","nextValue","deleteMark","undefined","changeValues","filter","_","i","deleteIndex","updateCacheValue","valueIndex","offsetPercent","startValue","endValue","length","maxStartOffset","maxEndOffset","offset","Math","formatStartValue","cloneCacheValues","map","val","offsetDist","cloneValues","next","values","value","onStartMove","startValues","stopPropagation","initialValues","originValue","startX","startY","onMouseMove","event","preventDefault","moveX","moveY","offsetX","offsetY","width","height","getBoundingClientRect","offSetPercent","removeDist","abs","onMouseUp","addEventListener","currentTarget","returnValues","useMemo","sourceValues","sort","a","b","targetValues","counts","forEach","maxDiffCount","diffCount","Object","reduce","prev"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/slider/es/hooks/useDrag.js"],"sourcesContent":["import * as React from 'react';\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport { UnstableContext } from \"../context\";\n/** Drag to delete offset. It's a user experience number for dragging out */\nconst REMOVE_DIST = 130;\nfunction getPosition(e) {\n  const obj = 'targetTouches' in e ? e.targetTouches[0] : e;\n  return {\n    pageX: obj.pageX,\n    pageY: obj.pageY\n  };\n}\nfunction useDrag(containerRef, direction, rawValues, min, max, formatValue, triggerChange, finishChange, offsetValues, editable, minCount) {\n  const [draggingValue, setDraggingValue] = React.useState(null);\n  const [draggingIndex, setDraggingIndex] = React.useState(-1);\n  const [draggingDelete, setDraggingDelete] = React.useState(false);\n  const [cacheValues, setCacheValues] = React.useState(rawValues);\n  const [originValues, setOriginValues] = React.useState(rawValues);\n  const mouseMoveEventRef = React.useRef(null);\n  const mouseUpEventRef = React.useRef(null);\n  const touchEventTargetRef = React.useRef(null);\n  const {\n    onDragStart,\n    onDragChange\n  } = React.useContext(UnstableContext);\n  useLayoutEffect(() => {\n    if (draggingIndex === -1) {\n      setCacheValues(rawValues);\n    }\n  }, [rawValues, draggingIndex]);\n\n  // Clean up event\n  React.useEffect(() => () => {\n    document.removeEventListener('mousemove', mouseMoveEventRef.current);\n    document.removeEventListener('mouseup', mouseUpEventRef.current);\n    if (touchEventTargetRef.current) {\n      touchEventTargetRef.current.removeEventListener('touchmove', mouseMoveEventRef.current);\n      touchEventTargetRef.current.removeEventListener('touchend', mouseUpEventRef.current);\n    }\n  }, []);\n  const flushValues = (nextValues, nextValue, deleteMark) => {\n    // Perf: Only update state when value changed\n    if (nextValue !== undefined) {\n      setDraggingValue(nextValue);\n    }\n    setCacheValues(nextValues);\n    let changeValues = nextValues;\n    if (deleteMark) {\n      changeValues = nextValues.filter((_, i) => i !== draggingIndex);\n    }\n    triggerChange(changeValues);\n    if (onDragChange) {\n      onDragChange({\n        rawValues: nextValues,\n        deleteIndex: deleteMark ? draggingIndex : -1,\n        draggingIndex,\n        draggingValue: nextValue\n      });\n    }\n  };\n  const updateCacheValue = useEvent((valueIndex, offsetPercent, deleteMark) => {\n    if (valueIndex === -1) {\n      // >>>> Dragging on the track\n      const startValue = originValues[0];\n      const endValue = originValues[originValues.length - 1];\n      const maxStartOffset = min - startValue;\n      const maxEndOffset = max - endValue;\n\n      // Get valid offset\n      let offset = offsetPercent * (max - min);\n      offset = Math.max(offset, maxStartOffset);\n      offset = Math.min(offset, maxEndOffset);\n\n      // Use first value to revert back of valid offset (like steps marks)\n      const formatStartValue = formatValue(startValue + offset);\n      offset = formatStartValue - startValue;\n      const cloneCacheValues = originValues.map(val => val + offset);\n      flushValues(cloneCacheValues);\n    } else {\n      // >>>> Dragging on the handle\n      const offsetDist = (max - min) * offsetPercent;\n\n      // Always start with the valueIndex origin value\n      const cloneValues = [...cacheValues];\n      cloneValues[valueIndex] = originValues[valueIndex];\n      const next = offsetValues(cloneValues, offsetDist, valueIndex, 'dist');\n      flushValues(next.values, next.value, deleteMark);\n    }\n  });\n  const onStartMove = (e, valueIndex, startValues) => {\n    e.stopPropagation();\n\n    // 如果是点击 track 触发的，需要传入变化后的初始值，而不能直接用 rawValues\n    const initialValues = startValues || rawValues;\n    const originValue = initialValues[valueIndex];\n    setDraggingIndex(valueIndex);\n    setDraggingValue(originValue);\n    setOriginValues(initialValues);\n    setCacheValues(initialValues);\n    setDraggingDelete(false);\n    const {\n      pageX: startX,\n      pageY: startY\n    } = getPosition(e);\n\n    // We declare it here since closure can't get outer latest value\n    let deleteMark = false;\n\n    // Internal trigger event\n    if (onDragStart) {\n      onDragStart({\n        rawValues: initialValues,\n        draggingIndex: valueIndex,\n        draggingValue: originValue\n      });\n    }\n\n    // Moving\n    const onMouseMove = event => {\n      event.preventDefault();\n      const {\n        pageX: moveX,\n        pageY: moveY\n      } = getPosition(event);\n      const offsetX = moveX - startX;\n      const offsetY = moveY - startY;\n      const {\n        width,\n        height\n      } = containerRef.current.getBoundingClientRect();\n      let offSetPercent;\n      let removeDist;\n      switch (direction) {\n        case 'btt':\n          offSetPercent = -offsetY / height;\n          removeDist = offsetX;\n          break;\n        case 'ttb':\n          offSetPercent = offsetY / height;\n          removeDist = offsetX;\n          break;\n        case 'rtl':\n          offSetPercent = -offsetX / width;\n          removeDist = offsetY;\n          break;\n        default:\n          offSetPercent = offsetX / width;\n          removeDist = offsetY;\n      }\n\n      // Check if need mark remove\n      deleteMark = editable ? Math.abs(removeDist) > REMOVE_DIST && minCount < cacheValues.length : false;\n      setDraggingDelete(deleteMark);\n      updateCacheValue(valueIndex, offSetPercent, deleteMark);\n    };\n\n    // End\n    const onMouseUp = event => {\n      event.preventDefault();\n      document.removeEventListener('mouseup', onMouseUp);\n      document.removeEventListener('mousemove', onMouseMove);\n      if (touchEventTargetRef.current) {\n        touchEventTargetRef.current.removeEventListener('touchmove', mouseMoveEventRef.current);\n        touchEventTargetRef.current.removeEventListener('touchend', mouseUpEventRef.current);\n      }\n      mouseMoveEventRef.current = null;\n      mouseUpEventRef.current = null;\n      touchEventTargetRef.current = null;\n      finishChange(deleteMark);\n      setDraggingIndex(-1);\n      setDraggingDelete(false);\n    };\n    document.addEventListener('mouseup', onMouseUp);\n    document.addEventListener('mousemove', onMouseMove);\n    e.currentTarget.addEventListener('touchend', onMouseUp);\n    e.currentTarget.addEventListener('touchmove', onMouseMove);\n    mouseMoveEventRef.current = onMouseMove;\n    mouseUpEventRef.current = onMouseUp;\n    touchEventTargetRef.current = e.currentTarget;\n  };\n\n  // Only return cache value when it mapping with rawValues\n  const returnValues = React.useMemo(() => {\n    const sourceValues = [...rawValues].sort((a, b) => a - b);\n    const targetValues = [...cacheValues].sort((a, b) => a - b);\n    const counts = {};\n    targetValues.forEach(val => {\n      counts[val] = (counts[val] || 0) + 1;\n    });\n    sourceValues.forEach(val => {\n      counts[val] = (counts[val] || 0) - 1;\n    });\n    const maxDiffCount = editable ? 1 : 0;\n    const diffCount = Object.values(counts).reduce((prev, next) => prev + Math.abs(next), 0);\n    return diffCount <= maxDiffCount ? cacheValues : rawValues;\n  }, [rawValues, cacheValues, editable]);\n  return [draggingIndex, draggingValue, draggingDelete, returnValues, onStartMove];\n}\nexport default useDrag;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}