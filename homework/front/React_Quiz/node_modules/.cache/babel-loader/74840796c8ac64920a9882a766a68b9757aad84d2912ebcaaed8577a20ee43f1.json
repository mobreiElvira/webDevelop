{"ast":null,"code":"import { useControlledState, useEvent } from '@rc-component/util';\nimport { useRef, useState, useEffect } from 'react';\nconst internalMacroTask = fn => {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = fn;\n  channel.port2.postMessage(null);\n};\nexport const macroTask = function (fn) {\n  let times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (times <= 0) {\n    fn();\n    return;\n  }\n  internalMacroTask(() => {\n    macroTask(fn, times - 1);\n  });\n};\n\n/**\n * Trigger by latest open call, if nextOpen is undefined, means toggle.\n * ignoreNext will skip next call in the macro task queue.\n */\n\n/**\n * When `open` is controlled, follow the controlled value;\n * Otherwise use uncontrolled logic.\n * Setting `open` takes effect immediately,\n * but setting it to `false` is delayed via MessageChannel.\n *\n * SSR handling: During SSR, `open` is always false to avoid Portal issues.\n * On client-side hydration, it syncs with the actual open state.\n */\nexport default function useOpen(propOpen, onOpen, postOpen) {\n  // SSR not support Portal which means we need delay `open` for the first time render\n  const [rendered, setRendered] = useState(false);\n  useEffect(() => {\n    setRendered(true);\n  }, []);\n  const [stateOpen, internalSetOpen] = useControlledState(false, propOpen);\n\n  // During SSR, always return false for open state\n  const ssrSafeOpen = rendered ? stateOpen : false;\n  const mergedOpen = postOpen(ssrSafeOpen);\n  const taskIdRef = useRef(0);\n  const taskLockRef = useRef(false);\n  const triggerEvent = useEvent(nextOpen => {\n    if (onOpen && mergedOpen !== nextOpen) {\n      onOpen(nextOpen);\n    }\n    internalSetOpen(nextOpen);\n  });\n  const toggleOpen = useEvent(function (nextOpen) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      ignoreNext = false\n    } = config;\n    taskIdRef.current += 1;\n    const id = taskIdRef.current;\n    const nextOpenVal = typeof nextOpen === 'boolean' ? nextOpen : !mergedOpen;\n\n    // Since `mergedOpen` is post-processed, we need to check if the value really changed\n    if (nextOpenVal) {\n      if (!taskLockRef.current) {\n        triggerEvent(nextOpenVal);\n\n        // Lock if needed\n        if (ignoreNext) {\n          taskLockRef.current = ignoreNext;\n          macroTask(() => {\n            taskLockRef.current = false;\n          }, 3);\n        }\n      }\n      return;\n    }\n    macroTask(() => {\n      if (id === taskIdRef.current && !taskLockRef.current) {\n        triggerEvent(nextOpenVal);\n      }\n    });\n  });\n  return [mergedOpen, toggleOpen];\n}","map":{"version":3,"names":["useControlledState","useEvent","useRef","useState","useEffect","internalMacroTask","fn","channel","MessageChannel","port1","onmessage","port2","postMessage","macroTask","times","arguments","length","undefined","useOpen","propOpen","onOpen","postOpen","rendered","setRendered","stateOpen","internalSetOpen","ssrSafeOpen","mergedOpen","taskIdRef","taskLockRef","triggerEvent","nextOpen","toggleOpen","config","ignoreNext","current","id","nextOpenVal"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/select/es/hooks/useOpen.js"],"sourcesContent":["import { useControlledState, useEvent } from '@rc-component/util';\nimport { useRef, useState, useEffect } from 'react';\nconst internalMacroTask = fn => {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = fn;\n  channel.port2.postMessage(null);\n};\nexport const macroTask = (fn, times = 1) => {\n  if (times <= 0) {\n    fn();\n    return;\n  }\n  internalMacroTask(() => {\n    macroTask(fn, times - 1);\n  });\n};\n\n/**\n * Trigger by latest open call, if nextOpen is undefined, means toggle.\n * ignoreNext will skip next call in the macro task queue.\n */\n\n/**\n * When `open` is controlled, follow the controlled value;\n * Otherwise use uncontrolled logic.\n * Setting `open` takes effect immediately,\n * but setting it to `false` is delayed via MessageChannel.\n *\n * SSR handling: During SSR, `open` is always false to avoid Portal issues.\n * On client-side hydration, it syncs with the actual open state.\n */\nexport default function useOpen(propOpen, onOpen, postOpen) {\n  // SSR not support Portal which means we need delay `open` for the first time render\n  const [rendered, setRendered] = useState(false);\n  useEffect(() => {\n    setRendered(true);\n  }, []);\n  const [stateOpen, internalSetOpen] = useControlledState(false, propOpen);\n\n  // During SSR, always return false for open state\n  const ssrSafeOpen = rendered ? stateOpen : false;\n  const mergedOpen = postOpen(ssrSafeOpen);\n  const taskIdRef = useRef(0);\n  const taskLockRef = useRef(false);\n  const triggerEvent = useEvent(nextOpen => {\n    if (onOpen && mergedOpen !== nextOpen) {\n      onOpen(nextOpen);\n    }\n    internalSetOpen(nextOpen);\n  });\n  const toggleOpen = useEvent((nextOpen, config = {}) => {\n    const {\n      ignoreNext = false\n    } = config;\n    taskIdRef.current += 1;\n    const id = taskIdRef.current;\n    const nextOpenVal = typeof nextOpen === 'boolean' ? nextOpen : !mergedOpen;\n\n    // Since `mergedOpen` is post-processed, we need to check if the value really changed\n    if (nextOpenVal) {\n      if (!taskLockRef.current) {\n        triggerEvent(nextOpenVal);\n\n        // Lock if needed\n        if (ignoreNext) {\n          taskLockRef.current = ignoreNext;\n          macroTask(() => {\n            taskLockRef.current = false;\n          }, 3);\n        }\n      }\n      return;\n    }\n    macroTask(() => {\n      if (id === taskIdRef.current && !taskLockRef.current) {\n        triggerEvent(nextOpenVal);\n      }\n    });\n  });\n  return [mergedOpen, toggleOpen];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}