{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"name\"];\nimport { merge } from \"@rc-component/util/es/utils/set\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"./FieldContext\";\nimport { allPromiseFinish } from \"./utils/asyncUtil\";\nimport { defaultValidateMessages } from \"./utils/messages\";\nimport NameMap from \"./utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"./utils/valueUtil\";\nexport class FormStore {\n  constructor(forceRootUpdate) {\n    var _this = this;\n    _defineProperty(this, \"formHooked\", false);\n    _defineProperty(this, \"forceRootUpdate\", void 0);\n    _defineProperty(this, \"subscribable\", true);\n    _defineProperty(this, \"store\", {});\n    _defineProperty(this, \"fieldEntities\", []);\n    _defineProperty(this, \"initialValues\", {});\n    _defineProperty(this, \"callbacks\", {});\n    _defineProperty(this, \"validateMessages\", null);\n    _defineProperty(this, \"preserve\", null);\n    _defineProperty(this, \"lastValidatePromise\", null);\n    _defineProperty(this, \"getForm\", () => ({\n      getFieldValue: this.getFieldValue,\n      getFieldsValue: this.getFieldsValue,\n      getFieldError: this.getFieldError,\n      getFieldWarning: this.getFieldWarning,\n      getFieldsError: this.getFieldsError,\n      isFieldsTouched: this.isFieldsTouched,\n      isFieldTouched: this.isFieldTouched,\n      isFieldValidating: this.isFieldValidating,\n      isFieldsValidating: this.isFieldsValidating,\n      resetFields: this.resetFields,\n      setFields: this.setFields,\n      setFieldValue: this.setFieldValue,\n      setFieldsValue: this.setFieldsValue,\n      validateFields: this.validateFields,\n      submit: this.submit,\n      _init: true,\n      getInternalHooks: this.getInternalHooks\n    }));\n    // ======================== Internal Hooks ========================\n    _defineProperty(this, \"getInternalHooks\", key => {\n      if (key === HOOK_MARK) {\n        this.formHooked = true;\n        return {\n          dispatch: this.dispatch,\n          initEntityValue: this.initEntityValue,\n          registerField: this.registerField,\n          useSubscribe: this.useSubscribe,\n          setInitialValues: this.setInitialValues,\n          destroyForm: this.destroyForm,\n          setCallbacks: this.setCallbacks,\n          setValidateMessages: this.setValidateMessages,\n          getFields: this.getFields,\n          setPreserve: this.setPreserve,\n          getInitialValue: this.getInitialValue,\n          registerWatch: this.registerWatch,\n          setBatchUpdate: this.setBatchUpdate\n        };\n      }\n      warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n      return null;\n    });\n    _defineProperty(this, \"useSubscribe\", subscribable => {\n      this.subscribable = subscribable;\n    });\n    /**\n     * Record prev Form unmount fieldEntities which config preserve false.\n     * This need to be refill with initialValues instead of store value.\n     */\n    _defineProperty(this, \"prevWithoutPreserves\", null);\n    /**\n     * First time `setInitialValues` should update store with initial value\n     */\n    _defineProperty(this, \"setInitialValues\", (initialValues, init) => {\n      this.initialValues = initialValues || {};\n      if (init) {\n        var _this$prevWithoutPres;\n        let nextStore = merge(initialValues, this.store);\n\n        // We will take consider prev form unmount fields.\n        // When the field is not `preserve`, we need fill this with initialValues instead of store.\n        // eslint-disable-next-line array-callback-return\n        (_this$prevWithoutPres = this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(_ref => {\n          let {\n            key: namePath\n          } = _ref;\n          nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n        });\n        this.prevWithoutPreserves = null;\n        this.updateStore(nextStore);\n      }\n    });\n    _defineProperty(this, \"destroyForm\", clearOnDestroy => {\n      if (clearOnDestroy) {\n        // destroy form reset store\n        this.updateStore({});\n      } else {\n        // Fill preserve fields\n        const prevWithoutPreserves = new NameMap();\n        this.getFieldEntities(true).forEach(entity => {\n          if (!this.isMergedPreserve(entity.isPreserve())) {\n            prevWithoutPreserves.set(entity.getNamePath(), true);\n          }\n        });\n        this.prevWithoutPreserves = prevWithoutPreserves;\n      }\n    });\n    _defineProperty(this, \"getInitialValue\", namePath => {\n      const initValue = getValue(this.initialValues, namePath);\n\n      // Not cloneDeep when without `namePath`\n      return namePath.length ? merge(initValue) : initValue;\n    });\n    _defineProperty(this, \"setCallbacks\", callbacks => {\n      this.callbacks = callbacks;\n    });\n    _defineProperty(this, \"setValidateMessages\", validateMessages => {\n      this.validateMessages = validateMessages;\n    });\n    _defineProperty(this, \"setPreserve\", preserve => {\n      this.preserve = preserve;\n    });\n    // ============================= Watch ============================\n    _defineProperty(this, \"watchList\", []);\n    _defineProperty(this, \"registerWatch\", callback => {\n      this.watchList.push(callback);\n      return () => {\n        this.watchList = this.watchList.filter(fn => fn !== callback);\n      };\n    });\n    _defineProperty(this, \"notifyWatch\", function () {\n      let namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      // No need to cost perf when nothing need to watch\n      if (_this.watchList.length) {\n        const values = _this.getFieldsValue();\n        const allValues = _this.getFieldsValue(true);\n        _this.watchList.forEach(callback => {\n          callback(values, allValues, namePath);\n        });\n      }\n    });\n    _defineProperty(this, \"notifyWatchNamePathList\", []);\n    _defineProperty(this, \"batchNotifyWatch\", namePath => {\n      this.notifyWatchNamePathList.push(namePath);\n      this.batch('notifyWatch', () => {\n        this.notifyWatch(this.notifyWatchNamePathList);\n        this.notifyWatchNamePathList = [];\n      });\n    });\n    // ============================= Batch ============================\n    _defineProperty(this, \"batchUpdate\", void 0);\n    _defineProperty(this, \"setBatchUpdate\", batchUpdate => {\n      this.batchUpdate = batchUpdate;\n    });\n    // Batch call the task, only last will be called\n    _defineProperty(this, \"batch\", (key, callback) => {\n      this.batchUpdate(key, callback);\n    });\n    // ========================== Dev Warning =========================\n    _defineProperty(this, \"timeoutId\", null);\n    _defineProperty(this, \"warningUnhooked\", () => {\n      if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n        this.timeoutId = setTimeout(() => {\n          this.timeoutId = null;\n          if (!this.formHooked) {\n            warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n          }\n        });\n      }\n    });\n    // ============================ Store =============================\n    _defineProperty(this, \"updateStore\", nextStore => {\n      this.store = nextStore;\n    });\n    // ============================ Fields ============================\n    /**\n     * Get registered field entities.\n     * @param pure Only return field which has a `name`. Default: false\n     */\n    _defineProperty(this, \"getFieldEntities\", function () {\n      let pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!pure) {\n        return _this.fieldEntities;\n      }\n      return _this.fieldEntities.filter(field => field.getNamePath().length);\n    });\n    _defineProperty(this, \"getFieldsMap\", function () {\n      let pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      const cache = new NameMap();\n      _this.getFieldEntities(pure).forEach(field => {\n        const namePath = field.getNamePath();\n        cache.set(namePath, field);\n      });\n      return cache;\n    });\n    _defineProperty(this, \"getFieldEntitiesForNamePathList\", nameList => {\n      if (!nameList) {\n        return this.getFieldEntities(true);\n      }\n      const cache = this.getFieldsMap(true);\n      return nameList.map(name => {\n        const namePath = getNamePath(name);\n        return cache.get(namePath) || {\n          INVALIDATE_NAME_PATH: getNamePath(name)\n        };\n      });\n    });\n    _defineProperty(this, \"getFieldsValue\", (nameList, filterFunc) => {\n      this.warningUnhooked();\n\n      // Fill args\n      let mergedNameList;\n      let mergedFilterFunc;\n      if (nameList === true || Array.isArray(nameList)) {\n        mergedNameList = nameList;\n        mergedFilterFunc = filterFunc;\n      } else if (nameList && typeof nameList === 'object') {\n        mergedFilterFunc = nameList.filter;\n      }\n      if (mergedNameList === true && !mergedFilterFunc) {\n        return this.store;\n      }\n      const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n      const filteredNameList = [];\n      const listNamePaths = [];\n      fieldEntities.forEach(entity => {\n        var _entity$isList;\n        const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n        // Ignore when it's a list item and not specific the namePath,\n        // since parent field is already take in count\n        if ((_entity$isList = entity.isList) !== null && _entity$isList !== void 0 && _entity$isList.call(entity)) {\n          listNamePaths.push(namePath);\n          return;\n        }\n        if (!mergedFilterFunc) {\n          filteredNameList.push(namePath);\n        } else {\n          const meta = 'getMeta' in entity ? entity.getMeta() : null;\n          if (mergedFilterFunc(meta)) {\n            filteredNameList.push(namePath);\n          }\n        }\n      });\n      let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n      // We need fill the list as [] if Form.List is empty\n      listNamePaths.forEach(namePath => {\n        if (!getValue(mergedValues, namePath)) {\n          mergedValues = setValue(mergedValues, namePath, []);\n        }\n      });\n      return mergedValues;\n    });\n    _defineProperty(this, \"getFieldValue\", name => {\n      this.warningUnhooked();\n      const namePath = getNamePath(name);\n      return getValue(this.store, namePath);\n    });\n    _defineProperty(this, \"getFieldsError\", nameList => {\n      this.warningUnhooked();\n      const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n      return fieldEntities.map((entity, index) => {\n        if (entity && !entity.INVALIDATE_NAME_PATH) {\n          return {\n            name: entity.getNamePath(),\n            errors: entity.getErrors(),\n            warnings: entity.getWarnings()\n          };\n        }\n        return {\n          name: getNamePath(nameList[index]),\n          errors: [],\n          warnings: []\n        };\n      });\n    });\n    _defineProperty(this, \"getFieldError\", name => {\n      this.warningUnhooked();\n      const namePath = getNamePath(name);\n      const fieldError = this.getFieldsError([namePath])[0];\n      return fieldError.errors;\n    });\n    _defineProperty(this, \"getFieldWarning\", name => {\n      this.warningUnhooked();\n      const namePath = getNamePath(name);\n      const fieldError = this.getFieldsError([namePath])[0];\n      return fieldError.warnings;\n    });\n    _defineProperty(this, \"isFieldsTouched\", function () {\n      _this.warningUnhooked();\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const [arg0, arg1] = args;\n      let namePathList;\n      let isAllFieldsTouched = false;\n      if (args.length === 0) {\n        namePathList = null;\n      } else if (args.length === 1) {\n        if (Array.isArray(arg0)) {\n          namePathList = arg0.map(getNamePath);\n          isAllFieldsTouched = false;\n        } else {\n          namePathList = null;\n          isAllFieldsTouched = arg0;\n        }\n      } else {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = arg1;\n      }\n      const fieldEntities = _this.getFieldEntities(true);\n      const isFieldTouched = field => field.isFieldTouched();\n\n      // ===== Will get fully compare when not config namePathList =====\n      if (!namePathList) {\n        return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n      }\n\n      // Generate a nest tree for validate\n      const map = new NameMap();\n      namePathList.forEach(shortNamePath => {\n        map.set(shortNamePath, []);\n      });\n      fieldEntities.forEach(field => {\n        const fieldNamePath = field.getNamePath();\n\n        // Find matched entity and put into list\n        namePathList.forEach(shortNamePath => {\n          if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n            map.update(shortNamePath, list => [...list, field]);\n          }\n        });\n      });\n\n      // Check if NameMap value is touched\n      const isNamePathListTouched = entities => entities.some(isFieldTouched);\n      const namePathListEntities = map.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      });\n      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n    });\n    _defineProperty(this, \"isFieldTouched\", name => {\n      this.warningUnhooked();\n      return this.isFieldsTouched([name]);\n    });\n    _defineProperty(this, \"isFieldsValidating\", nameList => {\n      this.warningUnhooked();\n      const fieldEntities = this.getFieldEntities();\n      if (!nameList) {\n        return fieldEntities.some(testField => testField.isFieldValidating());\n      }\n      const namePathList = nameList.map(getNamePath);\n      return fieldEntities.some(testField => {\n        const fieldNamePath = testField.getNamePath();\n        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n      });\n    });\n    _defineProperty(this, \"isFieldValidating\", name => {\n      this.warningUnhooked();\n      return this.isFieldsValidating([name]);\n    });\n    /**\n     * Reset Field with field `initialValue` prop.\n     * Can pass `entities` or `namePathList` or just nothing.\n     */\n    _defineProperty(this, \"resetWithFieldInitialValue\", function () {\n      let info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // Create cache\n      const cache = new NameMap();\n      const fieldEntities = _this.getFieldEntities(true);\n      fieldEntities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        const namePath = field.getNamePath();\n\n        // Record only if has `initialValue`\n        if (initialValue !== undefined) {\n          const records = cache.get(namePath) || new Set();\n          records.add({\n            entity: field,\n            value: initialValue\n          });\n          cache.set(namePath, records);\n        }\n      });\n\n      // Reset\n      const resetWithFields = entities => {\n        entities.forEach(field => {\n          const {\n            initialValue\n          } = field.props;\n          if (initialValue !== undefined) {\n            const namePath = field.getNamePath();\n            const formInitialValue = _this.getInitialValue(namePath);\n            if (formInitialValue !== undefined) {\n              // Warning if conflict with form initialValues and do not modify value\n              warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\n            } else {\n              const records = cache.get(namePath);\n              if (records && records.size > 1) {\n                // Warning if multiple field set `initialValue`and do not modify value\n                warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\n              } else if (records) {\n                const originValue = _this.getFieldValue(namePath);\n                const isListField = field.isListField();\n\n                // Set `initialValue`\n                if (!isListField && (!info.skipExist || originValue === undefined)) {\n                  _this.updateStore(setValue(_this.store, namePath, [...records][0].value));\n                }\n              }\n            }\n          }\n        });\n      };\n      let requiredFieldEntities;\n      if (info.entities) {\n        requiredFieldEntities = info.entities;\n      } else if (info.namePathList) {\n        requiredFieldEntities = [];\n        info.namePathList.forEach(namePath => {\n          const records = cache.get(namePath);\n          if (records) {\n            requiredFieldEntities.push(...[...records].map(r => r.entity));\n          }\n        });\n      } else {\n        requiredFieldEntities = fieldEntities;\n      }\n      resetWithFields(requiredFieldEntities);\n    });\n    _defineProperty(this, \"resetFields\", nameList => {\n      this.warningUnhooked();\n      const prevStore = this.store;\n      if (!nameList) {\n        this.updateStore(merge(this.initialValues));\n        this.resetWithFieldInitialValue();\n        this.notifyObservers(prevStore, null, {\n          type: 'reset'\n        });\n        this.notifyWatch();\n        return;\n      }\n\n      // Reset by `nameList`\n      const namePathList = nameList.map(getNamePath);\n      namePathList.forEach(namePath => {\n        const initialValue = this.getInitialValue(namePath);\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      });\n      this.resetWithFieldInitialValue({\n        namePathList\n      });\n      this.notifyObservers(prevStore, namePathList, {\n        type: 'reset'\n      });\n      this.notifyWatch(namePathList);\n    });\n    _defineProperty(this, \"setFields\", fields => {\n      this.warningUnhooked();\n      const prevStore = this.store;\n      const namePathList = [];\n      fields.forEach(fieldData => {\n        const {\n            name\n          } = fieldData,\n          data = _objectWithoutProperties(fieldData, _excluded);\n        const namePath = getNamePath(name);\n        namePathList.push(namePath);\n\n        // Value\n        if ('value' in data) {\n          this.updateStore(setValue(this.store, namePath, data.value));\n        }\n        this.notifyObservers(prevStore, [namePath], {\n          type: 'setField',\n          data: fieldData\n        });\n      });\n      this.notifyWatch(namePathList);\n    });\n    _defineProperty(this, \"getFields\", () => {\n      const entities = this.getFieldEntities(true);\n      const fields = entities.map(field => {\n        const namePath = field.getNamePath();\n        const meta = field.getMeta();\n        const fieldData = _objectSpread(_objectSpread({}, meta), {}, {\n          name: namePath,\n          value: this.getFieldValue(namePath)\n        });\n        Object.defineProperty(fieldData, 'originRCField', {\n          value: true\n        });\n        return fieldData;\n      });\n      return fields;\n    });\n    // =========================== Observer ===========================\n    /**\n     * This only trigger when a field is on constructor to avoid we get initialValue too late\n     */\n    _defineProperty(this, \"initEntityValue\", entity => {\n      const {\n        initialValue\n      } = entity.props;\n      if (initialValue !== undefined) {\n        const namePath = entity.getNamePath();\n        const prevValue = getValue(this.store, namePath);\n        if (prevValue === undefined) {\n          this.updateStore(setValue(this.store, namePath, initialValue));\n        }\n      }\n    });\n    _defineProperty(this, \"isMergedPreserve\", fieldPreserve => {\n      const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n      return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\n    });\n    _defineProperty(this, \"registerField\", entity => {\n      this.fieldEntities.push(entity);\n      const namePath = entity.getNamePath();\n      this.batchNotifyWatch(namePath);\n\n      // Set initial values\n      if (entity.props.initialValue !== undefined) {\n        const prevStore = this.store;\n        this.resetWithFieldInitialValue({\n          entities: [entity],\n          skipExist: true\n        });\n        this.notifyObservers(prevStore, [entity.getNamePath()], {\n          type: 'valueUpdate',\n          source: 'internal'\n        });\n      }\n\n      // un-register field callback\n      return function (isListField, preserve) {\n        let subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        _this.fieldEntities = _this.fieldEntities.filter(item => item !== entity);\n\n        // Clean up store value if not preserve\n        if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n          const defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\n          if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(field =>\n          // Only reset when no namePath exist\n          !matchNamePath(field.getNamePath(), namePath))) {\n            const prevStore = _this.store;\n            _this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n            // Notify that field is unmount\n            _this.notifyObservers(prevStore, [namePath], {\n              type: 'remove'\n            });\n\n            // Dependencies update\n            _this.triggerDependenciesUpdate(prevStore, namePath);\n          }\n        }\n        _this.batchNotifyWatch(namePath);\n      };\n    });\n    _defineProperty(this, \"dispatch\", action => {\n      switch (action.type) {\n        case 'updateValue':\n          {\n            const {\n              namePath,\n              value\n            } = action;\n            this.updateValue(namePath, value);\n            break;\n          }\n        case 'validateField':\n          {\n            const {\n              namePath,\n              triggerName\n            } = action;\n            this.validateFields([namePath], {\n              triggerName\n            });\n            break;\n          }\n        default:\n        // Currently we don't have other action. Do nothing.\n      }\n    });\n    _defineProperty(this, \"notifyObservers\", (prevStore, namePathList, info) => {\n      if (this.subscribable) {\n        const mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\n          store: this.getFieldsValue(true)\n        });\n        this.getFieldEntities().forEach(_ref3 => {\n          let {\n            onStoreChange\n          } = _ref3;\n          onStoreChange(prevStore, namePathList, mergedInfo);\n        });\n      } else {\n        this.forceRootUpdate();\n      }\n    });\n    /**\n     * Notify dependencies children with parent update\n     * We need delay to trigger validate in case Field is under render props\n     */\n    _defineProperty(this, \"triggerDependenciesUpdate\", (prevStore, namePath) => {\n      const childrenFields = this.getDependencyChildrenFields(namePath);\n      if (childrenFields.length) {\n        this.validateFields(childrenFields);\n      }\n      this.notifyObservers(prevStore, childrenFields, {\n        type: 'dependenciesUpdate',\n        relatedFields: [namePath, ...childrenFields]\n      });\n      return childrenFields;\n    });\n    _defineProperty(this, \"updateValue\", (name, value) => {\n      const namePath = getNamePath(name);\n      const prevStore = this.store;\n      this.updateStore(setValue(this.store, namePath, value));\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n      this.notifyWatch([namePath]);\n\n      // Dependencies update\n      const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n      // trigger callback function\n      const {\n        onValuesChange\n      } = this.callbacks;\n      if (onValuesChange) {\n        const changedValues = cloneByNamePathList(this.store, [namePath]);\n        const allValues = this.getFieldsValue();\n        // Merge changedValues into allValues to ensure allValues contains the latest changes\n        const mergedAllValues = merge(allValues, changedValues);\n        onValuesChange(changedValues, mergedAllValues);\n      }\n      this.triggerOnFieldsChange([namePath, ...childrenFields]);\n    });\n    // Let all child Field get update.\n    _defineProperty(this, \"setFieldsValue\", store => {\n      this.warningUnhooked();\n      const prevStore = this.store;\n      if (store) {\n        const nextStore = merge(this.store, store);\n        this.updateStore(nextStore);\n      }\n      this.notifyObservers(prevStore, null, {\n        type: 'valueUpdate',\n        source: 'external'\n      });\n      this.notifyWatch();\n    });\n    _defineProperty(this, \"setFieldValue\", (name, value) => {\n      this.setFields([{\n        name,\n        value,\n        errors: [],\n        warnings: [],\n        touched: true\n      }]);\n    });\n    _defineProperty(this, \"getDependencyChildrenFields\", rootNamePath => {\n      const children = new Set();\n      const childrenFields = [];\n      const dependencies2fields = new NameMap();\n\n      /**\n       * Generate maps\n       * Can use cache to save perf if user report performance issue with this\n       */\n      this.getFieldEntities().forEach(field => {\n        const {\n          dependencies\n        } = field.props;\n        (dependencies || []).forEach(dependency => {\n          const dependencyNamePath = getNamePath(dependency);\n          dependencies2fields.update(dependencyNamePath, function () {\n            let fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n            fields.add(field);\n            return fields;\n          });\n        });\n      });\n      const fillChildren = namePath => {\n        const fields = dependencies2fields.get(namePath) || new Set();\n        fields.forEach(field => {\n          if (!children.has(field)) {\n            children.add(field);\n            const fieldNamePath = field.getNamePath();\n            if (field.isFieldDirty() && fieldNamePath.length) {\n              childrenFields.push(fieldNamePath);\n              fillChildren(fieldNamePath);\n            }\n          }\n        });\n      };\n      fillChildren(rootNamePath);\n      return childrenFields;\n    });\n    _defineProperty(this, \"triggerOnFieldsChange\", (namePathList, filedErrors) => {\n      const {\n        onFieldsChange\n      } = this.callbacks;\n      if (onFieldsChange) {\n        const fields = this.getFields();\n\n        /**\n         * Fill errors since `fields` may be replaced by controlled fields\n         */\n        if (filedErrors) {\n          const cache = new NameMap();\n          filedErrors.forEach(_ref4 => {\n            let {\n              name,\n              errors\n            } = _ref4;\n            cache.set(name, errors);\n          });\n          fields.forEach(field => {\n            // eslint-disable-next-line no-param-reassign\n            field.errors = cache.get(field.name) || field.errors;\n          });\n        }\n        const changedFields = fields.filter(_ref5 => {\n          let {\n            name: fieldName\n          } = _ref5;\n          return containsNamePath(namePathList, fieldName);\n        });\n        if (changedFields.length) {\n          onFieldsChange(changedFields, fields);\n        }\n      }\n    });\n    // =========================== Validate ===========================\n    _defineProperty(this, \"validateFields\", (arg1, arg2) => {\n      this.warningUnhooked();\n      let nameList;\n      let options;\n      if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n        nameList = arg1;\n        options = arg2;\n      } else {\n        options = arg1;\n      }\n      const provideNameList = !!nameList;\n      const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n      // Same namePathList, but does not include Form.List name\n      const finalValueNamePathList = [...namePathList];\n\n      // Collect result in promise list\n      const promiseList = [];\n\n      // We temp save the path which need trigger for `onFieldsChange`\n      const TMP_SPLIT = String(Date.now());\n      const validateNamePathList = new Set();\n      const {\n        recursive,\n        dirty\n      } = options || {};\n      this.getFieldEntities(true).forEach(field => {\n        const fieldNamePath = field.getNamePath();\n\n        // Add field if not provide `nameList`\n        if (!provideNameList) {\n          if (\n          // If is field, pass directly\n          !field.isList() ||\n          // If is list, do not add if already exist sub field in the namePathList\n          !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n            finalValueNamePathList.push(fieldNamePath);\n          }\n          namePathList.push(fieldNamePath);\n        }\n\n        // Skip if without rule\n        if (!field.props.rules || !field.props.rules.length) {\n          return;\n        }\n\n        // Skip if only validate dirty field\n        if (dirty && !field.isFieldDirty()) {\n          return;\n        }\n        validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n        // Add field validate rule in to promise list\n        if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n          const promise = field.validateRules(_objectSpread({\n            validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), this.validateMessages)\n          }, options));\n\n          // Wrap promise with field\n          promiseList.push(promise.then(() => ({\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          })).catch(ruleErrors => {\n            var _ruleErrors$forEach;\n            const mergedErrors = [];\n            const mergedWarnings = [];\n            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, _ref6 => {\n              let {\n                rule: {\n                  warningOnly\n                },\n                errors\n              } = _ref6;\n              if (warningOnly) {\n                mergedWarnings.push(...errors);\n              } else {\n                mergedErrors.push(...errors);\n              }\n            });\n            if (mergedErrors.length) {\n              return Promise.reject({\n                name: fieldNamePath,\n                errors: mergedErrors,\n                warnings: mergedWarnings\n              });\n            }\n            return {\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            };\n          }));\n        }\n      });\n      const summaryPromise = allPromiseFinish(promiseList);\n      this.lastValidatePromise = summaryPromise;\n\n      // Notify fields with rule that validate has finished and need update\n      summaryPromise.catch(results => results).then(results => {\n        const resultNamePathList = results.map(_ref7 => {\n          let {\n            name\n          } = _ref7;\n          return name;\n        });\n        this.notifyObservers(this.store, resultNamePathList, {\n          type: 'validateFinish'\n        });\n        this.triggerOnFieldsChange(resultNamePathList, results);\n      });\n      const returnPromise = summaryPromise.then(() => {\n        if (this.lastValidatePromise === summaryPromise) {\n          return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n        }\n        return Promise.reject([]);\n      }).catch(results => {\n        var _errorList$;\n        const errorList = results.filter(result => result && result.errors.length);\n        const errorMessage = (_errorList$ = errorList[0]) === null || _errorList$ === void 0 || (_errorList$ = _errorList$.errors) === null || _errorList$ === void 0 ? void 0 : _errorList$[0];\n        return Promise.reject({\n          message: errorMessage,\n          values: this.getFieldsValue(namePathList),\n          errorFields: errorList,\n          outOfDate: this.lastValidatePromise !== summaryPromise\n        });\n      });\n\n      // Do not throw in console\n      returnPromise.catch(e => e);\n\n      // `validating` changed. Trigger `onFieldsChange`\n      const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n      this.triggerOnFieldsChange(triggerNamePathList);\n      return returnPromise;\n    });\n    // ============================ Submit ============================\n    _defineProperty(this, \"submit\", () => {\n      this.warningUnhooked();\n      this.validateFields().then(values => {\n        const {\n          onFinish\n        } = this.callbacks;\n        if (onFinish) {\n          try {\n            onFinish(values);\n          } catch (err) {\n            // Should print error if user `onFinish` callback failed\n            console.error(err);\n          }\n        }\n      }).catch(e => {\n        const {\n          onFinishFailed\n        } = this.callbacks;\n        if (onFinishFailed) {\n          onFinishFailed(e);\n        }\n      });\n    });\n    this.forceRootUpdate = forceRootUpdate;\n  }\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;","map":{"version":3,"names":["merge","warning","React","HOOK_MARK","allPromiseFinish","defaultValidateMessages","NameMap","cloneByNamePathList","containsNamePath","getNamePath","getValue","matchNamePath","setValue","FormStore","constructor","forceRootUpdate","_this","_defineProperty","getFieldValue","getFieldsValue","getFieldError","getFieldWarning","getFieldsError","isFieldsTouched","isFieldTouched","isFieldValidating","isFieldsValidating","resetFields","setFields","setFieldValue","setFieldsValue","validateFields","submit","_init","getInternalHooks","key","formHooked","dispatch","initEntityValue","registerField","useSubscribe","setInitialValues","destroyForm","setCallbacks","setValidateMessages","getFields","setPreserve","getInitialValue","registerWatch","setBatchUpdate","subscribable","initialValues","init","_this$prevWithoutPres","nextStore","store","prevWithoutPreserves","map","_ref","namePath","updateStore","clearOnDestroy","getFieldEntities","forEach","entity","isMergedPreserve","isPreserve","set","initValue","length","callbacks","validateMessages","preserve","callback","watchList","push","filter","fn","arguments","undefined","values","allValues","notifyWatchNamePathList","batch","notifyWatch","batchUpdate","process","env","NODE_ENV","timeoutId","window","setTimeout","pure","fieldEntities","field","cache","nameList","getFieldsMap","name","get","INVALIDATE_NAME_PATH","filterFunc","warningUnhooked","mergedNameList","mergedFilterFunc","Array","isArray","getFieldEntitiesForNamePathList","filteredNameList","listNamePaths","_entity$isList","isList","call","meta","getMeta","mergedValues","index","errors","getErrors","warnings","getWarnings","fieldError","_len","args","_key","arg0","arg1","namePathList","isAllFieldsTouched","every","some","shortNamePath","fieldNamePath","nameUnit","i","update","list","isNamePathListTouched","entities","namePathListEntities","_ref2","value","testField","info","initialValue","props","records","Set","add","resetWithFields","formInitialValue","concat","join","size","originValue","isListField","skipExist","requiredFieldEntities","r","prevStore","resetWithFieldInitialValue","notifyObservers","type","fields","fieldData","data","_objectWithoutProperties","_excluded","_objectSpread","Object","defineProperty","prevValue","fieldPreserve","mergedPreserve","batchNotifyWatch","source","subNamePath","item","defaultValue","triggerDependenciesUpdate","action","updateValue","triggerName","mergedInfo","_ref3","onStoreChange","childrenFields","getDependencyChildrenFields","relatedFields","onValuesChange","changedValues","mergedAllValues","triggerOnFieldsChange","touched","rootNamePath","children","dependencies2fields","dependencies","dependency","dependencyNamePath","fillChildren","has","isFieldDirty","filedErrors","onFieldsChange","_ref4","changedFields","_ref5","fieldName","arg2","options","provideNameList","finalValueNamePathList","promiseList","TMP_SPLIT","String","Date","now","validateNamePathList","recursive","dirty","rules","promise","validateRules","then","catch","ruleErrors","_ruleErrors$forEach","mergedErrors","mergedWarnings","_ref6","rule","warningOnly","Promise","reject","summaryPromise","lastValidatePromise","results","resultNamePathList","_ref7","returnPromise","resolve","_errorList$","errorList","result","errorMessage","message","errorFields","outOfDate","e","triggerNamePathList","onFinish","err","console","error","onFinishFailed","useForm","form","formRef","useRef","forceUpdate","useState","current","forceReRender","formStore","getForm"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/form/es/useForm.js"],"sourcesContent":["import { merge } from \"@rc-component/util/es/utils/set\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"./FieldContext\";\nimport { allPromiseFinish } from \"./utils/asyncUtil\";\nimport { defaultValidateMessages } from \"./utils/messages\";\nimport NameMap from \"./utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"./utils/valueUtil\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch,\n        setBatchUpdate: this.setBatchUpdate\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  watchList = [];\n  registerWatch = callback => {\n    this.watchList.push(callback);\n    return () => {\n      this.watchList = this.watchList.filter(fn => fn !== callback);\n    };\n  };\n  notifyWatch = (namePath = []) => {\n    // No need to cost perf when nothing need to watch\n    if (this.watchList.length) {\n      const values = this.getFieldsValue();\n      const allValues = this.getFieldsValue(true);\n      this.watchList.forEach(callback => {\n        callback(values, allValues, namePath);\n      });\n    }\n  };\n  notifyWatchNamePathList = [];\n  batchNotifyWatch = namePath => {\n    this.notifyWatchNamePathList.push(namePath);\n    this.batch('notifyWatch', () => {\n      this.notifyWatch(this.notifyWatchNamePathList);\n      this.notifyWatchNamePathList = [];\n    });\n  };\n\n  // ============================= Batch ============================\n  batchUpdate;\n  setBatchUpdate = batchUpdate => {\n    this.batchUpdate = batchUpdate;\n  };\n\n  // Batch call the task, only last will be called\n  batch = (key, callback) => {\n    this.batchUpdate(key, callback);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n  getFieldEntitiesForNamePathList = nameList => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    return nameList.map(name => {\n      const namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.batchNotifyWatch(namePath);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.batchNotifyWatch(namePath);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = merge(allValues, changedValues);\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}