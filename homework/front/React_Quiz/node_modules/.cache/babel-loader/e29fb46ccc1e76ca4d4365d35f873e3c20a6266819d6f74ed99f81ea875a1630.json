{"ast":null,"code":"import * as React from 'react';\nimport { FastColor } from '@ant-design/fast-color';\nimport { isPresetColor, isPresetStatusColor } from '../../_util/colors';\n/**\n * Convert color related props to a unified object,\n * which is used to flatten the compatibility requirements.\n */\nexport default function useColor(props, contextVariant) {\n  const {\n    color,\n    variant,\n    bordered\n  } = props;\n  return React.useMemo(() => {\n    const isInverseColor = color === null || color === void 0 ? void 0 : color.endsWith('-inverse');\n    // =================== Variant ===================\n    let nextVariant;\n    if (variant) {\n      // `variant` first\n      nextVariant = variant;\n    } else if (isInverseColor) {\n      // Fallback if using inverse color\n      nextVariant = 'solid';\n    } else if (bordered === false) {\n      // Fallback if using filled\n      nextVariant = 'filled';\n    } else {\n      // Finally not conflict, use context\n      nextVariant = contextVariant || 'filled';\n    }\n    // ==================== Color ====================\n    const nextColor = isInverseColor ? color === null || color === void 0 ? void 0 : color.replace('-inverse', '') : color;\n    // =============== Preset & Status ===============\n    const nextIsPreset = isPresetColor(color);\n    const nextIsStatus = isPresetStatusColor(color);\n    // ================== Customize ==================\n    // When `color` is not preset color,\n    // dynamic calculate the color pair.\n    const tagStyle = {};\n    if (!nextIsPreset && !nextIsStatus && nextColor) {\n      if (nextVariant === 'solid') {\n        tagStyle.backgroundColor = color;\n      } else {\n        const hsl = new FastColor(nextColor).toHsl();\n        hsl.l = 0.95;\n        tagStyle.backgroundColor = new FastColor(hsl).toHexString();\n        tagStyle.color = color;\n        if (nextVariant === 'outlined') {\n          tagStyle.borderColor = color;\n        }\n      }\n    }\n    return [nextVariant, nextColor, nextIsPreset, nextIsStatus, tagStyle];\n  }, [color, variant, bordered, contextVariant]);\n}","map":{"version":3,"names":["React","FastColor","isPresetColor","isPresetStatusColor","useColor","props","contextVariant","color","variant","bordered","useMemo","isInverseColor","endsWith","nextVariant","nextColor","replace","nextIsPreset","nextIsStatus","tagStyle","backgroundColor","hsl","toHsl","l","toHexString","borderColor"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/antd/es/tag/hooks/useColor.js"],"sourcesContent":["import * as React from 'react';\nimport { FastColor } from '@ant-design/fast-color';\nimport { isPresetColor, isPresetStatusColor } from '../../_util/colors';\n/**\n * Convert color related props to a unified object,\n * which is used to flatten the compatibility requirements.\n */\nexport default function useColor(props, contextVariant) {\n  const {\n    color,\n    variant,\n    bordered\n  } = props;\n  return React.useMemo(() => {\n    const isInverseColor = color?.endsWith('-inverse');\n    // =================== Variant ===================\n    let nextVariant;\n    if (variant) {\n      // `variant` first\n      nextVariant = variant;\n    } else if (isInverseColor) {\n      // Fallback if using inverse color\n      nextVariant = 'solid';\n    } else if (bordered === false) {\n      // Fallback if using filled\n      nextVariant = 'filled';\n    } else {\n      // Finally not conflict, use context\n      nextVariant = contextVariant || 'filled';\n    }\n    // ==================== Color ====================\n    const nextColor = isInverseColor ? color?.replace('-inverse', '') : color;\n    // =============== Preset & Status ===============\n    const nextIsPreset = isPresetColor(color);\n    const nextIsStatus = isPresetStatusColor(color);\n    // ================== Customize ==================\n    // When `color` is not preset color,\n    // dynamic calculate the color pair.\n    const tagStyle = {};\n    if (!nextIsPreset && !nextIsStatus && nextColor) {\n      if (nextVariant === 'solid') {\n        tagStyle.backgroundColor = color;\n      } else {\n        const hsl = new FastColor(nextColor).toHsl();\n        hsl.l = 0.95;\n        tagStyle.backgroundColor = new FastColor(hsl).toHexString();\n        tagStyle.color = color;\n        if (nextVariant === 'outlined') {\n          tagStyle.borderColor = color;\n        }\n      }\n    }\n    return [nextVariant, nextColor, nextIsPreset, nextIsStatus, tagStyle];\n  }, [color, variant, bordered, contextVariant]);\n}"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,SAAS,QAAQ,wBAAwB;AAClD,SAASC,aAAa,EAAEC,mBAAmB,QAAQ,oBAAoB;AACvE;AACA;AACA;AACA;AACA,eAAe,SAASC,QAAQA,CAACC,KAAK,EAAEC,cAAc,EAAE;EACtD,MAAM;IACJC,KAAK;IACLC,OAAO;IACPC;EACF,CAAC,GAAGJ,KAAK;EACT,OAAOL,KAAK,CAACU,OAAO,CAAC,MAAM;IACzB,MAAMC,cAAc,GAAGJ,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEK,QAAQ,CAAC,UAAU,CAAC;IAClD;IACA,IAAIC,WAAW;IACf,IAAIL,OAAO,EAAE;MACX;MACAK,WAAW,GAAGL,OAAO;IACvB,CAAC,MAAM,IAAIG,cAAc,EAAE;MACzB;MACAE,WAAW,GAAG,OAAO;IACvB,CAAC,MAAM,IAAIJ,QAAQ,KAAK,KAAK,EAAE;MAC7B;MACAI,WAAW,GAAG,QAAQ;IACxB,CAAC,MAAM;MACL;MACAA,WAAW,GAAGP,cAAc,IAAI,QAAQ;IAC1C;IACA;IACA,MAAMQ,SAAS,GAAGH,cAAc,GAAGJ,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEQ,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,GAAGR,KAAK;IACzE;IACA,MAAMS,YAAY,GAAGd,aAAa,CAACK,KAAK,CAAC;IACzC,MAAMU,YAAY,GAAGd,mBAAmB,CAACI,KAAK,CAAC;IAC/C;IACA;IACA;IACA,MAAMW,QAAQ,GAAG,CAAC,CAAC;IACnB,IAAI,CAACF,YAAY,IAAI,CAACC,YAAY,IAAIH,SAAS,EAAE;MAC/C,IAAID,WAAW,KAAK,OAAO,EAAE;QAC3BK,QAAQ,CAACC,eAAe,GAAGZ,KAAK;MAClC,CAAC,MAAM;QACL,MAAMa,GAAG,GAAG,IAAInB,SAAS,CAACa,SAAS,CAAC,CAACO,KAAK,CAAC,CAAC;QAC5CD,GAAG,CAACE,CAAC,GAAG,IAAI;QACZJ,QAAQ,CAACC,eAAe,GAAG,IAAIlB,SAAS,CAACmB,GAAG,CAAC,CAACG,WAAW,CAAC,CAAC;QAC3DL,QAAQ,CAACX,KAAK,GAAGA,KAAK;QACtB,IAAIM,WAAW,KAAK,UAAU,EAAE;UAC9BK,QAAQ,CAACM,WAAW,GAAGjB,KAAK;QAC9B;MACF;IACF;IACA,OAAO,CAACM,WAAW,EAAEC,SAAS,EAAEE,YAAY,EAAEC,YAAY,EAAEC,QAAQ,CAAC;EACvE,CAAC,EAAE,CAACX,KAAK,EAAEC,OAAO,EAAEC,QAAQ,EAAEH,cAAc,CAAC,CAAC;AAChD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}