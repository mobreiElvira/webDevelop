{"ast":null,"code":"import React from 'react';\nimport { useEvent } from '@rc-component/util';\n/**\n * Control the state of popup bind target:\n * 1. When set `target`. Do show the popup.\n * 2. When `target` is removed. Do hide the popup.\n * 3. When `target` change to another one:\n *  a. We wait motion finish of previous popup.\n *  b. Then we set new target and show the popup.\n * 4. During appear/enter animation, cache new options and apply after animation completes.\n */\nexport default function useTargetState() {\n  const [options, setOptions] = React.useState(null);\n  const [open, setOpen] = React.useState(false);\n  const [isAnimating, setIsAnimating] = React.useState(false);\n  const pendingOptionsRef = React.useRef(null);\n  const trigger = useEvent(nextOptions => {\n    if (nextOptions === false) {\n      // Clear pending options when hiding\n      pendingOptionsRef.current = null;\n      setOpen(false);\n    } else {\n      if (isAnimating && open) {\n        // If animating (appear or enter), cache new options\n        pendingOptionsRef.current = nextOptions;\n      } else {\n        setOpen(true);\n        // Set new options\n        setOptions(nextOptions);\n        pendingOptionsRef.current = null;\n\n        // Only mark as animating when transitioning from closed to open\n        if (!open) {\n          setIsAnimating(true);\n        }\n      }\n    }\n  });\n  const onVisibleChanged = useEvent(visible => {\n    if (visible) {\n      // Animation enter completed, check if there are pending options\n      setIsAnimating(false);\n      if (pendingOptionsRef.current) {\n        // Apply pending options\n        setOptions(pendingOptionsRef.current);\n        pendingOptionsRef.current = null;\n      }\n    } else {\n      // Animation leave completed\n      setIsAnimating(false);\n      pendingOptionsRef.current = null;\n    }\n  });\n  return [trigger, open, options, onVisibleChanged];\n}","map":{"version":3,"names":["React","useEvent","useTargetState","options","setOptions","useState","open","setOpen","isAnimating","setIsAnimating","pendingOptionsRef","useRef","trigger","nextOptions","current","onVisibleChanged","visible"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/trigger/es/UniqueProvider/useTargetState.js"],"sourcesContent":["import React from 'react';\nimport { useEvent } from '@rc-component/util';\n/**\n * Control the state of popup bind target:\n * 1. When set `target`. Do show the popup.\n * 2. When `target` is removed. Do hide the popup.\n * 3. When `target` change to another one:\n *  a. We wait motion finish of previous popup.\n *  b. Then we set new target and show the popup.\n * 4. During appear/enter animation, cache new options and apply after animation completes.\n */\nexport default function useTargetState() {\n  const [options, setOptions] = React.useState(null);\n  const [open, setOpen] = React.useState(false);\n  const [isAnimating, setIsAnimating] = React.useState(false);\n  const pendingOptionsRef = React.useRef(null);\n  const trigger = useEvent(nextOptions => {\n    if (nextOptions === false) {\n      // Clear pending options when hiding\n      pendingOptionsRef.current = null;\n      setOpen(false);\n    } else {\n      if (isAnimating && open) {\n        // If animating (appear or enter), cache new options\n        pendingOptionsRef.current = nextOptions;\n      } else {\n        setOpen(true);\n        // Set new options\n        setOptions(nextOptions);\n        pendingOptionsRef.current = null;\n\n        // Only mark as animating when transitioning from closed to open\n        if (!open) {\n          setIsAnimating(true);\n        }\n      }\n    }\n  });\n  const onVisibleChanged = useEvent(visible => {\n    if (visible) {\n      // Animation enter completed, check if there are pending options\n      setIsAnimating(false);\n      if (pendingOptionsRef.current) {\n        // Apply pending options\n        setOptions(pendingOptionsRef.current);\n        pendingOptionsRef.current = null;\n      }\n    } else {\n      // Animation leave completed\n      setIsAnimating(false);\n      pendingOptionsRef.current = null;\n    }\n  });\n  return [trigger, open, options, onVisibleChanged];\n}"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,QAAQ,QAAQ,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,cAAcA,CAAA,EAAG;EACvC,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGJ,KAAK,CAACK,QAAQ,CAAC,IAAI,CAAC;EAClD,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGP,KAAK,CAACK,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACG,WAAW,EAAEC,cAAc,CAAC,GAAGT,KAAK,CAACK,QAAQ,CAAC,KAAK,CAAC;EAC3D,MAAMK,iBAAiB,GAAGV,KAAK,CAACW,MAAM,CAAC,IAAI,CAAC;EAC5C,MAAMC,OAAO,GAAGX,QAAQ,CAACY,WAAW,IAAI;IACtC,IAAIA,WAAW,KAAK,KAAK,EAAE;MACzB;MACAH,iBAAiB,CAACI,OAAO,GAAG,IAAI;MAChCP,OAAO,CAAC,KAAK,CAAC;IAChB,CAAC,MAAM;MACL,IAAIC,WAAW,IAAIF,IAAI,EAAE;QACvB;QACAI,iBAAiB,CAACI,OAAO,GAAGD,WAAW;MACzC,CAAC,MAAM;QACLN,OAAO,CAAC,IAAI,CAAC;QACb;QACAH,UAAU,CAACS,WAAW,CAAC;QACvBH,iBAAiB,CAACI,OAAO,GAAG,IAAI;;QAEhC;QACA,IAAI,CAACR,IAAI,EAAE;UACTG,cAAc,CAAC,IAAI,CAAC;QACtB;MACF;IACF;EACF,CAAC,CAAC;EACF,MAAMM,gBAAgB,GAAGd,QAAQ,CAACe,OAAO,IAAI;IAC3C,IAAIA,OAAO,EAAE;MACX;MACAP,cAAc,CAAC,KAAK,CAAC;MACrB,IAAIC,iBAAiB,CAACI,OAAO,EAAE;QAC7B;QACAV,UAAU,CAACM,iBAAiB,CAACI,OAAO,CAAC;QACrCJ,iBAAiB,CAACI,OAAO,GAAG,IAAI;MAClC;IACF,CAAC,MAAM;MACL;MACAL,cAAc,CAAC,KAAK,CAAC;MACrBC,iBAAiB,CAACI,OAAO,GAAG,IAAI;IAClC;EACF,CAAC,CAAC;EACF,OAAO,CAACF,OAAO,EAAEN,IAAI,EAAEH,OAAO,EAAEY,gBAAgB,CAAC;AACnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}