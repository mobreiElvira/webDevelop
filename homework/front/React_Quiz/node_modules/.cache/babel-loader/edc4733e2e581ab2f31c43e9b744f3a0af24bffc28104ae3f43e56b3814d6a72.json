{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nfunction isPointsEq() {\n  let a1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let a2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let isAlignPoint = arguments.length > 2 ? arguments[2] : undefined;\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  const {\n    points\n  } = align;\n  const placements = Object.keys(builtinPlacements);\n  for (let i = 0; i < placements.length; i += 1) {\n    var _builtinPlacements$pl;\n    const placement = placements[i];\n    if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {\n      return \"\".concat(prefixCls, \"-placement-\").concat(placement);\n    }\n  }\n  return '';\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\nexport function collectScroller(ele) {\n  const scrollerList = [];\n  let current = ele === null || ele === void 0 ? void 0 : ele.parentElement;\n  const scrollStyle = ['hidden', 'scroll', 'clip', 'auto'];\n  while (current) {\n    const {\n      overflowX,\n      overflowY,\n      overflow\n    } = getWin(current).getComputedStyle(current);\n    if ([overflowX, overflowY, overflow].some(o => scrollStyle.includes(o))) {\n      scrollerList.push(current);\n    }\n    current = current.parentElement;\n  }\n  return scrollerList;\n}\nexport function toNum(num) {\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return Number.isNaN(num) ? defaultValue : num;\n}\nfunction getPxValue(val) {\n  return toNum(parseFloat(val), 0);\n}\n/**\n *\n *\n *  **************************************\n *  *              Border                *\n *  *     **************************     *\n *  *     *                  *     *     *\n *  *  B  *                  *  S  *  B  *\n *  *  o  *                  *  c  *  o  *\n *  *  r  *      Content     *  r  *  r  *\n *  *  d  *                  *  o  *  d  *\n *  *  e  *                  *  l  *  e  *\n *  *  r  ********************  l  *  r  *\n *  *     *        Scroll          *     *\n *  *     **************************     *\n *  *              Border                *\n *  **************************************\n *\n */\n/**\n * Get visible area of element\n */\nexport function getVisibleArea(initArea, scrollerList) {\n  const visibleArea = _objectSpread({}, initArea);\n  (scrollerList || []).forEach(ele => {\n    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {\n      return;\n    }\n\n    // Skip if static position which will not affect visible area\n    const {\n      overflow,\n      overflowClipMargin,\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth\n    } = getWin(ele).getComputedStyle(ele);\n    const eleRect = ele.getBoundingClientRect();\n    const {\n      offsetHeight: eleOutHeight,\n      clientHeight: eleInnerHeight,\n      offsetWidth: eleOutWidth,\n      clientWidth: eleInnerWidth\n    } = ele;\n    const borderTopNum = getPxValue(borderTopWidth);\n    const borderBottomNum = getPxValue(borderBottomWidth);\n    const borderLeftNum = getPxValue(borderLeftWidth);\n    const borderRightNum = getPxValue(borderRightWidth);\n    const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n\n    // Original visible area\n    const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;\n    const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;\n\n    // Cut border size\n    const scaledBorderTopWidth = borderTopNum * scaleY;\n    const scaledBorderBottomWidth = borderBottomNum * scaleY;\n    const scaledBorderLeftWidth = borderLeftNum * scaleX;\n    const scaledBorderRightWidth = borderRightNum * scaleX;\n\n    // Clip margin\n    let clipMarginWidth = 0;\n    let clipMarginHeight = 0;\n    if (overflow === 'clip') {\n      const clipNum = getPxValue(overflowClipMargin);\n      clipMarginWidth = clipNum * scaleX;\n      clipMarginHeight = clipNum * scaleY;\n    }\n\n    // Region\n    const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;\n    const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;\n    const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;\n    const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleLeft);\n    visibleArea.top = Math.max(visibleArea.top, eleTop);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}","map":{"version":3,"names":["isPointsEq","a1","arguments","length","undefined","a2","isAlignPoint","getAlignPopupClassName","builtinPlacements","prefixCls","align","points","placements","Object","keys","i","_builtinPlacements$pl","placement","concat","getWin","ele","ownerDocument","defaultView","collectScroller","scrollerList","current","parentElement","scrollStyle","overflowX","overflowY","overflow","getComputedStyle","some","o","includes","push","toNum","num","defaultValue","Number","isNaN","getPxValue","val","parseFloat","getVisibleArea","initArea","visibleArea","_objectSpread","forEach","HTMLBodyElement","HTMLHtmlElement","overflowClipMargin","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","eleRect","getBoundingClientRect","offsetHeight","eleOutHeight","clientHeight","eleInnerHeight","offsetWidth","eleOutWidth","clientWidth","eleInnerWidth","borderTopNum","borderBottomNum","borderLeftNum","borderRightNum","scaleX","Math","round","width","scaleY","height","eleScrollWidth","eleScrollHeight","scaledBorderTopWidth","scaledBorderBottomWidth","scaledBorderLeftWidth","scaledBorderRightWidth","clipMarginWidth","clipMarginHeight","clipNum","eleLeft","x","eleTop","y","eleRight","eleBottom","left","max","top","right","min","bottom"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/trigger/es/util.js"],"sourcesContent":["function isPointsEq(a1 = [], a2 = [], isAlignPoint) {\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  const {\n    points\n  } = align;\n  const placements = Object.keys(builtinPlacements);\n  for (let i = 0; i < placements.length; i += 1) {\n    const placement = placements[i];\n    if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) {\n      return `${prefixCls}-placement-${placement}`;\n    }\n  }\n  return '';\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\nexport function collectScroller(ele) {\n  const scrollerList = [];\n  let current = ele?.parentElement;\n  const scrollStyle = ['hidden', 'scroll', 'clip', 'auto'];\n  while (current) {\n    const {\n      overflowX,\n      overflowY,\n      overflow\n    } = getWin(current).getComputedStyle(current);\n    if ([overflowX, overflowY, overflow].some(o => scrollStyle.includes(o))) {\n      scrollerList.push(current);\n    }\n    current = current.parentElement;\n  }\n  return scrollerList;\n}\nexport function toNum(num, defaultValue = 1) {\n  return Number.isNaN(num) ? defaultValue : num;\n}\nfunction getPxValue(val) {\n  return toNum(parseFloat(val), 0);\n}\n/**\n *\n *\n *  **************************************\n *  *              Border                *\n *  *     **************************     *\n *  *     *                  *     *     *\n *  *  B  *                  *  S  *  B  *\n *  *  o  *                  *  c  *  o  *\n *  *  r  *      Content     *  r  *  r  *\n *  *  d  *                  *  o  *  d  *\n *  *  e  *                  *  l  *  e  *\n *  *  r  ********************  l  *  r  *\n *  *     *        Scroll          *     *\n *  *     **************************     *\n *  *              Border                *\n *  **************************************\n *\n */\n/**\n * Get visible area of element\n */\nexport function getVisibleArea(initArea, scrollerList) {\n  const visibleArea = {\n    ...initArea\n  };\n  (scrollerList || []).forEach(ele => {\n    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {\n      return;\n    }\n\n    // Skip if static position which will not affect visible area\n    const {\n      overflow,\n      overflowClipMargin,\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth\n    } = getWin(ele).getComputedStyle(ele);\n    const eleRect = ele.getBoundingClientRect();\n    const {\n      offsetHeight: eleOutHeight,\n      clientHeight: eleInnerHeight,\n      offsetWidth: eleOutWidth,\n      clientWidth: eleInnerWidth\n    } = ele;\n    const borderTopNum = getPxValue(borderTopWidth);\n    const borderBottomNum = getPxValue(borderBottomWidth);\n    const borderLeftNum = getPxValue(borderLeftWidth);\n    const borderRightNum = getPxValue(borderRightWidth);\n    const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n\n    // Original visible area\n    const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;\n    const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;\n\n    // Cut border size\n    const scaledBorderTopWidth = borderTopNum * scaleY;\n    const scaledBorderBottomWidth = borderBottomNum * scaleY;\n    const scaledBorderLeftWidth = borderLeftNum * scaleX;\n    const scaledBorderRightWidth = borderRightNum * scaleX;\n\n    // Clip margin\n    let clipMarginWidth = 0;\n    let clipMarginHeight = 0;\n    if (overflow === 'clip') {\n      const clipNum = getPxValue(overflowClipMargin);\n      clipMarginWidth = clipNum * scaleX;\n      clipMarginHeight = clipNum * scaleY;\n    }\n\n    // Region\n    const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;\n    const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;\n    const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;\n    const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleLeft);\n    visibleArea.top = Math.max(visibleArea.top, eleTop);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}