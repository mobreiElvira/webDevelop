{"ast":null,"code":"import getValue from \"@rc-component/util/es/utils/get\";\nimport setValue from \"@rc-component/util/es/utils/set\";\nimport { toArray } from \"./typeUtil\";\nexport { getValue, setValue };\n\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\n\n/**\n * Create a new store object that contains only the values referenced by\n * the provided list of name paths.\n */\nexport function cloneByNamePathList(store, namePathList) {\n  let newStore = {};\n  namePathList.forEach(namePath => {\n    const value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\n\n/**\n * Check if `namePathList` includes `namePath`.\n * @param namePathList A list of `InternalNamePath[]`\n * @param namePath Compare `InternalNamePath`\n * @param partialMatch True will make `[a, b]` match `[a, b, c]`\n */\nexport function containsNamePath(namePathList, namePath) {\n  let partialMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return namePathList && namePathList.some(path => matchNamePath(namePath, path, partialMatch));\n}\n\n/**\n * Check if `namePath` is super set or equal of `subNamePath`.\n * @param namePath A list of `InternalNamePath[]`\n * @param subNamePath Compare `InternalNamePath`\n * @param partialMatch True will make `[a, b]` match `[a, b, c]`\n */\nexport function matchNamePath(namePath, subNamePath) {\n  let partialMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!namePath || !subNamePath) {\n    return false;\n  }\n  if (!partialMatch && namePath.length !== subNamePath.length) {\n    return false;\n  }\n  return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);\n}\n\n// Like `shallowEqual`, but we not check the data which may cause re-render\n\nexport function isSimilar(source, target) {\n  if (source === target) {\n    return true;\n  }\n  if (!source && target || source && !target) {\n    return false;\n  }\n  if (!source || !target || typeof source !== 'object' || typeof target !== 'object') {\n    return false;\n  }\n  const sourceKeys = Object.keys(source);\n  const targetKeys = Object.keys(target);\n  const keys = new Set([...sourceKeys, ...targetKeys]);\n  return [...keys].every(key => {\n    const sourceValue = source[key];\n    const targetValue = target[key];\n    if (typeof sourceValue === 'function' && typeof targetValue === 'function') {\n      return true;\n    }\n    return sourceValue === targetValue;\n  });\n}\nexport function defaultGetValueFromEvent(valuePropName) {\n  const event = arguments.length <= 1 ? undefined : arguments[1];\n  if (event && event.target && typeof event.target === 'object' && valuePropName in event.target) {\n    return event.target[valuePropName];\n  }\n  return event;\n}\n\n/**\n * Moves an array item from one position in an array to another.\n *\n * Note: This is a pure function so a new array will be returned, instead\n * of altering the array argument.\n *\n * @param array         Array in which to move an item.         (required)\n * @param moveIndex     The index of the item to move.          (required)\n * @param toIndex       The index to move item at moveIndex to. (required)\n */\nexport function move(array, moveIndex, toIndex) {\n  const {\n    length\n  } = array;\n  if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {\n    return array;\n  }\n  const item = array[moveIndex];\n  const diff = moveIndex - toIndex;\n  if (diff > 0) {\n    // move left\n    return [...array.slice(0, toIndex), item, ...array.slice(toIndex, moveIndex), ...array.slice(moveIndex + 1, length)];\n  }\n  if (diff < 0) {\n    // move right\n    return [...array.slice(0, moveIndex), ...array.slice(moveIndex + 1, toIndex + 1), item, ...array.slice(toIndex + 1, length)];\n  }\n  return array;\n}","map":{"version":3,"names":["getValue","setValue","toArray","getNamePath","path","cloneByNamePathList","store","namePathList","newStore","forEach","namePath","value","containsNamePath","partialMatch","arguments","length","undefined","some","matchNamePath","subNamePath","every","nameUnit","i","isSimilar","source","target","sourceKeys","Object","keys","targetKeys","Set","key","sourceValue","targetValue","defaultGetValueFromEvent","valuePropName","event","move","array","moveIndex","toIndex","item","diff","slice"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/form/es/utils/valueUtil.js"],"sourcesContent":["import getValue from \"@rc-component/util/es/utils/get\";\nimport setValue from \"@rc-component/util/es/utils/set\";\nimport { toArray } from \"./typeUtil\";\nexport { getValue, setValue };\n\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\n\n/**\n * Create a new store object that contains only the values referenced by\n * the provided list of name paths.\n */\nexport function cloneByNamePathList(store, namePathList) {\n  let newStore = {};\n  namePathList.forEach(namePath => {\n    const value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\n\n/**\n * Check if `namePathList` includes `namePath`.\n * @param namePathList A list of `InternalNamePath[]`\n * @param namePath Compare `InternalNamePath`\n * @param partialMatch True will make `[a, b]` match `[a, b, c]`\n */\nexport function containsNamePath(namePathList, namePath, partialMatch = false) {\n  return namePathList && namePathList.some(path => matchNamePath(namePath, path, partialMatch));\n}\n\n/**\n * Check if `namePath` is super set or equal of `subNamePath`.\n * @param namePath A list of `InternalNamePath[]`\n * @param subNamePath Compare `InternalNamePath`\n * @param partialMatch True will make `[a, b]` match `[a, b, c]`\n */\nexport function matchNamePath(namePath, subNamePath, partialMatch = false) {\n  if (!namePath || !subNamePath) {\n    return false;\n  }\n  if (!partialMatch && namePath.length !== subNamePath.length) {\n    return false;\n  }\n  return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);\n}\n\n// Like `shallowEqual`, but we not check the data which may cause re-render\n\nexport function isSimilar(source, target) {\n  if (source === target) {\n    return true;\n  }\n  if (!source && target || source && !target) {\n    return false;\n  }\n  if (!source || !target || typeof source !== 'object' || typeof target !== 'object') {\n    return false;\n  }\n  const sourceKeys = Object.keys(source);\n  const targetKeys = Object.keys(target);\n  const keys = new Set([...sourceKeys, ...targetKeys]);\n  return [...keys].every(key => {\n    const sourceValue = source[key];\n    const targetValue = target[key];\n    if (typeof sourceValue === 'function' && typeof targetValue === 'function') {\n      return true;\n    }\n    return sourceValue === targetValue;\n  });\n}\nexport function defaultGetValueFromEvent(valuePropName, ...args) {\n  const event = args[0];\n  if (event && event.target && typeof event.target === 'object' && valuePropName in event.target) {\n    return event.target[valuePropName];\n  }\n  return event;\n}\n\n/**\n * Moves an array item from one position in an array to another.\n *\n * Note: This is a pure function so a new array will be returned, instead\n * of altering the array argument.\n *\n * @param array         Array in which to move an item.         (required)\n * @param moveIndex     The index of the item to move.          (required)\n * @param toIndex       The index to move item at moveIndex to. (required)\n */\nexport function move(array, moveIndex, toIndex) {\n  const {\n    length\n  } = array;\n  if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {\n    return array;\n  }\n  const item = array[moveIndex];\n  const diff = moveIndex - toIndex;\n  if (diff > 0) {\n    // move left\n    return [...array.slice(0, toIndex), item, ...array.slice(toIndex, moveIndex), ...array.slice(moveIndex + 1, length)];\n  }\n  if (diff < 0) {\n    // move right\n    return [...array.slice(0, moveIndex), ...array.slice(moveIndex + 1, toIndex + 1), item, ...array.slice(toIndex + 1, length)];\n  }\n  return array;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}