{"ast":null,"code":"import useEvent from \"./useEvent\";\nimport { useLayoutUpdateEffect } from \"./useLayoutEffect\";\nimport useState from \"./useState\";\n/** We only think `undefined` is empty */\nfunction hasValue(value) {\n  return value !== undefined;\n}\n\n/**\n * @deprecated Please use `useControlledState` instead if not need support < React 18.\n * Similar to `useState` but will use props value if provided.\n * Note that internal use rc-util `useState` hook.\n */\nexport default function useMergedState(defaultStateValue, option) {\n  const {\n    defaultValue,\n    value,\n    onChange,\n    postState\n  } = option || {};\n\n  // ======================= Init =======================\n  const [innerValue, setInnerValue] = useState(() => {\n    if (hasValue(value)) {\n      return value;\n    } else if (hasValue(defaultValue)) {\n      return typeof defaultValue === 'function' ? defaultValue() : defaultValue;\n    } else {\n      return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;\n    }\n  });\n  const mergedValue = value !== undefined ? value : innerValue;\n  const postMergedValue = postState ? postState(mergedValue) : mergedValue;\n\n  // ====================== Change ======================\n  const onChangeFn = useEvent(onChange);\n  const [prevValue, setPrevValue] = useState([mergedValue]);\n  useLayoutUpdateEffect(() => {\n    const prev = prevValue[0];\n    if (innerValue !== prev) {\n      onChangeFn(innerValue, prev);\n    }\n  }, [prevValue]);\n\n  // Sync value back to `undefined` when it from control to un-control\n  useLayoutUpdateEffect(() => {\n    if (!hasValue(value)) {\n      setInnerValue(value);\n    }\n  }, [value]);\n\n  // ====================== Update ======================\n  const triggerChange = useEvent((updater, ignoreDestroy) => {\n    setInnerValue(updater, ignoreDestroy);\n    setPrevValue([mergedValue], ignoreDestroy);\n  });\n  return [postMergedValue, triggerChange];\n}","map":{"version":3,"names":["useEvent","useLayoutUpdateEffect","useState","hasValue","value","undefined","useMergedState","defaultStateValue","option","defaultValue","onChange","postState","innerValue","setInnerValue","mergedValue","postMergedValue","onChangeFn","prevValue","setPrevValue","prev","triggerChange","updater","ignoreDestroy"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/util/es/hooks/useMergedState.js"],"sourcesContent":["import useEvent from \"./useEvent\";\nimport { useLayoutUpdateEffect } from \"./useLayoutEffect\";\nimport useState from \"./useState\";\n/** We only think `undefined` is empty */\nfunction hasValue(value) {\n  return value !== undefined;\n}\n\n/**\n * @deprecated Please use `useControlledState` instead if not need support < React 18.\n * Similar to `useState` but will use props value if provided.\n * Note that internal use rc-util `useState` hook.\n */\nexport default function useMergedState(defaultStateValue, option) {\n  const {\n    defaultValue,\n    value,\n    onChange,\n    postState\n  } = option || {};\n\n  // ======================= Init =======================\n  const [innerValue, setInnerValue] = useState(() => {\n    if (hasValue(value)) {\n      return value;\n    } else if (hasValue(defaultValue)) {\n      return typeof defaultValue === 'function' ? defaultValue() : defaultValue;\n    } else {\n      return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;\n    }\n  });\n  const mergedValue = value !== undefined ? value : innerValue;\n  const postMergedValue = postState ? postState(mergedValue) : mergedValue;\n\n  // ====================== Change ======================\n  const onChangeFn = useEvent(onChange);\n  const [prevValue, setPrevValue] = useState([mergedValue]);\n  useLayoutUpdateEffect(() => {\n    const prev = prevValue[0];\n    if (innerValue !== prev) {\n      onChangeFn(innerValue, prev);\n    }\n  }, [prevValue]);\n\n  // Sync value back to `undefined` when it from control to un-control\n  useLayoutUpdateEffect(() => {\n    if (!hasValue(value)) {\n      setInnerValue(value);\n    }\n  }, [value]);\n\n  // ====================== Update ======================\n  const triggerChange = useEvent((updater, ignoreDestroy) => {\n    setInnerValue(updater, ignoreDestroy);\n    setPrevValue([mergedValue], ignoreDestroy);\n  });\n  return [postMergedValue, triggerChange];\n}"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,YAAY;AACjC,SAASC,qBAAqB,QAAQ,mBAAmB;AACzD,OAAOC,QAAQ,MAAM,YAAY;AACjC;AACA,SAASC,QAAQA,CAACC,KAAK,EAAE;EACvB,OAAOA,KAAK,KAAKC,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,cAAcA,CAACC,iBAAiB,EAAEC,MAAM,EAAE;EAChE,MAAM;IACJC,YAAY;IACZL,KAAK;IACLM,QAAQ;IACRC;EACF,CAAC,GAAGH,MAAM,IAAI,CAAC,CAAC;;EAEhB;EACA,MAAM,CAACI,UAAU,EAAEC,aAAa,CAAC,GAAGX,QAAQ,CAAC,MAAM;IACjD,IAAIC,QAAQ,CAACC,KAAK,CAAC,EAAE;MACnB,OAAOA,KAAK;IACd,CAAC,MAAM,IAAID,QAAQ,CAACM,YAAY,CAAC,EAAE;MACjC,OAAO,OAAOA,YAAY,KAAK,UAAU,GAAGA,YAAY,CAAC,CAAC,GAAGA,YAAY;IAC3E,CAAC,MAAM;MACL,OAAO,OAAOF,iBAAiB,KAAK,UAAU,GAAGA,iBAAiB,CAAC,CAAC,GAAGA,iBAAiB;IAC1F;EACF,CAAC,CAAC;EACF,MAAMO,WAAW,GAAGV,KAAK,KAAKC,SAAS,GAAGD,KAAK,GAAGQ,UAAU;EAC5D,MAAMG,eAAe,GAAGJ,SAAS,GAAGA,SAAS,CAACG,WAAW,CAAC,GAAGA,WAAW;;EAExE;EACA,MAAME,UAAU,GAAGhB,QAAQ,CAACU,QAAQ,CAAC;EACrC,MAAM,CAACO,SAAS,EAAEC,YAAY,CAAC,GAAGhB,QAAQ,CAAC,CAACY,WAAW,CAAC,CAAC;EACzDb,qBAAqB,CAAC,MAAM;IAC1B,MAAMkB,IAAI,GAAGF,SAAS,CAAC,CAAC,CAAC;IACzB,IAAIL,UAAU,KAAKO,IAAI,EAAE;MACvBH,UAAU,CAACJ,UAAU,EAAEO,IAAI,CAAC;IAC9B;EACF,CAAC,EAAE,CAACF,SAAS,CAAC,CAAC;;EAEf;EACAhB,qBAAqB,CAAC,MAAM;IAC1B,IAAI,CAACE,QAAQ,CAACC,KAAK,CAAC,EAAE;MACpBS,aAAa,CAACT,KAAK,CAAC;IACtB;EACF,CAAC,EAAE,CAACA,KAAK,CAAC,CAAC;;EAEX;EACA,MAAMgB,aAAa,GAAGpB,QAAQ,CAAC,CAACqB,OAAO,EAAEC,aAAa,KAAK;IACzDT,aAAa,CAACQ,OAAO,EAAEC,aAAa,CAAC;IACrCJ,YAAY,CAAC,CAACJ,WAAW,CAAC,EAAEQ,aAAa,CAAC;EAC5C,CAAC,CAAC;EACF,OAAO,CAACP,eAAe,EAAEK,aAAa,CAAC;AACzC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}