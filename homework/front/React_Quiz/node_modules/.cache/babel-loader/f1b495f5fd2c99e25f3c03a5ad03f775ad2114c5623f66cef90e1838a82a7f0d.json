{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport hash from '@emotion/hash';\nimport canUseDom from \"@rc-component/util/es/Dom/canUseDom\";\nimport { removeCSS, updateCSS } from \"@rc-component/util/es/Dom/dynamicCSS\";\nimport { ATTR_MARK, ATTR_TOKEN } from \"../StyleContext\";\nimport { Theme } from \"../theme\";\n\n// Create a cache for memo concat\n\nconst resultCache = new WeakMap();\nconst RESULT_VALUE = {};\nexport function memoResult(callback, deps) {\n  let current = resultCache;\n  for (let i = 0; i < deps.length; i += 1) {\n    const dep = deps[i];\n    if (!current.has(dep)) {\n      current.set(dep, new WeakMap());\n    }\n    current = current.get(dep);\n  }\n  if (!current.has(RESULT_VALUE)) {\n    current.set(RESULT_VALUE, callback());\n  }\n  return current.get(RESULT_VALUE);\n}\n\n// Create a cache here to avoid always loop generate\nconst flattenTokenCache = new WeakMap();\n\n/**\n * Flatten token to string, this will auto cache the result when token not change\n */\nexport function flattenToken(token) {\n  let str = flattenTokenCache.get(token) || '';\n  if (!str) {\n    Object.keys(token).forEach(key => {\n      const value = token[key];\n      str += key;\n      if (value instanceof Theme) {\n        str += value.id;\n      } else if (value && typeof value === 'object') {\n        str += flattenToken(value);\n      } else {\n        str += value;\n      }\n    });\n\n    // https://github.com/ant-design/ant-design/issues/48386\n    // Should hash the string to avoid style tag name too long\n    str = hash(str);\n\n    // Put in cache\n    flattenTokenCache.set(token, str);\n  }\n  return str;\n}\n\n/**\n * Convert derivative token to key string\n */\nexport function token2key(token, salt) {\n  return hash(\"\".concat(salt, \"_\").concat(flattenToken(token)));\n}\nconst randomSelectorKey = \"random-\".concat(Date.now(), \"-\").concat(Math.random()).replace(/\\./g, '');\n\n// Magic `content` for detect selector support\nconst checkContent = '_bAmBoO_';\nfunction supportSelector(styleStr, handleElement, supportCheck) {\n  if (canUseDom()) {\n    var _getComputedStyle$con, _ele$parentNode;\n    updateCSS(styleStr, randomSelectorKey);\n    const ele = document.createElement('div');\n    ele.style.position = 'fixed';\n    ele.style.left = '0';\n    ele.style.top = '0';\n    handleElement === null || handleElement === void 0 || handleElement(ele);\n    document.body.appendChild(ele);\n    if (process.env.NODE_ENV !== 'production') {\n      ele.innerHTML = 'Test';\n      ele.style.zIndex = '9999999';\n    }\n    const support = supportCheck ? supportCheck(ele) : (_getComputedStyle$con = getComputedStyle(ele).content) === null || _getComputedStyle$con === void 0 ? void 0 : _getComputedStyle$con.includes(checkContent);\n    (_ele$parentNode = ele.parentNode) === null || _ele$parentNode === void 0 || _ele$parentNode.removeChild(ele);\n    removeCSS(randomSelectorKey);\n    return support;\n  }\n  return false;\n}\nlet canLayer = undefined;\nexport function supportLayer() {\n  if (canLayer === undefined) {\n    canLayer = supportSelector(\"@layer \".concat(randomSelectorKey, \" { .\").concat(randomSelectorKey, \" { content: \\\"\").concat(checkContent, \"\\\"!important; } }\"), ele => {\n      ele.className = randomSelectorKey;\n    });\n  }\n  return canLayer;\n}\nlet canWhere = undefined;\nexport function supportWhere() {\n  if (canWhere === undefined) {\n    canWhere = supportSelector(\":where(.\".concat(randomSelectorKey, \") { content: \\\"\").concat(checkContent, \"\\\"!important; }\"), ele => {\n      ele.className = randomSelectorKey;\n    });\n  }\n  return canWhere;\n}\nlet canLogic = undefined;\nexport function supportLogicProps() {\n  if (canLogic === undefined) {\n    canLogic = supportSelector(\".\".concat(randomSelectorKey, \" { inset-block: 93px !important; }\"), ele => {\n      ele.className = randomSelectorKey;\n    }, ele => getComputedStyle(ele).bottom === '93px');\n  }\n  return canLogic;\n}\nexport const isClientSide = canUseDom();\nexport function unit(num) {\n  if (typeof num === 'number') {\n    return \"\".concat(num, \"px\");\n  }\n  return num;\n}\nexport function toStyleStr(style, tokenKey, styleId) {\n  let customizeAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let plain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  if (plain) {\n    return style;\n  }\n  const attrs = _objectSpread(_objectSpread({}, customizeAttrs), {}, {\n    [ATTR_TOKEN]: tokenKey,\n    [ATTR_MARK]: styleId\n  });\n  const attrStr = Object.keys(attrs).map(attr => {\n    const val = attrs[attr];\n    return val ? \"\".concat(attr, \"=\\\"\").concat(val, \"\\\"\") : null;\n  }).filter(v => v).join(' ');\n  return \"<style \".concat(attrStr, \">\").concat(style, \"</style>\");\n}\nexport function where(options) {\n  const {\n    hashCls,\n    hashPriority = 'low'\n  } = options || {};\n  if (!hashCls) {\n    return '';\n  }\n  const hashSelector = \".\".concat(hashCls);\n  return hashPriority === 'low' ? \":where(\".concat(hashSelector, \")\") : hashSelector;\n}","map":{"version":3,"names":["hash","canUseDom","removeCSS","updateCSS","ATTR_MARK","ATTR_TOKEN","Theme","resultCache","WeakMap","RESULT_VALUE","memoResult","callback","deps","current","i","length","dep","has","set","get","flattenTokenCache","flattenToken","token","str","Object","keys","forEach","key","value","id","token2key","salt","concat","randomSelectorKey","Date","now","Math","random","replace","checkContent","supportSelector","styleStr","handleElement","supportCheck","_getComputedStyle$con","_ele$parentNode","ele","document","createElement","style","position","left","top","body","appendChild","process","env","NODE_ENV","innerHTML","zIndex","support","getComputedStyle","content","includes","parentNode","removeChild","canLayer","undefined","supportLayer","className","canWhere","supportWhere","canLogic","supportLogicProps","bottom","isClientSide","unit","num","toStyleStr","tokenKey","styleId","customizeAttrs","arguments","plain","attrs","_objectSpread","attrStr","map","attr","val","filter","v","join","where","options","hashCls","hashPriority","hashSelector"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@ant-design/cssinjs/es/util/index.js"],"sourcesContent":["import hash from '@emotion/hash';\nimport canUseDom from \"@rc-component/util/es/Dom/canUseDom\";\nimport { removeCSS, updateCSS } from \"@rc-component/util/es/Dom/dynamicCSS\";\nimport { ATTR_MARK, ATTR_TOKEN } from \"../StyleContext\";\nimport { Theme } from \"../theme\";\n\n// Create a cache for memo concat\n\nconst resultCache = new WeakMap();\nconst RESULT_VALUE = {};\nexport function memoResult(callback, deps) {\n  let current = resultCache;\n  for (let i = 0; i < deps.length; i += 1) {\n    const dep = deps[i];\n    if (!current.has(dep)) {\n      current.set(dep, new WeakMap());\n    }\n    current = current.get(dep);\n  }\n  if (!current.has(RESULT_VALUE)) {\n    current.set(RESULT_VALUE, callback());\n  }\n  return current.get(RESULT_VALUE);\n}\n\n// Create a cache here to avoid always loop generate\nconst flattenTokenCache = new WeakMap();\n\n/**\n * Flatten token to string, this will auto cache the result when token not change\n */\nexport function flattenToken(token) {\n  let str = flattenTokenCache.get(token) || '';\n  if (!str) {\n    Object.keys(token).forEach(key => {\n      const value = token[key];\n      str += key;\n      if (value instanceof Theme) {\n        str += value.id;\n      } else if (value && typeof value === 'object') {\n        str += flattenToken(value);\n      } else {\n        str += value;\n      }\n    });\n\n    // https://github.com/ant-design/ant-design/issues/48386\n    // Should hash the string to avoid style tag name too long\n    str = hash(str);\n\n    // Put in cache\n    flattenTokenCache.set(token, str);\n  }\n  return str;\n}\n\n/**\n * Convert derivative token to key string\n */\nexport function token2key(token, salt) {\n  return hash(`${salt}_${flattenToken(token)}`);\n}\nconst randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\\./g, '');\n\n// Magic `content` for detect selector support\nconst checkContent = '_bAmBoO_';\nfunction supportSelector(styleStr, handleElement, supportCheck) {\n  if (canUseDom()) {\n    updateCSS(styleStr, randomSelectorKey);\n    const ele = document.createElement('div');\n    ele.style.position = 'fixed';\n    ele.style.left = '0';\n    ele.style.top = '0';\n    handleElement?.(ele);\n    document.body.appendChild(ele);\n    if (process.env.NODE_ENV !== 'production') {\n      ele.innerHTML = 'Test';\n      ele.style.zIndex = '9999999';\n    }\n    const support = supportCheck ? supportCheck(ele) : getComputedStyle(ele).content?.includes(checkContent);\n    ele.parentNode?.removeChild(ele);\n    removeCSS(randomSelectorKey);\n    return support;\n  }\n  return false;\n}\nlet canLayer = undefined;\nexport function supportLayer() {\n  if (canLayer === undefined) {\n    canLayer = supportSelector(`@layer ${randomSelectorKey} { .${randomSelectorKey} { content: \"${checkContent}\"!important; } }`, ele => {\n      ele.className = randomSelectorKey;\n    });\n  }\n  return canLayer;\n}\nlet canWhere = undefined;\nexport function supportWhere() {\n  if (canWhere === undefined) {\n    canWhere = supportSelector(`:where(.${randomSelectorKey}) { content: \"${checkContent}\"!important; }`, ele => {\n      ele.className = randomSelectorKey;\n    });\n  }\n  return canWhere;\n}\nlet canLogic = undefined;\nexport function supportLogicProps() {\n  if (canLogic === undefined) {\n    canLogic = supportSelector(`.${randomSelectorKey} { inset-block: 93px !important; }`, ele => {\n      ele.className = randomSelectorKey;\n    }, ele => getComputedStyle(ele).bottom === '93px');\n  }\n  return canLogic;\n}\nexport const isClientSide = canUseDom();\nexport function unit(num) {\n  if (typeof num === 'number') {\n    return `${num}px`;\n  }\n  return num;\n}\nexport function toStyleStr(style, tokenKey, styleId, customizeAttrs = {}, plain = false) {\n  if (plain) {\n    return style;\n  }\n  const attrs = {\n    ...customizeAttrs,\n    [ATTR_TOKEN]: tokenKey,\n    [ATTR_MARK]: styleId\n  };\n  const attrStr = Object.keys(attrs).map(attr => {\n    const val = attrs[attr];\n    return val ? `${attr}=\"${val}\"` : null;\n  }).filter(v => v).join(' ');\n  return `<style ${attrStr}>${style}</style>`;\n}\nexport function where(options) {\n  const {\n    hashCls,\n    hashPriority = 'low'\n  } = options || {};\n  if (!hashCls) {\n    return '';\n  }\n  const hashSelector = `.${hashCls}`;\n  return hashPriority === 'low' ? `:where(${hashSelector})` : hashSelector;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}