{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n// TODO: https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/treeview/treeview-2/treeview-2a.html\n// Fully accessibility support\n\nimport { clsx } from 'clsx';\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  constructor() {\n    var _this;\n    super(...arguments);\n    _this = this;\n    _defineProperty(this, \"destroyed\", false);\n    _defineProperty(this, \"delayedDragEnterLogic\", void 0);\n    _defineProperty(this, \"loadingRetryTimes\", {});\n    _defineProperty(this, \"state\", {\n      keyEntities: {},\n      indent: null,\n      selectedKeys: [],\n      checkedKeys: [],\n      halfCheckedKeys: [],\n      loadedKeys: [],\n      loadingKeys: [],\n      expandedKeys: [],\n      draggingNodeKey: null,\n      dragChildrenKeys: [],\n      // dropTargetKey is the key of abstract-drop-node\n      // the abstract-drop-node is the real drop node when drag and drop\n      // not the DOM drag over node\n      dropTargetKey: null,\n      dropPosition: null,\n      // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n      dropContainerKey: null,\n      // the container key of abstract-drop-node if dropPosition is -1 or 1\n      dropLevelOffset: null,\n      // the drop level offset of abstract-drag-over-node\n      dropTargetPos: null,\n      // the pos of abstract-drop-node\n      dropAllowed: true,\n      // if drop to abstract-drop-node is allowed\n      // the abstract-drag-over-node\n      // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n      // abstract-drag-over-node is the top node\n      dragOverNodeKey: null,\n      treeData: [],\n      flattenNodes: [],\n      focused: false,\n      activeKey: null,\n      listChanging: false,\n      prevProps: null,\n      fieldNames: fillFieldNames()\n    });\n    _defineProperty(this, \"dragStartMousePosition\", null);\n    _defineProperty(this, \"dragNodeProps\", null);\n    _defineProperty(this, \"currentMouseOverDroppableNodeKey\", null);\n    _defineProperty(this, \"listRef\", /*#__PURE__*/React.createRef());\n    _defineProperty(this, \"onNodeDragStart\", (event, nodeProps) => {\n      const {\n        expandedKeys,\n        keyEntities\n      } = this.state;\n      const {\n        onDragStart\n      } = this.props;\n      const {\n        eventKey\n      } = nodeProps;\n      this.dragNodeProps = nodeProps;\n      this.dragStartMousePosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      const newExpandedKeys = arrDel(expandedKeys, eventKey);\n      this.setState({\n        draggingNodeKey: eventKey,\n        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n        indent: this.listRef.current.getIndentWidth()\n      });\n      this.setExpandedKeys(newExpandedKeys);\n      window.addEventListener('dragend', this.onWindowDragEnd);\n      onDragStart === null || onDragStart === void 0 || onDragStart({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n    });\n    /**\n     * [Legacy] Select handler is smaller than node,\n     * so that this will trigger when drag enter node or select handler.\n     * This is a little tricky if customize css without padding.\n     * Better for use mouse move event to refresh drag state.\n     * But let's just keep it to avoid event trigger logic change.\n     */\n    _defineProperty(this, \"onNodeDragEnter\", (event, nodeProps) => {\n      const {\n        expandedKeys,\n        keyEntities,\n        dragChildrenKeys,\n        flattenNodes,\n        indent\n      } = this.state;\n      const {\n        onDragEnter,\n        onExpand,\n        allowDrop,\n        direction\n      } = this.props;\n      const {\n        pos,\n        eventKey\n      } = nodeProps;\n\n      // record the key of node which is latest entered, used in dragleave event.\n      if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n        this.currentMouseOverDroppableNodeKey = eventKey;\n      }\n      if (!this.dragNodeProps) {\n        this.resetDragState();\n        return;\n      }\n      const {\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n      if (\n      // don't allow drop inside its children\n      dragChildrenKeys.includes(dropTargetKey) ||\n      // don't allow drop when drop is not allowed caculated by calcDropPosition\n      !dropAllowed) {\n        this.resetDragState();\n        return;\n      }\n\n      // Side effect for delay drag\n      if (!this.delayedDragEnterLogic) {\n        this.delayedDragEnterLogic = {};\n      }\n      Object.keys(this.delayedDragEnterLogic).forEach(key => {\n        clearTimeout(this.delayedDragEnterLogic[key]);\n      });\n      if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n        // hoist expand logic here\n        // since if logic is on the bottom\n        // it will be blocked by abstract dragover node check\n        //   => if you dragenter from top, you mouse will still be consider as in the top node\n        event.persist();\n        this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n          if (this.state.draggingNodeKey === null) {\n            return;\n          }\n          let newExpandedKeys = [...expandedKeys];\n          const entity = getEntity(keyEntities, nodeProps.eventKey);\n          if (entity && (entity.children || []).length) {\n            newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n          }\n          if (!this.props.hasOwnProperty('expandedKeys')) {\n            this.setExpandedKeys(newExpandedKeys);\n          }\n          onExpand === null || onExpand === void 0 || onExpand(newExpandedKeys, {\n            node: convertNodePropsToEventData(nodeProps),\n            expanded: true,\n            nativeEvent: event.nativeEvent\n          });\n        }, 800);\n      }\n\n      // Skip if drag node is self\n      if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n        this.resetDragState();\n        return;\n      }\n\n      // Update drag over node and drag state\n      this.setState({\n        dragOverNodeKey,\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed\n      });\n      onDragEnter === null || onDragEnter === void 0 || onDragEnter({\n        event,\n        node: convertNodePropsToEventData(nodeProps),\n        expandedKeys\n      });\n    });\n    _defineProperty(this, \"onNodeDragOver\", (event, nodeProps) => {\n      const {\n        dragChildrenKeys,\n        flattenNodes,\n        keyEntities,\n        expandedKeys,\n        indent\n      } = this.state;\n      const {\n        onDragOver,\n        allowDrop,\n        direction\n      } = this.props;\n      if (!this.dragNodeProps) {\n        return;\n      }\n      const {\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n      if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n        // don't allow drop inside its children\n        // don't allow drop when drop is not allowed calculated by calcDropPosition\n        return;\n      }\n\n      // Update drag position\n\n      if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n        if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n          this.resetDragState();\n        }\n      } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n        this.setState({\n          dropPosition,\n          dropLevelOffset,\n          dropTargetKey,\n          dropContainerKey,\n          dropTargetPos,\n          dropAllowed,\n          dragOverNodeKey\n        });\n      }\n      onDragOver === null || onDragOver === void 0 || onDragOver({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n    });\n    _defineProperty(this, \"onNodeDragLeave\", (event, nodeProps) => {\n      // if it is outside the droppable area\n      // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n      if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n        this.resetDragState();\n        this.currentMouseOverDroppableNodeKey = null;\n      }\n      const {\n        onDragLeave\n      } = this.props;\n      onDragLeave === null || onDragLeave === void 0 || onDragLeave({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n    });\n    // since stopPropagation() is called in treeNode\n    // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n    _defineProperty(this, \"onWindowDragEnd\", event => {\n      this.onNodeDragEnd(event, null, true);\n      window.removeEventListener('dragend', this.onWindowDragEnd);\n    });\n    // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n    _defineProperty(this, \"onNodeDragEnd\", (event, nodeProps) => {\n      const {\n        onDragEnd\n      } = this.props;\n      this.setState({\n        dragOverNodeKey: null\n      });\n      this.cleanDragState();\n      onDragEnd === null || onDragEnd === void 0 || onDragEnd({\n        event,\n        node: convertNodePropsToEventData(nodeProps)\n      });\n      this.dragNodeProps = null;\n      window.removeEventListener('dragend', this.onWindowDragEnd);\n    });\n    _defineProperty(this, \"onNodeDrop\", function (event, _) {\n      var _this$getActiveItem;\n      let outsideTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const {\n        dragChildrenKeys,\n        dropPosition,\n        dropTargetKey,\n        dropTargetPos,\n        dropAllowed\n      } = _this.state;\n      if (!dropAllowed) {\n        return;\n      }\n      const {\n        onDrop\n      } = _this.props;\n      _this.setState({\n        dragOverNodeKey: null\n      });\n      _this.cleanDragState();\n      if (dropTargetKey === null) return;\n      const abstractDropNodeProps = _objectSpread(_objectSpread({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {\n        active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,\n        data: getEntity(_this.state.keyEntities, dropTargetKey).node\n      });\n      const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n      warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n      const posArr = posToArr(dropTargetPos);\n      const dropResult = {\n        event,\n        node: convertNodePropsToEventData(abstractDropNodeProps),\n        dragNode: _this.dragNodeProps ? convertNodePropsToEventData(_this.dragNodeProps) : null,\n        dragNodesKeys: [_this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n        dropToGap: dropPosition !== 0,\n        dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n      };\n      if (!outsideTree) {\n        onDrop === null || onDrop === void 0 || onDrop(dropResult);\n      }\n      _this.dragNodeProps = null;\n    });\n    _defineProperty(this, \"cleanDragState\", () => {\n      const {\n        draggingNodeKey\n      } = this.state;\n      if (draggingNodeKey !== null) {\n        this.setState({\n          draggingNodeKey: null,\n          dropPosition: null,\n          dropContainerKey: null,\n          dropTargetKey: null,\n          dropLevelOffset: null,\n          dropAllowed: true,\n          dragOverNodeKey: null\n        });\n      }\n      this.dragStartMousePosition = null;\n      this.currentMouseOverDroppableNodeKey = null;\n    });\n    _defineProperty(this, \"triggerExpandActionExpand\", (e, treeNode) => {\n      const {\n        expandedKeys,\n        flattenNodes\n      } = this.state;\n      const {\n        expanded,\n        key,\n        isLeaf\n      } = treeNode;\n      if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n        return;\n      }\n      const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n      const eventNode = convertNodePropsToEventData(_objectSpread(_objectSpread({}, getTreeNodeProps(key, this.getTreeNodeRequiredProps())), {}, {\n        data: node.data\n      }));\n      this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n      this.onNodeExpand(e, eventNode);\n    });\n    _defineProperty(this, \"onNodeClick\", (e, treeNode) => {\n      const {\n        onClick,\n        expandAction\n      } = this.props;\n      if (expandAction === 'click') {\n        this.triggerExpandActionExpand(e, treeNode);\n      }\n      onClick === null || onClick === void 0 || onClick(e, treeNode);\n    });\n    _defineProperty(this, \"onNodeDoubleClick\", (e, treeNode) => {\n      const {\n        onDoubleClick,\n        expandAction\n      } = this.props;\n      if (expandAction === 'doubleClick') {\n        this.triggerExpandActionExpand(e, treeNode);\n      }\n      onDoubleClick === null || onDoubleClick === void 0 || onDoubleClick(e, treeNode);\n    });\n    _defineProperty(this, \"onNodeSelect\", (e, treeNode) => {\n      let {\n        selectedKeys\n      } = this.state;\n      const {\n        keyEntities,\n        fieldNames\n      } = this.state;\n      const {\n        onSelect,\n        multiple\n      } = this.props;\n      const {\n        selected\n      } = treeNode;\n      const key = treeNode[fieldNames.key];\n      const targetSelected = !selected;\n\n      // Update selected keys\n      if (!targetSelected) {\n        selectedKeys = arrDel(selectedKeys, key);\n      } else if (!multiple) {\n        selectedKeys = [key];\n      } else {\n        selectedKeys = arrAdd(selectedKeys, key);\n      }\n\n      // [Legacy] Not found related usage in doc or upper libs\n      const selectedNodes = selectedKeys.map(selectedKey => {\n        const entity = getEntity(keyEntities, selectedKey);\n        return entity ? entity.node : null;\n      }).filter(Boolean);\n      this.setUncontrolledState({\n        selectedKeys\n      });\n      onSelect === null || onSelect === void 0 || onSelect(selectedKeys, {\n        event: 'select',\n        selected: targetSelected,\n        node: treeNode,\n        selectedNodes,\n        nativeEvent: e.nativeEvent\n      });\n    });\n    _defineProperty(this, \"onNodeCheck\", (e, treeNode, checked) => {\n      const {\n        keyEntities,\n        checkedKeys: oriCheckedKeys,\n        halfCheckedKeys: oriHalfCheckedKeys\n      } = this.state;\n      const {\n        checkStrictly,\n        onCheck\n      } = this.props;\n      const {\n        key\n      } = treeNode;\n\n      // Prepare trigger arguments\n      let checkedObj;\n      const eventObj = {\n        event: 'check',\n        node: treeNode,\n        checked,\n        nativeEvent: e.nativeEvent\n      };\n      if (checkStrictly) {\n        const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n        const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n        checkedObj = {\n          checked: checkedKeys,\n          halfChecked: halfCheckedKeys\n        };\n        eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n        this.setUncontrolledState({\n          checkedKeys\n        });\n      } else {\n        // Always fill first\n        let {\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n        // If remove, we do it again to correction\n        if (!checked) {\n          const keySet = new Set(checkedKeys);\n          keySet.delete(key);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductCheck(Array.from(keySet), {\n            checked: false,\n            halfCheckedKeys\n          }, keyEntities));\n        }\n        checkedObj = checkedKeys;\n\n        // [Legacy] This is used for `rc-tree-select`\n        eventObj.checkedNodes = [];\n        eventObj.checkedNodesPositions = [];\n        eventObj.halfCheckedKeys = halfCheckedKeys;\n        checkedKeys.forEach(checkedKey => {\n          const entity = getEntity(keyEntities, checkedKey);\n          if (!entity) return;\n          const {\n            node,\n            pos\n          } = entity;\n          eventObj.checkedNodes.push(node);\n          eventObj.checkedNodesPositions.push({\n            node,\n            pos\n          });\n        });\n        this.setUncontrolledState({\n          checkedKeys\n        }, false, {\n          halfCheckedKeys\n        });\n      }\n      onCheck === null || onCheck === void 0 || onCheck(checkedObj, eventObj);\n    });\n    _defineProperty(this, \"onNodeLoad\", treeNode => {\n      var _entity$children;\n      const {\n        key\n      } = treeNode;\n      const {\n        keyEntities\n      } = this.state;\n\n      // Skip if has children already\n      const entity = getEntity(keyEntities, key);\n      if (entity !== null && entity !== void 0 && (_entity$children = entity.children) !== null && _entity$children !== void 0 && _entity$children.length) {\n        return;\n      }\n      const loadPromise = new Promise((resolve, reject) => {\n        // We need to get the latest state of loading/loaded keys\n        this.setState(_ref => {\n          let {\n            loadedKeys = [],\n            loadingKeys = []\n          } = _ref;\n          const {\n            loadData,\n            onLoad\n          } = this.props;\n          if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n            return null;\n          }\n\n          // Process load data\n          const promise = loadData(treeNode);\n          promise.then(() => {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n            // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n            // https://github.com/ant-design/ant-design/issues/12464\n            onLoad === null || onLoad === void 0 || onLoad(newLoadedKeys, {\n              event: 'load',\n              node: treeNode\n            });\n            this.setUncontrolledState({\n              loadedKeys: newLoadedKeys\n            });\n            this.setState(prevState => ({\n              loadingKeys: arrDel(prevState.loadingKeys, key)\n            }));\n            resolve();\n          }).catch(e => {\n            this.setState(prevState => ({\n              loadingKeys: arrDel(prevState.loadingKeys, key)\n            }));\n\n            // If exceed max retry times, we give up retry\n            this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n            if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n              const {\n                loadedKeys: currentLoadedKeys\n              } = this.state;\n              warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n              this.setUncontrolledState({\n                loadedKeys: arrAdd(currentLoadedKeys, key)\n              });\n              resolve();\n            }\n            reject(e);\n          });\n          return {\n            loadingKeys: arrAdd(loadingKeys, key)\n          };\n        });\n      });\n\n      // Not care warning if we ignore this\n      loadPromise.catch(() => {});\n      return loadPromise;\n    });\n    _defineProperty(this, \"onNodeMouseEnter\", (event, node) => {\n      const {\n        onMouseEnter\n      } = this.props;\n      onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({\n        event,\n        node\n      });\n    });\n    _defineProperty(this, \"onNodeMouseLeave\", (event, node) => {\n      const {\n        onMouseLeave\n      } = this.props;\n      onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({\n        event,\n        node\n      });\n    });\n    _defineProperty(this, \"onNodeContextMenu\", (event, node) => {\n      const {\n        onRightClick\n      } = this.props;\n      if (onRightClick) {\n        event.preventDefault();\n        onRightClick({\n          event,\n          node\n        });\n      }\n    });\n    _defineProperty(this, \"onFocus\", function () {\n      const {\n        onFocus\n      } = _this.props;\n      _this.setState({\n        focused: true\n      });\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      onFocus === null || onFocus === void 0 || onFocus(...args);\n    });\n    _defineProperty(this, \"onBlur\", function () {\n      const {\n        onBlur\n      } = _this.props;\n      _this.setState({\n        focused: false\n      });\n      _this.onActiveChange(null);\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      onBlur === null || onBlur === void 0 || onBlur(...args);\n    });\n    _defineProperty(this, \"getTreeNodeRequiredProps\", () => {\n      const {\n        expandedKeys,\n        selectedKeys,\n        loadedKeys,\n        loadingKeys,\n        checkedKeys,\n        halfCheckedKeys,\n        dragOverNodeKey,\n        dropPosition,\n        keyEntities\n      } = this.state;\n      return {\n        expandedKeys: expandedKeys || [],\n        selectedKeys: selectedKeys || [],\n        loadedKeys: loadedKeys || [],\n        loadingKeys: loadingKeys || [],\n        checkedKeys: checkedKeys || [],\n        halfCheckedKeys: halfCheckedKeys || [],\n        dragOverNodeKey,\n        dropPosition,\n        keyEntities: keyEntities\n      };\n    });\n    // =========================== Expanded ===========================\n    /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n    _defineProperty(this, \"setExpandedKeys\", expandedKeys => {\n      const {\n        treeData,\n        fieldNames\n      } = this.state;\n      const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n      this.setUncontrolledState({\n        expandedKeys,\n        flattenNodes\n      }, true);\n    });\n    _defineProperty(this, \"onNodeExpand\", (e, treeNode) => {\n      let {\n        expandedKeys\n      } = this.state;\n      const {\n        listChanging,\n        fieldNames\n      } = this.state;\n      const {\n        onExpand,\n        loadData\n      } = this.props;\n      const {\n        expanded\n      } = treeNode;\n      const key = treeNode[fieldNames.key];\n\n      // Do nothing when motion is in progress\n      if (listChanging) {\n        return;\n      }\n\n      // Update selected keys\n      const certain = expandedKeys.includes(key);\n      const targetExpanded = !expanded;\n      warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n      expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n      this.setExpandedKeys(expandedKeys);\n      onExpand === null || onExpand === void 0 || onExpand(expandedKeys, {\n        node: treeNode,\n        expanded: targetExpanded,\n        nativeEvent: e.nativeEvent\n      });\n\n      // Async Load data\n      if (targetExpanded && loadData) {\n        const loadPromise = this.onNodeLoad(treeNode);\n        if (loadPromise) {\n          loadPromise.then(() => {\n            // [Legacy] Refresh logic\n            const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n            this.setUncontrolledState({\n              flattenNodes: newFlattenTreeData\n            });\n          }).catch(() => {\n            const {\n              expandedKeys: currentExpandedKeys\n            } = this.state;\n            const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n            this.setExpandedKeys(expandedKeysToRestore);\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"onListChangeStart\", () => {\n      this.setUncontrolledState({\n        listChanging: true\n      });\n    });\n    _defineProperty(this, \"onListChangeEnd\", () => {\n      setTimeout(() => {\n        this.setUncontrolledState({\n          listChanging: false\n        });\n      });\n    });\n    // =========================== Keyboard ===========================\n    _defineProperty(this, \"onActiveChange\", newActiveKey => {\n      const {\n        activeKey\n      } = this.state;\n      const {\n        onActiveChange,\n        itemScrollOffset = 0\n      } = this.props;\n      if (activeKey === newActiveKey) {\n        return;\n      }\n      this.setState({\n        activeKey: newActiveKey\n      });\n      if (newActiveKey !== null) {\n        this.scrollTo({\n          key: newActiveKey,\n          offset: itemScrollOffset\n        });\n      }\n      onActiveChange === null || onActiveChange === void 0 || onActiveChange(newActiveKey);\n    });\n    _defineProperty(this, \"getActiveItem\", () => {\n      const {\n        activeKey,\n        flattenNodes\n      } = this.state;\n      if (activeKey === null) {\n        return null;\n      }\n      return flattenNodes.find(_ref2 => {\n        let {\n          key\n        } = _ref2;\n        return key === activeKey;\n      }) || null;\n    });\n    _defineProperty(this, \"offsetActiveKey\", offset => {\n      const {\n        flattenNodes,\n        activeKey\n      } = this.state;\n      let index = flattenNodes.findIndex(_ref3 => {\n        let {\n          key\n        } = _ref3;\n        return key === activeKey;\n      });\n\n      // Align with index\n      if (index === -1 && offset < 0) {\n        index = flattenNodes.length;\n      }\n      index = (index + offset + flattenNodes.length) % flattenNodes.length;\n      const item = flattenNodes[index];\n      if (item) {\n        const {\n          key\n        } = item;\n        this.onActiveChange(key);\n      } else {\n        this.onActiveChange(null);\n      }\n    });\n    _defineProperty(this, \"onKeyDown\", event => {\n      const {\n        activeKey,\n        expandedKeys,\n        checkedKeys,\n        fieldNames\n      } = this.state;\n      const {\n        onKeyDown,\n        checkable,\n        selectable\n      } = this.props;\n\n      // >>>>>>>>>> Direction\n      switch (event.which) {\n        case KeyCode.UP:\n          {\n            this.offsetActiveKey(-1);\n            event.preventDefault();\n            break;\n          }\n        case KeyCode.DOWN:\n          {\n            this.offsetActiveKey(1);\n            event.preventDefault();\n            break;\n          }\n      }\n\n      // >>>>>>>>>> Expand & Selection\n      const activeItem = this.getActiveItem();\n      if (activeItem && activeItem.data) {\n        const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n        const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;\n        const eventNode = convertNodePropsToEventData(_objectSpread(_objectSpread({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {\n          data: activeItem.data,\n          active: true\n        }));\n        switch (event.which) {\n          // >>> Expand\n          case KeyCode.LEFT:\n            {\n              // Collapse if possible\n              if (expandable && expandedKeys.includes(activeKey)) {\n                this.onNodeExpand({}, eventNode);\n              } else if (activeItem.parent) {\n                this.onActiveChange(activeItem.parent.key);\n              }\n              event.preventDefault();\n              break;\n            }\n          case KeyCode.RIGHT:\n            {\n              // Expand if possible\n              if (expandable && !expandedKeys.includes(activeKey)) {\n                this.onNodeExpand({}, eventNode);\n              } else if (activeItem.children && activeItem.children.length) {\n                this.onActiveChange(activeItem.children[0].key);\n              }\n              event.preventDefault();\n              break;\n            }\n\n          // Selection\n          case KeyCode.ENTER:\n          case KeyCode.SPACE:\n            {\n              if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {\n                this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n              } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {\n                this.onNodeSelect({}, eventNode);\n              }\n              break;\n            }\n        }\n      }\n      onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);\n    });\n    /**\n     * Only update the value which is not in props\n     */\n    _defineProperty(this, \"setUncontrolledState\", function (state) {\n      let atomic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let forceState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (!_this.destroyed) {\n        let needSync = false;\n        let allPassed = true;\n        const newState = {};\n        Object.keys(state).forEach(name => {\n          if (_this.props.hasOwnProperty(name)) {\n            allPassed = false;\n            return;\n          }\n          needSync = true;\n          newState[name] = state[name];\n        });\n        if (needSync && (!atomic || allPassed)) {\n          _this.setState(_objectSpread(_objectSpread({}, newState), forceState));\n        }\n      }\n    });\n    _defineProperty(this, \"scrollTo\", scroll => {\n      this.listRef.current.scrollTo(scroll);\n    });\n  }\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = _objectSpread({\n        [MOTION_KEY]: MotionEntity\n      }, entitiesMap.keyEntities);\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = _objectSpread({}, keyEntities);\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  render() {\n    const {\n      focused,\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      activeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [\"\".concat(prefixCls, \"-show-line\")]: showLine,\n        [\"\".concat(prefixCls, \"-focused\")]: focused,\n        [\"\".concat(prefixCls, \"-active-focused\")]: activeKey !== null\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      focused: focused,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\n_defineProperty(Tree, \"defaultProps\", {\n  prefixCls: 'rc-tree',\n  showLine: false,\n  showIcon: true,\n  selectable: true,\n  multiple: false,\n  checkable: false,\n  disabled: false,\n  checkStrictly: false,\n  draggable: false,\n  defaultExpandParent: true,\n  autoExpandParent: false,\n  defaultExpandAll: false,\n  defaultExpandedKeys: [],\n  defaultCheckedKeys: [],\n  defaultSelectedKeys: [],\n  dropIndicatorRender: DropIndicator,\n  allowDrop: () => true,\n  expandAction: false\n});\n_defineProperty(Tree, \"TreeNode\", TreeNode);\nexport default Tree;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","clsx","KeyCode","pickAttrs","warning","React","TreeContext","DropIndicator","NodeList","MOTION_KEY","MotionEntity","TreeNode","arrAdd","arrDel","calcDropPosition","calcSelectedKeys","conductExpandParent","getDragChildrenKeys","parseCheckedKeys","posToArr","conductCheck","getEntity","convertDataToEntities","convertNodePropsToEventData","convertTreeToData","fillFieldNames","flattenTreeData","getTreeNodeProps","warningWithoutKey","MAX_RETRY_TIMES","Tree","Component","constructor","_this","this","_defineProperty","keyEntities","indent","selectedKeys","checkedKeys","halfCheckedKeys","loadedKeys","loadingKeys","expandedKeys","draggingNodeKey","dragChildrenKeys","dropTargetKey","dropPosition","dropContainerKey","dropLevelOffset","dropTargetPos","dropAllowed","dragOverNodeKey","treeData","flattenNodes","focused","activeKey","listChanging","prevProps","fieldNames","createRef","event","nodeProps","state","onDragStart","props","eventKey","dragNodeProps","dragStartMousePosition","x","clientX","y","clientY","newExpandedKeys","setState","listRef","current","getIndentWidth","setExpandedKeys","window","addEventListener","onWindowDragEnd","node","onDragEnter","onExpand","allowDrop","direction","pos","currentMouseOverDroppableNodeKey","resetDragState","includes","delayedDragEnterLogic","keys","forEach","clearTimeout","persist","setTimeout","entity","children","expanded","nativeEvent","onDragOver","currentTarget","contains","relatedTarget","onDragLeave","onNodeDragEnd","removeEventListener","onDragEnd","cleanDragState","_","_this$getActiveItem","outsideTree","undefined","onDrop","abstractDropNodeProps","_objectSpread","getTreeNodeRequiredProps","active","getActiveItem","data","dropToChild","posArr","dropResult","dragNode","dragNodesKeys","concat","dropToGap","Number","e","treeNode","isLeaf","shiftKey","metaKey","ctrlKey","filter","nodeItem","eventNode","onNodeExpand","onClick","expandAction","triggerExpandActionExpand","onDoubleClick","onSelect","multiple","selected","targetSelected","selectedNodes","map","selectedKey","Boolean","setUncontrolledState","checked","oriCheckedKeys","oriHalfCheckedKeys","checkStrictly","onCheck","checkedObj","eventObj","halfChecked","checkedNodes","checkedKey","keySet","Set","delete","Array","from","checkedNodesPositions","push","_entity$children","loadPromise","Promise","resolve","reject","_ref","loadData","onLoad","promise","then","currentLoadedKeys","newLoadedKeys","prevState","catch","loadingRetryTimes","onMouseEnter","onMouseLeave","onRightClick","preventDefault","onFocus","_len","args","_key","onBlur","onActiveChange","_len2","_key2","certain","targetExpanded","onNodeLoad","newFlattenTreeData","currentExpandedKeys","expandedKeysToRestore","newActiveKey","itemScrollOffset","scrollTo","offset","find","_ref2","index","findIndex","_ref3","item","onKeyDown","checkable","selectable","which","UP","offsetActiveKey","DOWN","activeItem","treeNodeRequiredProps","expandable","LEFT","parent","RIGHT","ENTER","SPACE","disabled","disableCheckbox","onNodeCheck","onNodeSelect","atomic","forceState","destroyed","needSync","allPassed","newState","name","scroll","componentDidMount","onUpdated","componentDidUpdate","componentWillUnmount","getDerivedStateFromProps","entitiesMap","process","env","NODE_ENV","autoExpandParent","defaultExpandParent","defaultExpandAll","cloneKeyEntities","nextExpandedKeys","defaultExpandedKeys","defaultSelectedKeys","checkedKeyEntity","defaultCheckedKeys","conductKeys","render","prefixCls","className","style","styles","classNames","treeClassNames","showLine","focusable","tabIndex","showIcon","icon","switcherIcon","draggable","motion","filterTreeNode","height","itemHeight","scrollWidth","virtual","titleRender","dropIndicatorRender","onContextMenu","onScroll","rootClassName","rootStyle","domProps","aria","draggableConfig","nodeDraggable","contextValue","onNodeClick","onNodeDoubleClick","onNodeMouseEnter","onNodeMouseLeave","onNodeContextMenu","onNodeDragStart","onNodeDragEnter","onNodeDragOver","onNodeDragLeave","onNodeDrop","createElement","Provider","value","ref","dragging","onListChangeStart","onListChangeEnd"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/tree/es/Tree.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n// TODO: https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/treeview/treeview-2/treeview-2a.html\n// Fully accessibility support\n\nimport { clsx } from 'clsx';\nimport KeyCode from \"@rc-component/util/es/KeyCode\";\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  static defaultProps = {\n    prefixCls: 'rc-tree',\n    showLine: false,\n    showIcon: true,\n    selectable: true,\n    multiple: false,\n    checkable: false,\n    disabled: false,\n    checkStrictly: false,\n    draggable: false,\n    defaultExpandParent: true,\n    autoExpandParent: false,\n    defaultExpandAll: false,\n    defaultExpandedKeys: [],\n    defaultCheckedKeys: [],\n    defaultSelectedKeys: [],\n    dropIndicatorRender: DropIndicator,\n    allowDrop: () => true,\n    expandAction: false\n  };\n  static TreeNode = TreeNode;\n  destroyed = false;\n  delayedDragEnterLogic;\n  loadingRetryTimes = {};\n  state = {\n    keyEntities: {},\n    indent: null,\n    selectedKeys: [],\n    checkedKeys: [],\n    halfCheckedKeys: [],\n    loadedKeys: [],\n    loadingKeys: [],\n    expandedKeys: [],\n    draggingNodeKey: null,\n    dragChildrenKeys: [],\n    // dropTargetKey is the key of abstract-drop-node\n    // the abstract-drop-node is the real drop node when drag and drop\n    // not the DOM drag over node\n    dropTargetKey: null,\n    dropPosition: null,\n    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n    dropContainerKey: null,\n    // the container key of abstract-drop-node if dropPosition is -1 or 1\n    dropLevelOffset: null,\n    // the drop level offset of abstract-drag-over-node\n    dropTargetPos: null,\n    // the pos of abstract-drop-node\n    dropAllowed: true,\n    // if drop to abstract-drop-node is allowed\n    // the abstract-drag-over-node\n    // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n    // abstract-drag-over-node is the top node\n    dragOverNodeKey: null,\n    treeData: [],\n    flattenNodes: [],\n    focused: false,\n    activeKey: null,\n    listChanging: false,\n    prevProps: null,\n    fieldNames: fillFieldNames()\n  };\n  dragStartMousePosition = null;\n  dragNodeProps = null;\n  currentMouseOverDroppableNodeKey = null;\n  listRef = /*#__PURE__*/React.createRef();\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = {\n        [MOTION_KEY]: MotionEntity,\n        ...entitiesMap.keyEntities\n      };\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = {\n        ...keyEntities\n      };\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  onNodeDragStart = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities\n    } = this.state;\n    const {\n      onDragStart\n    } = this.props;\n    const {\n      eventKey\n    } = nodeProps;\n    this.dragNodeProps = nodeProps;\n    this.dragStartMousePosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const newExpandedKeys = arrDel(expandedKeys, eventKey);\n    this.setState({\n      draggingNodeKey: eventKey,\n      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n      indent: this.listRef.current.getIndentWidth()\n    });\n    this.setExpandedKeys(newExpandedKeys);\n    window.addEventListener('dragend', this.onWindowDragEnd);\n    onDragStart?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  /**\n   * [Legacy] Select handler is smaller than node,\n   * so that this will trigger when drag enter node or select handler.\n   * This is a little tricky if customize css without padding.\n   * Better for use mouse move event to refresh drag state.\n   * But let's just keep it to avoid event trigger logic change.\n   */\n  onNodeDragEnter = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities,\n      dragChildrenKeys,\n      flattenNodes,\n      indent\n    } = this.state;\n    const {\n      onDragEnter,\n      onExpand,\n      allowDrop,\n      direction\n    } = this.props;\n    const {\n      pos,\n      eventKey\n    } = nodeProps;\n\n    // record the key of node which is latest entered, used in dragleave event.\n    if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n      this.currentMouseOverDroppableNodeKey = eventKey;\n    }\n    if (!this.dragNodeProps) {\n      this.resetDragState();\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (\n    // don't allow drop inside its children\n    dragChildrenKeys.includes(dropTargetKey) ||\n    // don't allow drop when drop is not allowed caculated by calcDropPosition\n    !dropAllowed) {\n      this.resetDragState();\n      return;\n    }\n\n    // Side effect for delay drag\n    if (!this.delayedDragEnterLogic) {\n      this.delayedDragEnterLogic = {};\n    }\n    Object.keys(this.delayedDragEnterLogic).forEach(key => {\n      clearTimeout(this.delayedDragEnterLogic[key]);\n    });\n    if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n      // hoist expand logic here\n      // since if logic is on the bottom\n      // it will be blocked by abstract dragover node check\n      //   => if you dragenter from top, you mouse will still be consider as in the top node\n      event.persist();\n      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n        if (this.state.draggingNodeKey === null) {\n          return;\n        }\n        let newExpandedKeys = [...expandedKeys];\n        const entity = getEntity(keyEntities, nodeProps.eventKey);\n        if (entity && (entity.children || []).length) {\n          newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n        }\n        if (!this.props.hasOwnProperty('expandedKeys')) {\n          this.setExpandedKeys(newExpandedKeys);\n        }\n        onExpand?.(newExpandedKeys, {\n          node: convertNodePropsToEventData(nodeProps),\n          expanded: true,\n          nativeEvent: event.nativeEvent\n        });\n      }, 800);\n    }\n\n    // Skip if drag node is self\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      this.resetDragState();\n      return;\n    }\n\n    // Update drag over node and drag state\n    this.setState({\n      dragOverNodeKey,\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed\n    });\n    onDragEnter?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps),\n      expandedKeys\n    });\n  };\n  onNodeDragOver = (event, nodeProps) => {\n    const {\n      dragChildrenKeys,\n      flattenNodes,\n      keyEntities,\n      expandedKeys,\n      indent\n    } = this.state;\n    const {\n      onDragOver,\n      allowDrop,\n      direction\n    } = this.props;\n    if (!this.dragNodeProps) {\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n      // don't allow drop inside its children\n      // don't allow drop when drop is not allowed calculated by calcDropPosition\n      return;\n    }\n\n    // Update drag position\n\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n        this.resetDragState();\n      }\n    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n      this.setState({\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      });\n    }\n    onDragOver?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n  onNodeDragLeave = (event, nodeProps) => {\n    // if it is outside the droppable area\n    // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n    if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n      this.resetDragState();\n      this.currentMouseOverDroppableNodeKey = null;\n    }\n    const {\n      onDragLeave\n    } = this.props;\n    onDragLeave?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  // since stopPropagation() is called in treeNode\n  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n  onWindowDragEnd = event => {\n    this.onNodeDragEnd(event, null, true);\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n\n  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n  onNodeDragEnd = (event, nodeProps) => {\n    const {\n      onDragEnd\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    onDragEnd?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n    this.dragNodeProps = null;\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n  onNodeDrop = (event, _, outsideTree = false) => {\n    const {\n      dragChildrenKeys,\n      dropPosition,\n      dropTargetKey,\n      dropTargetPos,\n      dropAllowed\n    } = this.state;\n    if (!dropAllowed) {\n      return;\n    }\n    const {\n      onDrop\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    if (dropTargetKey === null) return;\n    const abstractDropNodeProps = {\n      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),\n      active: this.getActiveItem()?.key === dropTargetKey,\n      data: getEntity(this.state.keyEntities, dropTargetKey).node\n    };\n    const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n    warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n    const posArr = posToArr(dropTargetPos);\n    const dropResult = {\n      event,\n      node: convertNodePropsToEventData(abstractDropNodeProps),\n      dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,\n      dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n      dropToGap: dropPosition !== 0,\n      dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n    };\n    if (!outsideTree) {\n      onDrop?.(dropResult);\n    }\n    this.dragNodeProps = null;\n  };\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  cleanDragState = () => {\n    const {\n      draggingNodeKey\n    } = this.state;\n    if (draggingNodeKey !== null) {\n      this.setState({\n        draggingNodeKey: null,\n        dropPosition: null,\n        dropContainerKey: null,\n        dropTargetKey: null,\n        dropLevelOffset: null,\n        dropAllowed: true,\n        dragOverNodeKey: null\n      });\n    }\n    this.dragStartMousePosition = null;\n    this.currentMouseOverDroppableNodeKey = null;\n  };\n  triggerExpandActionExpand = (e, treeNode) => {\n    const {\n      expandedKeys,\n      flattenNodes\n    } = this.state;\n    const {\n      expanded,\n      key,\n      isLeaf\n    } = treeNode;\n    if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n    const eventNode = convertNodePropsToEventData({\n      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),\n      data: node.data\n    });\n    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n    this.onNodeExpand(e, eventNode);\n  };\n  onNodeClick = (e, treeNode) => {\n    const {\n      onClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'click') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onClick?.(e, treeNode);\n  };\n  onNodeDoubleClick = (e, treeNode) => {\n    const {\n      onDoubleClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'doubleClick') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onDoubleClick?.(e, treeNode);\n  };\n  onNodeSelect = (e, treeNode) => {\n    let {\n      selectedKeys\n    } = this.state;\n    const {\n      keyEntities,\n      fieldNames\n    } = this.state;\n    const {\n      onSelect,\n      multiple\n    } = this.props;\n    const {\n      selected\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n    const targetSelected = !selected;\n\n    // Update selected keys\n    if (!targetSelected) {\n      selectedKeys = arrDel(selectedKeys, key);\n    } else if (!multiple) {\n      selectedKeys = [key];\n    } else {\n      selectedKeys = arrAdd(selectedKeys, key);\n    }\n\n    // [Legacy] Not found related usage in doc or upper libs\n    const selectedNodes = selectedKeys.map(selectedKey => {\n      const entity = getEntity(keyEntities, selectedKey);\n      return entity ? entity.node : null;\n    }).filter(Boolean);\n    this.setUncontrolledState({\n      selectedKeys\n    });\n    onSelect?.(selectedKeys, {\n      event: 'select',\n      selected: targetSelected,\n      node: treeNode,\n      selectedNodes,\n      nativeEvent: e.nativeEvent\n    });\n  };\n  onNodeCheck = (e, treeNode, checked) => {\n    const {\n      keyEntities,\n      checkedKeys: oriCheckedKeys,\n      halfCheckedKeys: oriHalfCheckedKeys\n    } = this.state;\n    const {\n      checkStrictly,\n      onCheck\n    } = this.props;\n    const {\n      key\n    } = treeNode;\n\n    // Prepare trigger arguments\n    let checkedObj;\n    const eventObj = {\n      event: 'check',\n      node: treeNode,\n      checked,\n      nativeEvent: e.nativeEvent\n    };\n    if (checkStrictly) {\n      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n      checkedObj = {\n        checked: checkedKeys,\n        halfChecked: halfCheckedKeys\n      };\n      eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n      this.setUncontrolledState({\n        checkedKeys\n      });\n    } else {\n      // Always fill first\n      let {\n        checkedKeys,\n        halfCheckedKeys\n      } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n      // If remove, we do it again to correction\n      if (!checked) {\n        const keySet = new Set(checkedKeys);\n        keySet.delete(key);\n        ({\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck(Array.from(keySet), {\n          checked: false,\n          halfCheckedKeys\n        }, keyEntities));\n      }\n      checkedObj = checkedKeys;\n\n      // [Legacy] This is used for `rc-tree-select`\n      eventObj.checkedNodes = [];\n      eventObj.checkedNodesPositions = [];\n      eventObj.halfCheckedKeys = halfCheckedKeys;\n      checkedKeys.forEach(checkedKey => {\n        const entity = getEntity(keyEntities, checkedKey);\n        if (!entity) return;\n        const {\n          node,\n          pos\n        } = entity;\n        eventObj.checkedNodes.push(node);\n        eventObj.checkedNodesPositions.push({\n          node,\n          pos\n        });\n      });\n      this.setUncontrolledState({\n        checkedKeys\n      }, false, {\n        halfCheckedKeys\n      });\n    }\n    onCheck?.(checkedObj, eventObj);\n  };\n  onNodeLoad = treeNode => {\n    const {\n      key\n    } = treeNode;\n    const {\n      keyEntities\n    } = this.state;\n\n    // Skip if has children already\n    const entity = getEntity(keyEntities, key);\n    if (entity?.children?.length) {\n      return;\n    }\n    const loadPromise = new Promise((resolve, reject) => {\n      // We need to get the latest state of loading/loaded keys\n      this.setState(({\n        loadedKeys = [],\n        loadingKeys = []\n      }) => {\n        const {\n          loadData,\n          onLoad\n        } = this.props;\n        if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n          return null;\n        }\n\n        // Process load data\n        const promise = loadData(treeNode);\n        promise.then(() => {\n          const {\n            loadedKeys: currentLoadedKeys\n          } = this.state;\n          const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n          // https://github.com/ant-design/ant-design/issues/12464\n          onLoad?.(newLoadedKeys, {\n            event: 'load',\n            node: treeNode\n          });\n          this.setUncontrolledState({\n            loadedKeys: newLoadedKeys\n          });\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n          resolve();\n        }).catch(e => {\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n\n          // If exceed max retry times, we give up retry\n          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n            this.setUncontrolledState({\n              loadedKeys: arrAdd(currentLoadedKeys, key)\n            });\n            resolve();\n          }\n          reject(e);\n        });\n        return {\n          loadingKeys: arrAdd(loadingKeys, key)\n        };\n      });\n    });\n\n    // Not care warning if we ignore this\n    loadPromise.catch(() => {});\n    return loadPromise;\n  };\n  onNodeMouseEnter = (event, node) => {\n    const {\n      onMouseEnter\n    } = this.props;\n    onMouseEnter?.({\n      event,\n      node\n    });\n  };\n  onNodeMouseLeave = (event, node) => {\n    const {\n      onMouseLeave\n    } = this.props;\n    onMouseLeave?.({\n      event,\n      node\n    });\n  };\n  onNodeContextMenu = (event, node) => {\n    const {\n      onRightClick\n    } = this.props;\n    if (onRightClick) {\n      event.preventDefault();\n      onRightClick({\n        event,\n        node\n      });\n    }\n  };\n  onFocus = (...args) => {\n    const {\n      onFocus\n    } = this.props;\n    this.setState({\n      focused: true\n    });\n    onFocus?.(...args);\n  };\n  onBlur = (...args) => {\n    const {\n      onBlur\n    } = this.props;\n    this.setState({\n      focused: false\n    });\n    this.onActiveChange(null);\n    onBlur?.(...args);\n  };\n  getTreeNodeRequiredProps = () => {\n    const {\n      expandedKeys,\n      selectedKeys,\n      loadedKeys,\n      loadingKeys,\n      checkedKeys,\n      halfCheckedKeys,\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities\n    } = this.state;\n    return {\n      expandedKeys: expandedKeys || [],\n      selectedKeys: selectedKeys || [],\n      loadedKeys: loadedKeys || [],\n      loadingKeys: loadingKeys || [],\n      checkedKeys: checkedKeys || [],\n      halfCheckedKeys: halfCheckedKeys || [],\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities: keyEntities\n    };\n  };\n\n  // =========================== Expanded ===========================\n  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n  setExpandedKeys = expandedKeys => {\n    const {\n      treeData,\n      fieldNames\n    } = this.state;\n    const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n    this.setUncontrolledState({\n      expandedKeys,\n      flattenNodes\n    }, true);\n  };\n  onNodeExpand = (e, treeNode) => {\n    let {\n      expandedKeys\n    } = this.state;\n    const {\n      listChanging,\n      fieldNames\n    } = this.state;\n    const {\n      onExpand,\n      loadData\n    } = this.props;\n    const {\n      expanded\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n\n    // Do nothing when motion is in progress\n    if (listChanging) {\n      return;\n    }\n\n    // Update selected keys\n    const certain = expandedKeys.includes(key);\n    const targetExpanded = !expanded;\n    warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n    expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n    this.setExpandedKeys(expandedKeys);\n    onExpand?.(expandedKeys, {\n      node: treeNode,\n      expanded: targetExpanded,\n      nativeEvent: e.nativeEvent\n    });\n\n    // Async Load data\n    if (targetExpanded && loadData) {\n      const loadPromise = this.onNodeLoad(treeNode);\n      if (loadPromise) {\n        loadPromise.then(() => {\n          // [Legacy] Refresh logic\n          const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n          this.setUncontrolledState({\n            flattenNodes: newFlattenTreeData\n          });\n        }).catch(() => {\n          const {\n            expandedKeys: currentExpandedKeys\n          } = this.state;\n          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n          this.setExpandedKeys(expandedKeysToRestore);\n        });\n      }\n    }\n  };\n  onListChangeStart = () => {\n    this.setUncontrolledState({\n      listChanging: true\n    });\n  };\n  onListChangeEnd = () => {\n    setTimeout(() => {\n      this.setUncontrolledState({\n        listChanging: false\n      });\n    });\n  };\n\n  // =========================== Keyboard ===========================\n  onActiveChange = newActiveKey => {\n    const {\n      activeKey\n    } = this.state;\n    const {\n      onActiveChange,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey === newActiveKey) {\n      return;\n    }\n    this.setState({\n      activeKey: newActiveKey\n    });\n    if (newActiveKey !== null) {\n      this.scrollTo({\n        key: newActiveKey,\n        offset: itemScrollOffset\n      });\n    }\n    onActiveChange?.(newActiveKey);\n  };\n  getActiveItem = () => {\n    const {\n      activeKey,\n      flattenNodes\n    } = this.state;\n    if (activeKey === null) {\n      return null;\n    }\n    return flattenNodes.find(({\n      key\n    }) => key === activeKey) || null;\n  };\n  offsetActiveKey = offset => {\n    const {\n      flattenNodes,\n      activeKey\n    } = this.state;\n    let index = flattenNodes.findIndex(({\n      key\n    }) => key === activeKey);\n\n    // Align with index\n    if (index === -1 && offset < 0) {\n      index = flattenNodes.length;\n    }\n    index = (index + offset + flattenNodes.length) % flattenNodes.length;\n    const item = flattenNodes[index];\n    if (item) {\n      const {\n        key\n      } = item;\n      this.onActiveChange(key);\n    } else {\n      this.onActiveChange(null);\n    }\n  };\n  onKeyDown = event => {\n    const {\n      activeKey,\n      expandedKeys,\n      checkedKeys,\n      fieldNames\n    } = this.state;\n    const {\n      onKeyDown,\n      checkable,\n      selectable\n    } = this.props;\n\n    // >>>>>>>>>> Direction\n    switch (event.which) {\n      case KeyCode.UP:\n        {\n          this.offsetActiveKey(-1);\n          event.preventDefault();\n          break;\n        }\n      case KeyCode.DOWN:\n        {\n          this.offsetActiveKey(1);\n          event.preventDefault();\n          break;\n        }\n    }\n\n    // >>>>>>>>>> Expand & Selection\n    const activeItem = this.getActiveItem();\n    if (activeItem && activeItem.data) {\n      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n      const expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;\n      const eventNode = convertNodePropsToEventData({\n        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),\n        data: activeItem.data,\n        active: true\n      });\n      switch (event.which) {\n        // >>> Expand\n        case KeyCode.LEFT:\n          {\n            // Collapse if possible\n            if (expandable && expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.parent) {\n              this.onActiveChange(activeItem.parent.key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            // Expand if possible\n            if (expandable && !expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.children && activeItem.children.length) {\n              this.onActiveChange(activeItem.children[0].key);\n            }\n            event.preventDefault();\n            break;\n          }\n\n        // Selection\n        case KeyCode.ENTER:\n        case KeyCode.SPACE:\n          {\n            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {\n              this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n      }\n    }\n    onKeyDown?.(event);\n  };\n\n  /**\n   * Only update the value which is not in props\n   */\n  setUncontrolledState = (state, atomic = false, forceState = null) => {\n    if (!this.destroyed) {\n      let needSync = false;\n      let allPassed = true;\n      const newState = {};\n      Object.keys(state).forEach(name => {\n        if (this.props.hasOwnProperty(name)) {\n          allPassed = false;\n          return;\n        }\n        needSync = true;\n        newState[name] = state[name];\n      });\n      if (needSync && (!atomic || allPassed)) {\n        this.setState({\n          ...newState,\n          ...forceState\n        });\n      }\n    }\n  };\n  scrollTo = scroll => {\n    this.listRef.current.scrollTo(scroll);\n  };\n  render() {\n    const {\n      focused,\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      activeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [`${prefixCls}-show-line`]: showLine,\n        [`${prefixCls}-focused`]: focused,\n        [`${prefixCls}-active-focused`]: activeKey !== null\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      focused: focused,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\nexport default Tree;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}