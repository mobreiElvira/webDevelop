{"ast":null,"code":"import _objectWithoutProperties from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nconst _excluded = [\"name\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport toChildrenArray from \"@rc-component/util/es/Children/toArray\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport ListContext from \"./ListContext\";\nimport { toArray } from \"./utils/typeUtil\";\nimport { validateRules } from \"./utils/validateUtil\";\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from \"./utils/valueUtil\";\nconst EMPTY_ERRORS = [];\nconst EMPTY_WARNINGS = [];\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === 'function') {\n    return shouldUpdate(prev, next, 'source' in info ? {\n      source: info.source\n    } : {});\n  }\n  return prevValue !== nextValue;\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style\n\n// We use Class instead of Hooks here since it will cost much code by using Hooks.\nclass Field extends React.Component {\n  // ============================== Subscriptions ==============================\n  constructor(props) {\n    var _this;\n    // Register on init\n    super(props);\n    _this = this;\n    _defineProperty(this, \"state\", {\n      resetCount: 0\n    });\n    _defineProperty(this, \"cancelRegisterFunc\", null);\n    _defineProperty(this, \"mounted\", false);\n    /**\n     * Follow state should not management in State since it will async update by React.\n     * This makes first render of form can not get correct state value.\n     */\n    _defineProperty(this, \"touched\", false);\n    /**\n     * Mark when touched & validated. Currently only used for `dependencies`.\n     * Note that we do not think field with `initialValue` is dirty\n     * but this will be by `isFieldDirty` func.\n     */\n    _defineProperty(this, \"dirty\", false);\n    _defineProperty(this, \"validatePromise\", void 0);\n    _defineProperty(this, \"prevValidating\", void 0);\n    _defineProperty(this, \"errors\", EMPTY_ERRORS);\n    _defineProperty(this, \"warnings\", EMPTY_WARNINGS);\n    _defineProperty(this, \"cancelRegister\", () => {\n      const {\n        preserve,\n        isListField,\n        name\n      } = this.props;\n      if (this.cancelRegisterFunc) {\n        this.cancelRegisterFunc(isListField, preserve, getNamePath(name));\n      }\n      this.cancelRegisterFunc = null;\n    });\n    // ================================== Utils ==================================\n    _defineProperty(this, \"getNamePath\", () => {\n      const {\n        name,\n        fieldContext\n      } = this.props;\n      const {\n        prefixName = []\n      } = fieldContext;\n      return name !== undefined ? [...prefixName, ...name] : [];\n    });\n    _defineProperty(this, \"getRules\", () => {\n      const {\n        rules = [],\n        fieldContext\n      } = this.props;\n      return rules.map(rule => {\n        if (typeof rule === 'function') {\n          return rule(fieldContext);\n        }\n        return rule;\n      });\n    });\n    _defineProperty(this, \"refresh\", () => {\n      if (!this.mounted) return;\n\n      /**\n       * Clean up current node.\n       */\n      this.setState(_ref => {\n        let {\n          resetCount\n        } = _ref;\n        return {\n          resetCount: resetCount + 1\n        };\n      });\n    });\n    // Event should only trigger when meta changed\n    _defineProperty(this, \"metaCache\", null);\n    _defineProperty(this, \"triggerMetaEvent\", destroy => {\n      const {\n        onMetaChange\n      } = this.props;\n      if (onMetaChange) {\n        const meta = _objectSpread(_objectSpread({}, this.getMeta()), {}, {\n          destroy\n        });\n        if (!isEqual(this.metaCache, meta)) {\n          onMetaChange(meta);\n        }\n        this.metaCache = meta;\n      } else {\n        this.metaCache = null;\n      }\n    });\n    // ========================= Field Entity Interfaces =========================\n    // Trigger by store update. Check if need update the component\n    _defineProperty(this, \"onStoreChange\", (prevStore, namePathList, info) => {\n      const {\n        shouldUpdate,\n        dependencies = [],\n        onReset\n      } = this.props;\n      const {\n        store\n      } = info;\n      const namePath = this.getNamePath();\n      const prevValue = this.getValue(prevStore);\n      const curValue = this.getValue(store);\n      const namePathMatch = namePathList && containsNamePath(namePathList, namePath);\n\n      // `setFieldsValue` is a quick access to update related status\n      if (info.type === 'valueUpdate' && info.source === 'external' && !isEqual(prevValue, curValue)) {\n        this.touched = true;\n        this.dirty = true;\n        this.validatePromise = null;\n        this.errors = EMPTY_ERRORS;\n        this.warnings = EMPTY_WARNINGS;\n        this.triggerMetaEvent();\n      }\n      switch (info.type) {\n        case 'reset':\n          if (!namePathList || namePathMatch) {\n            // Clean up state\n            this.touched = false;\n            this.dirty = false;\n            this.validatePromise = undefined;\n            this.errors = EMPTY_ERRORS;\n            this.warnings = EMPTY_WARNINGS;\n            this.triggerMetaEvent();\n            onReset === null || onReset === void 0 || onReset();\n            this.refresh();\n            return;\n          }\n          break;\n\n        /**\n         * In case field with `preserve = false` nest deps like:\n         * - A = 1 => show B\n         * - B = 1 => show C\n         * - Reset A, need clean B, C\n         */\n        case 'remove':\n          {\n            if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n              this.reRender();\n              return;\n            }\n            break;\n          }\n        case 'setField':\n          {\n            const {\n              data\n            } = info;\n            if (namePathMatch) {\n              if ('touched' in data) {\n                this.touched = data.touched;\n              }\n              if ('validating' in data && !('originRCField' in data)) {\n                this.validatePromise = data.validating ? Promise.resolve([]) : null;\n              }\n              if ('errors' in data) {\n                this.errors = data.errors || EMPTY_ERRORS;\n              }\n              if ('warnings' in data) {\n                this.warnings = data.warnings || EMPTY_WARNINGS;\n              }\n              this.dirty = true;\n              this.triggerMetaEvent();\n              this.reRender();\n              return;\n            } else if ('value' in data && containsNamePath(namePathList, namePath, true)) {\n              // Contains path with value should also check\n              this.reRender();\n              return;\n            }\n\n            // Handle update by `setField` with `shouldUpdate`\n            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n              this.reRender();\n              return;\n            }\n            break;\n          }\n        case 'dependenciesUpdate':\n          {\n            /**\n             * Trigger when marked `dependencies` updated. Related fields will all update\n             */\n            const dependencyList = dependencies.map(getNamePath);\n            // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\n            // emitted earlier and they will work there\n            // If set it may cause unnecessary twice rerendering\n            if (dependencyList.some(dependency => containsNamePath(info.relatedFields, dependency))) {\n              this.reRender();\n              return;\n            }\n            break;\n          }\n        default:\n          // 1. If `namePath` exists in `namePathList`, means it's related value and should update\n          //      For example <List name=\"list\"><Field name={['list', 0]}></List>\n          //      If `namePathList` is [['list']] (List value update), Field should be updated\n          //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\n          // 2.\n          //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\n          //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\n          //       is not provided\n          //   2.2 If `shouldUpdate` provided, use customize logic to update the field\n          //       else to check if value changed\n          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            this.reRender();\n            return;\n          }\n          break;\n      }\n      if (shouldUpdate === true) {\n        this.reRender();\n      }\n    });\n    _defineProperty(this, \"validateRules\", options => {\n      // We should fixed namePath & value to avoid developer change then by form function\n      const namePath = this.getNamePath();\n      const currentValue = this.getValue();\n      const {\n        triggerName,\n        validateOnly = false\n      } = options || {};\n\n      // Force change to async to avoid rule OOD under renderProps field\n      const rootPromise = Promise.resolve().then(async () => {\n        if (!this.mounted) {\n          return [];\n        }\n        const {\n          validateFirst = false,\n          messageVariables,\n          validateDebounce\n        } = this.props;\n\n        // Start validate\n        let filteredRules = this.getRules();\n        if (triggerName) {\n          filteredRules = filteredRules.filter(rule => rule).filter(rule => {\n            const {\n              validateTrigger\n            } = rule;\n            if (!validateTrigger) {\n              return true;\n            }\n            const triggerList = toArray(validateTrigger);\n            return triggerList.includes(triggerName);\n          });\n        }\n\n        // Wait for debounce. Skip if no `triggerName` since its from `validateFields / submit`\n        if (validateDebounce && triggerName) {\n          await new Promise(resolve => {\n            setTimeout(resolve, validateDebounce);\n          });\n\n          // Skip since out of date\n          if (this.validatePromise !== rootPromise) {\n            return [];\n          }\n        }\n        const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);\n        promise.catch(e => e).then(function () {\n          let ruleErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_ERRORS;\n          if (_this.validatePromise === rootPromise) {\n            var _ruleErrors$forEach;\n            _this.validatePromise = null;\n\n            // Get errors & warnings\n            const nextErrors = [];\n            const nextWarnings = [];\n            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, _ref2 => {\n              let {\n                rule: {\n                  warningOnly\n                },\n                errors = EMPTY_ERRORS\n              } = _ref2;\n              if (warningOnly) {\n                nextWarnings.push(...errors);\n              } else {\n                nextErrors.push(...errors);\n              }\n            });\n            _this.errors = nextErrors;\n            _this.warnings = nextWarnings;\n            _this.triggerMetaEvent();\n            _this.reRender();\n          }\n        });\n        return promise;\n      });\n      if (validateOnly) {\n        return rootPromise;\n      }\n      this.validatePromise = rootPromise;\n      this.dirty = true;\n      this.errors = EMPTY_ERRORS;\n      this.warnings = EMPTY_WARNINGS;\n      this.triggerMetaEvent();\n\n      // Force trigger re-render since we need sync renderProps with new meta\n      this.reRender();\n      return rootPromise;\n    });\n    _defineProperty(this, \"isFieldValidating\", () => !!this.validatePromise);\n    _defineProperty(this, \"isFieldTouched\", () => this.touched);\n    _defineProperty(this, \"isFieldDirty\", () => {\n      // Touched or validate or has initialValue\n      if (this.dirty || this.props.initialValue !== undefined) {\n        return true;\n      }\n\n      // Form set initialValue\n      const {\n        fieldContext\n      } = this.props;\n      const {\n        getInitialValue\n      } = fieldContext.getInternalHooks(HOOK_MARK);\n      if (getInitialValue(this.getNamePath()) !== undefined) {\n        return true;\n      }\n      return false;\n    });\n    _defineProperty(this, \"getErrors\", () => this.errors);\n    _defineProperty(this, \"getWarnings\", () => this.warnings);\n    _defineProperty(this, \"isListField\", () => this.props.isListField);\n    _defineProperty(this, \"isList\", () => this.props.isList);\n    _defineProperty(this, \"isPreserve\", () => this.props.preserve);\n    // ============================= Child Component =============================\n    _defineProperty(this, \"getMeta\", () => {\n      // Make error & validating in cache to save perf\n      this.prevValidating = this.isFieldValidating();\n      const meta = {\n        touched: this.isFieldTouched(),\n        validating: this.prevValidating,\n        errors: this.errors,\n        warnings: this.warnings,\n        name: this.getNamePath(),\n        validated: this.validatePromise === null\n      };\n      return meta;\n    });\n    // Only return validate child node. If invalidate, will do nothing about field.\n    _defineProperty(this, \"getOnlyChild\", children => {\n      // Support render props\n      if (typeof children === 'function') {\n        const meta = this.getMeta();\n        return _objectSpread(_objectSpread({}, this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext))), {}, {\n          isFunction: true\n        });\n      }\n\n      // Filed element only\n      const childList = toChildrenArray(children);\n      if (childList.length !== 1 || ! /*#__PURE__*/React.isValidElement(childList[0])) {\n        return {\n          child: childList,\n          isFunction: false\n        };\n      }\n      return {\n        child: childList[0],\n        isFunction: false\n      };\n    });\n    // ============================== Field Control ==============================\n    _defineProperty(this, \"getValue\", store => {\n      const {\n        getFieldsValue\n      } = this.props.fieldContext;\n      const namePath = this.getNamePath();\n      return getValue(store || getFieldsValue(true), namePath);\n    });\n    _defineProperty(this, \"getControlled\", function () {\n      let childProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const {\n        name,\n        trigger = 'onChange',\n        validateTrigger,\n        getValueFromEvent,\n        normalize,\n        valuePropName = 'value',\n        getValueProps,\n        fieldContext\n      } = _this.props;\n      const mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\n      const namePath = _this.getNamePath();\n      const {\n        getInternalHooks,\n        getFieldsValue\n      } = fieldContext;\n      const {\n        dispatch\n      } = getInternalHooks(HOOK_MARK);\n      const value = _this.getValue();\n      const mergedGetValueProps = getValueProps || (val => ({\n        [valuePropName]: val\n      }));\n      const originTriggerFunc = childProps[trigger];\n      const valueProps = name !== undefined ? mergedGetValueProps(value) : {};\n\n      // warning when prop value is function\n      if (process.env.NODE_ENV !== 'production' && valueProps) {\n        Object.keys(valueProps).forEach(key => {\n          warning(typeof valueProps[key] !== 'function', \"It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: \".concat(key, \")\"));\n        });\n      }\n      const control = _objectSpread(_objectSpread({}, childProps), valueProps);\n\n      // Add trigger\n      control[trigger] = function () {\n        // Mark as touched\n        _this.touched = true;\n        _this.dirty = true;\n        _this.triggerMetaEvent();\n        let newValue;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        if (getValueFromEvent) {\n          newValue = getValueFromEvent(...args);\n        } else {\n          newValue = defaultGetValueFromEvent(valuePropName, ...args);\n        }\n        if (normalize) {\n          newValue = normalize(newValue, value, getFieldsValue(true));\n        }\n        if (newValue !== value) {\n          dispatch({\n            type: 'updateValue',\n            namePath,\n            value: newValue\n          });\n        }\n        if (originTriggerFunc) {\n          originTriggerFunc(...args);\n        }\n      };\n\n      // Add validateTrigger\n      const validateTriggerList = toArray(mergedValidateTrigger || []);\n      validateTriggerList.forEach(triggerName => {\n        // Wrap additional function of component, so that we can get latest value from store\n        const originTrigger = control[triggerName];\n        control[triggerName] = function () {\n          if (originTrigger) {\n            originTrigger(...arguments);\n          }\n\n          // Always use latest rules\n          const {\n            rules\n          } = _this.props;\n          if (rules && rules.length) {\n            // We dispatch validate to root,\n            // since it will update related data with other field with same name\n            dispatch({\n              type: 'validateField',\n              namePath,\n              triggerName\n            });\n          }\n        };\n      });\n      return control;\n    });\n    if (props.fieldContext) {\n      const {\n        getInternalHooks\n      } = props.fieldContext;\n      const {\n        initEntityValue\n      } = getInternalHooks(HOOK_MARK);\n      initEntityValue(this);\n    }\n  }\n  componentDidMount() {\n    const {\n      shouldUpdate,\n      fieldContext\n    } = this.props;\n    this.mounted = true;\n\n    // Register on init\n    if (fieldContext) {\n      const {\n        getInternalHooks\n      } = fieldContext;\n      const {\n        registerField\n      } = getInternalHooks(HOOK_MARK);\n      this.cancelRegisterFunc = registerField(this);\n    }\n\n    // One more render for component in case fields not ready\n    if (shouldUpdate === true) {\n      this.reRender();\n    }\n  }\n  componentWillUnmount() {\n    this.cancelRegister();\n    this.triggerMetaEvent(true);\n    this.mounted = false;\n  }\n  reRender() {\n    if (!this.mounted) return;\n    this.forceUpdate();\n  }\n  render() {\n    const {\n      resetCount\n    } = this.state;\n    const {\n      children\n    } = this.props;\n    const {\n      child,\n      isFunction\n    } = this.getOnlyChild(children);\n\n    // Not need to `cloneElement` since user can handle this in render function self\n    let returnChildNode;\n    if (isFunction) {\n      returnChildNode = child;\n    } else if (/*#__PURE__*/React.isValidElement(child)) {\n      returnChildNode = /*#__PURE__*/React.cloneElement(child, this.getControlled(child.props));\n    } else {\n      warning(!child, '`children` of Field is not validate ReactElement.');\n      returnChildNode = child;\n    }\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      key: resetCount\n    }, returnChildNode);\n  }\n}\n_defineProperty(Field, \"contextType\", FieldContext);\nfunction WrapperField(_ref3) {\n  var _restProps$isListFiel;\n  let {\n      name\n    } = _ref3,\n    restProps = _objectWithoutProperties(_ref3, _excluded);\n  const fieldContext = React.useContext(FieldContext);\n  const listContext = React.useContext(ListContext);\n  const namePath = name !== undefined ? getNamePath(name) : undefined;\n  const isMergedListField = (_restProps$isListFiel = restProps.isListField) !== null && _restProps$isListFiel !== void 0 ? _restProps$isListFiel : !!listContext;\n  let key = 'keep';\n  if (!isMergedListField) {\n    key = \"_\".concat((namePath || []).join('_'));\n  }\n\n  // Warning if it's a directly list field.\n  // We can still support multiple level field preserve.\n  if (process.env.NODE_ENV !== 'production' && restProps.preserve === false && isMergedListField && namePath.length <= 1) {\n    warning(false, '`preserve` should not apply on Form.List fields.');\n  }\n  return /*#__PURE__*/React.createElement(Field, _extends({\n    key: key,\n    name: namePath,\n    isListField: isMergedListField\n  }, restProps, {\n    fieldContext: fieldContext\n  }));\n}\nexport default WrapperField;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","toChildrenArray","isEqual","warning","React","FieldContext","HOOK_MARK","ListContext","toArray","validateRules","containsNamePath","defaultGetValueFromEvent","getNamePath","getValue","EMPTY_ERRORS","EMPTY_WARNINGS","requireUpdate","shouldUpdate","prev","next","prevValue","nextValue","info","Field","Component","constructor","props","_this","this","_defineProperty","resetCount","preserve","isListField","name","cancelRegisterFunc","fieldContext","prefixName","undefined","rules","map","rule","mounted","setState","_ref","destroy","onMetaChange","meta","_objectSpread","getMeta","metaCache","prevStore","namePathList","dependencies","onReset","store","namePath","curValue","namePathMatch","type","touched","dirty","validatePromise","errors","warnings","triggerMetaEvent","refresh","reRender","data","validating","Promise","resolve","dependencyList","some","dependency","relatedFields","options","currentValue","triggerName","validateOnly","rootPromise","then","validateFirst","messageVariables","validateDebounce","filteredRules","getRules","filter","validateTrigger","triggerList","includes","setTimeout","promise","catch","e","ruleErrors","_ruleErrors$forEach","nextErrors","nextWarnings","forEach","_ref2","warningOnly","push","initialValue","getInitialValue","getInternalHooks","isList","prevValidating","isFieldValidating","isFieldTouched","validated","children","getOnlyChild","getControlled","isFunction","childList","isValidElement","child","getFieldsValue","childProps","trigger","getValueFromEvent","normalize","valuePropName","getValueProps","mergedValidateTrigger","dispatch","value","mergedGetValueProps","val","originTriggerFunc","valueProps","process","env","NODE_ENV","keys","concat","control","newValue","_len","args","Array","_key","validateTriggerList","originTrigger","initEntityValue","componentDidMount","registerField","componentWillUnmount","cancelRegister","forceUpdate","render","state","returnChildNode","cloneElement","createElement","Fragment","WrapperField","_ref3","_restProps$isListFiel","restProps","_objectWithoutProperties","_excluded","useContext","listContext","isMergedListField","join"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/form/es/Field.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport toChildrenArray from \"@rc-component/util/es/Children/toArray\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport ListContext from \"./ListContext\";\nimport { toArray } from \"./utils/typeUtil\";\nimport { validateRules } from \"./utils/validateUtil\";\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from \"./utils/valueUtil\";\nconst EMPTY_ERRORS = [];\nconst EMPTY_WARNINGS = [];\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === 'function') {\n    return shouldUpdate(prev, next, 'source' in info ? {\n      source: info.source\n    } : {});\n  }\n  return prevValue !== nextValue;\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style\n\n// We use Class instead of Hooks here since it will cost much code by using Hooks.\nclass Field extends React.Component {\n  static contextType = FieldContext;\n  state = {\n    resetCount: 0\n  };\n  cancelRegisterFunc = null;\n  mounted = false;\n\n  /**\n   * Follow state should not management in State since it will async update by React.\n   * This makes first render of form can not get correct state value.\n   */\n  touched = false;\n\n  /**\n   * Mark when touched & validated. Currently only used for `dependencies`.\n   * Note that we do not think field with `initialValue` is dirty\n   * but this will be by `isFieldDirty` func.\n   */\n  dirty = false;\n  validatePromise;\n  prevValidating;\n  errors = EMPTY_ERRORS;\n  warnings = EMPTY_WARNINGS;\n\n  // ============================== Subscriptions ==============================\n  constructor(props) {\n    super(props);\n\n    // Register on init\n    if (props.fieldContext) {\n      const {\n        getInternalHooks\n      } = props.fieldContext;\n      const {\n        initEntityValue\n      } = getInternalHooks(HOOK_MARK);\n      initEntityValue(this);\n    }\n  }\n  componentDidMount() {\n    const {\n      shouldUpdate,\n      fieldContext\n    } = this.props;\n    this.mounted = true;\n\n    // Register on init\n    if (fieldContext) {\n      const {\n        getInternalHooks\n      } = fieldContext;\n      const {\n        registerField\n      } = getInternalHooks(HOOK_MARK);\n      this.cancelRegisterFunc = registerField(this);\n    }\n\n    // One more render for component in case fields not ready\n    if (shouldUpdate === true) {\n      this.reRender();\n    }\n  }\n  componentWillUnmount() {\n    this.cancelRegister();\n    this.triggerMetaEvent(true);\n    this.mounted = false;\n  }\n  cancelRegister = () => {\n    const {\n      preserve,\n      isListField,\n      name\n    } = this.props;\n    if (this.cancelRegisterFunc) {\n      this.cancelRegisterFunc(isListField, preserve, getNamePath(name));\n    }\n    this.cancelRegisterFunc = null;\n  };\n\n  // ================================== Utils ==================================\n  getNamePath = () => {\n    const {\n      name,\n      fieldContext\n    } = this.props;\n    const {\n      prefixName = []\n    } = fieldContext;\n    return name !== undefined ? [...prefixName, ...name] : [];\n  };\n  getRules = () => {\n    const {\n      rules = [],\n      fieldContext\n    } = this.props;\n    return rules.map(rule => {\n      if (typeof rule === 'function') {\n        return rule(fieldContext);\n      }\n      return rule;\n    });\n  };\n  reRender() {\n    if (!this.mounted) return;\n    this.forceUpdate();\n  }\n  refresh = () => {\n    if (!this.mounted) return;\n\n    /**\n     * Clean up current node.\n     */\n    this.setState(({\n      resetCount\n    }) => ({\n      resetCount: resetCount + 1\n    }));\n  };\n\n  // Event should only trigger when meta changed\n  metaCache = null;\n  triggerMetaEvent = destroy => {\n    const {\n      onMetaChange\n    } = this.props;\n    if (onMetaChange) {\n      const meta = {\n        ...this.getMeta(),\n        destroy\n      };\n      if (!isEqual(this.metaCache, meta)) {\n        onMetaChange(meta);\n      }\n      this.metaCache = meta;\n    } else {\n      this.metaCache = null;\n    }\n  };\n\n  // ========================= Field Entity Interfaces =========================\n  // Trigger by store update. Check if need update the component\n  onStoreChange = (prevStore, namePathList, info) => {\n    const {\n      shouldUpdate,\n      dependencies = [],\n      onReset\n    } = this.props;\n    const {\n      store\n    } = info;\n    const namePath = this.getNamePath();\n    const prevValue = this.getValue(prevStore);\n    const curValue = this.getValue(store);\n    const namePathMatch = namePathList && containsNamePath(namePathList, namePath);\n\n    // `setFieldsValue` is a quick access to update related status\n    if (info.type === 'valueUpdate' && info.source === 'external' && !isEqual(prevValue, curValue)) {\n      this.touched = true;\n      this.dirty = true;\n      this.validatePromise = null;\n      this.errors = EMPTY_ERRORS;\n      this.warnings = EMPTY_WARNINGS;\n      this.triggerMetaEvent();\n    }\n    switch (info.type) {\n      case 'reset':\n        if (!namePathList || namePathMatch) {\n          // Clean up state\n          this.touched = false;\n          this.dirty = false;\n          this.validatePromise = undefined;\n          this.errors = EMPTY_ERRORS;\n          this.warnings = EMPTY_WARNINGS;\n          this.triggerMetaEvent();\n          onReset?.();\n          this.refresh();\n          return;\n        }\n        break;\n\n      /**\n       * In case field with `preserve = false` nest deps like:\n       * - A = 1 => show B\n       * - B = 1 => show C\n       * - Reset A, need clean B, C\n       */\n      case 'remove':\n        {\n          if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      case 'setField':\n        {\n          const {\n            data\n          } = info;\n          if (namePathMatch) {\n            if ('touched' in data) {\n              this.touched = data.touched;\n            }\n            if ('validating' in data && !('originRCField' in data)) {\n              this.validatePromise = data.validating ? Promise.resolve([]) : null;\n            }\n            if ('errors' in data) {\n              this.errors = data.errors || EMPTY_ERRORS;\n            }\n            if ('warnings' in data) {\n              this.warnings = data.warnings || EMPTY_WARNINGS;\n            }\n            this.dirty = true;\n            this.triggerMetaEvent();\n            this.reRender();\n            return;\n          } else if ('value' in data && containsNamePath(namePathList, namePath, true)) {\n            // Contains path with value should also check\n            this.reRender();\n            return;\n          }\n\n          // Handle update by `setField` with `shouldUpdate`\n          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      case 'dependenciesUpdate':\n        {\n          /**\n           * Trigger when marked `dependencies` updated. Related fields will all update\n           */\n          const dependencyList = dependencies.map(getNamePath);\n          // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\n          // emitted earlier and they will work there\n          // If set it may cause unnecessary twice rerendering\n          if (dependencyList.some(dependency => containsNamePath(info.relatedFields, dependency))) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      default:\n        // 1. If `namePath` exists in `namePathList`, means it's related value and should update\n        //      For example <List name=\"list\"><Field name={['list', 0]}></List>\n        //      If `namePathList` is [['list']] (List value update), Field should be updated\n        //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\n        // 2.\n        //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\n        //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\n        //       is not provided\n        //   2.2 If `shouldUpdate` provided, use customize logic to update the field\n        //       else to check if value changed\n        if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n          this.reRender();\n          return;\n        }\n        break;\n    }\n    if (shouldUpdate === true) {\n      this.reRender();\n    }\n  };\n  validateRules = options => {\n    // We should fixed namePath & value to avoid developer change then by form function\n    const namePath = this.getNamePath();\n    const currentValue = this.getValue();\n    const {\n      triggerName,\n      validateOnly = false\n    } = options || {};\n\n    // Force change to async to avoid rule OOD under renderProps field\n    const rootPromise = Promise.resolve().then(async () => {\n      if (!this.mounted) {\n        return [];\n      }\n      const {\n        validateFirst = false,\n        messageVariables,\n        validateDebounce\n      } = this.props;\n\n      // Start validate\n      let filteredRules = this.getRules();\n      if (triggerName) {\n        filteredRules = filteredRules.filter(rule => rule).filter(rule => {\n          const {\n            validateTrigger\n          } = rule;\n          if (!validateTrigger) {\n            return true;\n          }\n          const triggerList = toArray(validateTrigger);\n          return triggerList.includes(triggerName);\n        });\n      }\n\n      // Wait for debounce. Skip if no `triggerName` since its from `validateFields / submit`\n      if (validateDebounce && triggerName) {\n        await new Promise(resolve => {\n          setTimeout(resolve, validateDebounce);\n        });\n\n        // Skip since out of date\n        if (this.validatePromise !== rootPromise) {\n          return [];\n        }\n      }\n      const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);\n      promise.catch(e => e).then((ruleErrors = EMPTY_ERRORS) => {\n        if (this.validatePromise === rootPromise) {\n          this.validatePromise = null;\n\n          // Get errors & warnings\n          const nextErrors = [];\n          const nextWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors = EMPTY_ERRORS\n          }) => {\n            if (warningOnly) {\n              nextWarnings.push(...errors);\n            } else {\n              nextErrors.push(...errors);\n            }\n          });\n          this.errors = nextErrors;\n          this.warnings = nextWarnings;\n          this.triggerMetaEvent();\n          this.reRender();\n        }\n      });\n      return promise;\n    });\n    if (validateOnly) {\n      return rootPromise;\n    }\n    this.validatePromise = rootPromise;\n    this.dirty = true;\n    this.errors = EMPTY_ERRORS;\n    this.warnings = EMPTY_WARNINGS;\n    this.triggerMetaEvent();\n\n    // Force trigger re-render since we need sync renderProps with new meta\n    this.reRender();\n    return rootPromise;\n  };\n  isFieldValidating = () => !!this.validatePromise;\n  isFieldTouched = () => this.touched;\n  isFieldDirty = () => {\n    // Touched or validate or has initialValue\n    if (this.dirty || this.props.initialValue !== undefined) {\n      return true;\n    }\n\n    // Form set initialValue\n    const {\n      fieldContext\n    } = this.props;\n    const {\n      getInitialValue\n    } = fieldContext.getInternalHooks(HOOK_MARK);\n    if (getInitialValue(this.getNamePath()) !== undefined) {\n      return true;\n    }\n    return false;\n  };\n  getErrors = () => this.errors;\n  getWarnings = () => this.warnings;\n  isListField = () => this.props.isListField;\n  isList = () => this.props.isList;\n  isPreserve = () => this.props.preserve;\n\n  // ============================= Child Component =============================\n  getMeta = () => {\n    // Make error & validating in cache to save perf\n    this.prevValidating = this.isFieldValidating();\n    const meta = {\n      touched: this.isFieldTouched(),\n      validating: this.prevValidating,\n      errors: this.errors,\n      warnings: this.warnings,\n      name: this.getNamePath(),\n      validated: this.validatePromise === null\n    };\n    return meta;\n  };\n\n  // Only return validate child node. If invalidate, will do nothing about field.\n  getOnlyChild = children => {\n    // Support render props\n    if (typeof children === 'function') {\n      const meta = this.getMeta();\n      return {\n        ...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),\n        isFunction: true\n      };\n    }\n\n    // Filed element only\n    const childList = toChildrenArray(children);\n    if (childList.length !== 1 || ! /*#__PURE__*/React.isValidElement(childList[0])) {\n      return {\n        child: childList,\n        isFunction: false\n      };\n    }\n    return {\n      child: childList[0],\n      isFunction: false\n    };\n  };\n\n  // ============================== Field Control ==============================\n  getValue = store => {\n    const {\n      getFieldsValue\n    } = this.props.fieldContext;\n    const namePath = this.getNamePath();\n    return getValue(store || getFieldsValue(true), namePath);\n  };\n  getControlled = (childProps = {}) => {\n    const {\n      name,\n      trigger = 'onChange',\n      validateTrigger,\n      getValueFromEvent,\n      normalize,\n      valuePropName = 'value',\n      getValueProps,\n      fieldContext\n    } = this.props;\n    const mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\n    const namePath = this.getNamePath();\n    const {\n      getInternalHooks,\n      getFieldsValue\n    } = fieldContext;\n    const {\n      dispatch\n    } = getInternalHooks(HOOK_MARK);\n    const value = this.getValue();\n    const mergedGetValueProps = getValueProps || (val => ({\n      [valuePropName]: val\n    }));\n    const originTriggerFunc = childProps[trigger];\n    const valueProps = name !== undefined ? mergedGetValueProps(value) : {};\n\n    // warning when prop value is function\n    if (process.env.NODE_ENV !== 'production' && valueProps) {\n      Object.keys(valueProps).forEach(key => {\n        warning(typeof valueProps[key] !== 'function', `It's not recommended to generate dynamic function prop by \\`getValueProps\\`. Please pass it to child component directly (prop: ${key})`);\n      });\n    }\n    const control = {\n      ...childProps,\n      ...valueProps\n    };\n\n    // Add trigger\n    control[trigger] = (...args) => {\n      // Mark as touched\n      this.touched = true;\n      this.dirty = true;\n      this.triggerMetaEvent();\n      let newValue;\n      if (getValueFromEvent) {\n        newValue = getValueFromEvent(...args);\n      } else {\n        newValue = defaultGetValueFromEvent(valuePropName, ...args);\n      }\n      if (normalize) {\n        newValue = normalize(newValue, value, getFieldsValue(true));\n      }\n      if (newValue !== value) {\n        dispatch({\n          type: 'updateValue',\n          namePath,\n          value: newValue\n        });\n      }\n      if (originTriggerFunc) {\n        originTriggerFunc(...args);\n      }\n    };\n\n    // Add validateTrigger\n    const validateTriggerList = toArray(mergedValidateTrigger || []);\n    validateTriggerList.forEach(triggerName => {\n      // Wrap additional function of component, so that we can get latest value from store\n      const originTrigger = control[triggerName];\n      control[triggerName] = (...args) => {\n        if (originTrigger) {\n          originTrigger(...args);\n        }\n\n        // Always use latest rules\n        const {\n          rules\n        } = this.props;\n        if (rules && rules.length) {\n          // We dispatch validate to root,\n          // since it will update related data with other field with same name\n          dispatch({\n            type: 'validateField',\n            namePath,\n            triggerName\n          });\n        }\n      };\n    });\n    return control;\n  };\n  render() {\n    const {\n      resetCount\n    } = this.state;\n    const {\n      children\n    } = this.props;\n    const {\n      child,\n      isFunction\n    } = this.getOnlyChild(children);\n\n    // Not need to `cloneElement` since user can handle this in render function self\n    let returnChildNode;\n    if (isFunction) {\n      returnChildNode = child;\n    } else if ( /*#__PURE__*/React.isValidElement(child)) {\n      returnChildNode = /*#__PURE__*/React.cloneElement(child, this.getControlled(child.props));\n    } else {\n      warning(!child, '`children` of Field is not validate ReactElement.');\n      returnChildNode = child;\n    }\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      key: resetCount\n    }, returnChildNode);\n  }\n}\nfunction WrapperField({\n  name,\n  ...restProps\n}) {\n  const fieldContext = React.useContext(FieldContext);\n  const listContext = React.useContext(ListContext);\n  const namePath = name !== undefined ? getNamePath(name) : undefined;\n  const isMergedListField = restProps.isListField ?? !!listContext;\n  let key = 'keep';\n  if (!isMergedListField) {\n    key = `_${(namePath || []).join('_')}`;\n  }\n\n  // Warning if it's a directly list field.\n  // We can still support multiple level field preserve.\n  if (process.env.NODE_ENV !== 'production' && restProps.preserve === false && isMergedListField && namePath.length <= 1) {\n    warning(false, '`preserve` should not apply on Form.List fields.');\n  }\n  return /*#__PURE__*/React.createElement(Field, _extends({\n    key: key,\n    name: namePath,\n    isListField: isMergedListField\n  }, restProps, {\n    fieldContext: fieldContext\n  }));\n}\nexport default WrapperField;"],"mappings":";;;;AAAA,SAASA,QAAQA,CAAA,EAAG;EAAEA,QAAQ,GAAGC,MAAM,CAACC,MAAM,GAAGD,MAAM,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,GAAG,UAAUC,MAAM,EAAE;IAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;MAAE,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;QAAE,IAAIP,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;UAAEL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;QAAE;MAAE;IAAE;IAAE,OAAOL,MAAM;EAAE,CAAC;EAAE,OAAOJ,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEP,SAAS,CAAC;AAAE;AAClV,OAAOQ,eAAe,MAAM,wCAAwC;AACpE,OAAOC,OAAO,MAAM,+BAA+B;AACnD,OAAOC,OAAO,MAAM,+BAA+B;AACnD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAOC,YAAY,IAAIC,SAAS,QAAQ,gBAAgB;AACxD,OAAOC,WAAW,MAAM,eAAe;AACvC,SAASC,OAAO,QAAQ,kBAAkB;AAC1C,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,gBAAgB,EAAEC,wBAAwB,EAAEC,WAAW,EAAEC,QAAQ,QAAQ,mBAAmB;AACrG,MAAMC,YAAY,GAAG,EAAE;AACvB,MAAMC,cAAc,GAAG,EAAE;AACzB,SAASC,aAAaA,CAACC,YAAY,EAAEC,IAAI,EAAEC,IAAI,EAAEC,SAAS,EAAEC,SAAS,EAAEC,IAAI,EAAE;EAC3E,IAAI,OAAOL,YAAY,KAAK,UAAU,EAAE;IACtC,OAAOA,YAAY,CAACC,IAAI,EAAEC,IAAI,EAAE,QAAQ,IAAIG,IAAI,GAAG;MACjD3B,MAAM,EAAE2B,IAAI,CAAC3B;IACf,CAAC,GAAG,CAAC,CAAC,CAAC;EACT;EACA,OAAOyB,SAAS,KAAKC,SAAS;AAChC;;AAEA;;AAEA;AACA,MAAME,KAAK,SAASnB,KAAK,CAACoB,SAAS,CAAC;EAyBlC;EACAC,WAAWA,CAACC,KAAK,EAAE;IAAA,IAAAC,KAAA;IAGjB;IAFA,KAAK,CAACD,KAAK,CAAC;IAAAC,KAAA,GAAAC,IAAA;IAAAC,eAAA,gBAzBN;MACNC,UAAU,EAAE;IACd,CAAC;IAAAD,eAAA,6BACoB,IAAI;IAAAA,eAAA,kBACf,KAAK;IAEf;AACF;AACA;AACA;IAHEA,eAAA,kBAIU,KAAK;IAEf;AACF;AACA;AACA;AACA;IAJEA,eAAA,gBAKQ,KAAK;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA,iBAGJf,YAAY;IAAAe,eAAA,mBACVd,cAAc;IAAAc,eAAA,yBA6CR,MAAM;MACrB,MAAM;QACJE,QAAQ;QACRC,WAAW;QACXC;MACF,CAAC,GAAG,IAAI,CAACP,KAAK;MACd,IAAI,IAAI,CAACQ,kBAAkB,EAAE;QAC3B,IAAI,CAACA,kBAAkB,CAACF,WAAW,EAAED,QAAQ,EAAEnB,WAAW,CAACqB,IAAI,CAAC,CAAC;MACnE;MACA,IAAI,CAACC,kBAAkB,GAAG,IAAI;IAChC,CAAC;IAED;IAAAL,eAAA,sBACc,MAAM;MAClB,MAAM;QACJI,IAAI;QACJE;MACF,CAAC,GAAG,IAAI,CAACT,KAAK;MACd,MAAM;QACJU,UAAU,GAAG;MACf,CAAC,GAAGD,YAAY;MAChB,OAAOF,IAAI,KAAKI,SAAS,GAAG,CAAC,GAAGD,UAAU,EAAE,GAAGH,IAAI,CAAC,GAAG,EAAE;IAC3D,CAAC;IAAAJ,eAAA,mBACU,MAAM;MACf,MAAM;QACJS,KAAK,GAAG,EAAE;QACVH;MACF,CAAC,GAAG,IAAI,CAACT,KAAK;MACd,OAAOY,KAAK,CAACC,GAAG,CAACC,IAAI,IAAI;QACvB,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;UAC9B,OAAOA,IAAI,CAACL,YAAY,CAAC;QAC3B;QACA,OAAOK,IAAI;MACb,CAAC,CAAC;IACJ,CAAC;IAAAX,eAAA,kBAKS,MAAM;MACd,IAAI,CAAC,IAAI,CAACY,OAAO,EAAE;;MAEnB;AACJ;AACA;MACI,IAAI,CAACC,QAAQ,CAACC,IAAA;QAAA,IAAC;UACbb;QACF,CAAC,GAAAa,IAAA;QAAA,OAAM;UACLb,UAAU,EAAEA,UAAU,GAAG;QAC3B,CAAC;MAAA,CAAC,CAAC;IACL,CAAC;IAED;IAAAD,eAAA,oBACY,IAAI;IAAAA,eAAA,2BACGe,OAAO,IAAI;MAC5B,MAAM;QACJC;MACF,CAAC,GAAG,IAAI,CAACnB,KAAK;MACd,IAAImB,YAAY,EAAE;QAChB,MAAMC,IAAI,GAAAC,aAAA,CAAAA,aAAA,KACL,IAAI,CAACC,OAAO,CAAC,CAAC;UACjBJ;QAAO,EACR;QACD,IAAI,CAAC1C,OAAO,CAAC,IAAI,CAAC+C,SAAS,EAAEH,IAAI,CAAC,EAAE;UAClCD,YAAY,CAACC,IAAI,CAAC;QACpB;QACA,IAAI,CAACG,SAAS,GAAGH,IAAI;MACvB,CAAC,MAAM;QACL,IAAI,CAACG,SAAS,GAAG,IAAI;MACvB;IACF,CAAC;IAED;IACA;IAAApB,eAAA,wBACgB,CAACqB,SAAS,EAAEC,YAAY,EAAE7B,IAAI,KAAK;MACjD,MAAM;QACJL,YAAY;QACZmC,YAAY,GAAG,EAAE;QACjBC;MACF,CAAC,GAAG,IAAI,CAAC3B,KAAK;MACd,MAAM;QACJ4B;MACF,CAAC,GAAGhC,IAAI;MACR,MAAMiC,QAAQ,GAAG,IAAI,CAAC3C,WAAW,CAAC,CAAC;MACnC,MAAMQ,SAAS,GAAG,IAAI,CAACP,QAAQ,CAACqC,SAAS,CAAC;MAC1C,MAAMM,QAAQ,GAAG,IAAI,CAAC3C,QAAQ,CAACyC,KAAK,CAAC;MACrC,MAAMG,aAAa,GAAGN,YAAY,IAAIzC,gBAAgB,CAACyC,YAAY,EAAEI,QAAQ,CAAC;;MAE9E;MACA,IAAIjC,IAAI,CAACoC,IAAI,KAAK,aAAa,IAAIpC,IAAI,CAAC3B,MAAM,KAAK,UAAU,IAAI,CAACO,OAAO,CAACkB,SAAS,EAAEoC,QAAQ,CAAC,EAAE;QAC9F,IAAI,CAACG,OAAO,GAAG,IAAI;QACnB,IAAI,CAACC,KAAK,GAAG,IAAI;QACjB,IAAI,CAACC,eAAe,GAAG,IAAI;QAC3B,IAAI,CAACC,MAAM,GAAGhD,YAAY;QAC1B,IAAI,CAACiD,QAAQ,GAAGhD,cAAc;QAC9B,IAAI,CAACiD,gBAAgB,CAAC,CAAC;MACzB;MACA,QAAQ1C,IAAI,CAACoC,IAAI;QACf,KAAK,OAAO;UACV,IAAI,CAACP,YAAY,IAAIM,aAAa,EAAE;YAClC;YACA,IAAI,CAACE,OAAO,GAAG,KAAK;YACpB,IAAI,CAACC,KAAK,GAAG,KAAK;YAClB,IAAI,CAACC,eAAe,GAAGxB,SAAS;YAChC,IAAI,CAACyB,MAAM,GAAGhD,YAAY;YAC1B,IAAI,CAACiD,QAAQ,GAAGhD,cAAc;YAC9B,IAAI,CAACiD,gBAAgB,CAAC,CAAC;YACvBX,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAG,CAAC;YACX,IAAI,CAACY,OAAO,CAAC,CAAC;YACd;UACF;UACA;;QAEF;AACN;AACA;AACA;AACA;AACA;QACM,KAAK,QAAQ;UACX;YACE,IAAIhD,YAAY,IAAID,aAAa,CAACC,YAAY,EAAEiC,SAAS,EAAEI,KAAK,EAAElC,SAAS,EAAEoC,QAAQ,EAAElC,IAAI,CAAC,EAAE;cAC5F,IAAI,CAAC4C,QAAQ,CAAC,CAAC;cACf;YACF;YACA;UACF;QACF,KAAK,UAAU;UACb;YACE,MAAM;cACJC;YACF,CAAC,GAAG7C,IAAI;YACR,IAAImC,aAAa,EAAE;cACjB,IAAI,SAAS,IAAIU,IAAI,EAAE;gBACrB,IAAI,CAACR,OAAO,GAAGQ,IAAI,CAACR,OAAO;cAC7B;cACA,IAAI,YAAY,IAAIQ,IAAI,IAAI,EAAE,eAAe,IAAIA,IAAI,CAAC,EAAE;gBACtD,IAAI,CAACN,eAAe,GAAGM,IAAI,CAACC,UAAU,GAAGC,OAAO,CAACC,OAAO,CAAC,EAAE,CAAC,GAAG,IAAI;cACrE;cACA,IAAI,QAAQ,IAAIH,IAAI,EAAE;gBACpB,IAAI,CAACL,MAAM,GAAGK,IAAI,CAACL,MAAM,IAAIhD,YAAY;cAC3C;cACA,IAAI,UAAU,IAAIqD,IAAI,EAAE;gBACtB,IAAI,CAACJ,QAAQ,GAAGI,IAAI,CAACJ,QAAQ,IAAIhD,cAAc;cACjD;cACA,IAAI,CAAC6C,KAAK,GAAG,IAAI;cACjB,IAAI,CAACI,gBAAgB,CAAC,CAAC;cACvB,IAAI,CAACE,QAAQ,CAAC,CAAC;cACf;YACF,CAAC,MAAM,IAAI,OAAO,IAAIC,IAAI,IAAIzD,gBAAgB,CAACyC,YAAY,EAAEI,QAAQ,EAAE,IAAI,CAAC,EAAE;cAC5E;cACA,IAAI,CAACW,QAAQ,CAAC,CAAC;cACf;YACF;;YAEA;YACA,IAAIjD,YAAY,IAAI,CAACsC,QAAQ,CAAC7D,MAAM,IAAIsB,aAAa,CAACC,YAAY,EAAEiC,SAAS,EAAEI,KAAK,EAAElC,SAAS,EAAEoC,QAAQ,EAAElC,IAAI,CAAC,EAAE;cAChH,IAAI,CAAC4C,QAAQ,CAAC,CAAC;cACf;YACF;YACA;UACF;QACF,KAAK,oBAAoB;UACvB;YACE;AACV;AACA;YACU,MAAMK,cAAc,GAAGnB,YAAY,CAACb,GAAG,CAAC3B,WAAW,CAAC;YACpD;YACA;YACA;YACA,IAAI2D,cAAc,CAACC,IAAI,CAACC,UAAU,IAAI/D,gBAAgB,CAACY,IAAI,CAACoD,aAAa,EAAED,UAAU,CAAC,CAAC,EAAE;cACvF,IAAI,CAACP,QAAQ,CAAC,CAAC;cACf;YACF;YACA;UACF;QACF;UACE;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAIT,aAAa,IAAI,CAAC,CAACL,YAAY,CAAC1D,MAAM,IAAI6D,QAAQ,CAAC7D,MAAM,IAAIuB,YAAY,KAAKD,aAAa,CAACC,YAAY,EAAEiC,SAAS,EAAEI,KAAK,EAAElC,SAAS,EAAEoC,QAAQ,EAAElC,IAAI,CAAC,EAAE;YAC1J,IAAI,CAAC4C,QAAQ,CAAC,CAAC;YACf;UACF;UACA;MACJ;MACA,IAAIjD,YAAY,KAAK,IAAI,EAAE;QACzB,IAAI,CAACiD,QAAQ,CAAC,CAAC;MACjB;IACF,CAAC;IAAArC,eAAA,wBACe8C,OAAO,IAAI;MACzB;MACA,MAAMpB,QAAQ,GAAG,IAAI,CAAC3C,WAAW,CAAC,CAAC;MACnC,MAAMgE,YAAY,GAAG,IAAI,CAAC/D,QAAQ,CAAC,CAAC;MACpC,MAAM;QACJgE,WAAW;QACXC,YAAY,GAAG;MACjB,CAAC,GAAGH,OAAO,IAAI,CAAC,CAAC;;MAEjB;MACA,MAAMI,WAAW,GAAGV,OAAO,CAACC,OAAO,CAAC,CAAC,CAACU,IAAI,CAAC,YAAY;QACrD,IAAI,CAAC,IAAI,CAACvC,OAAO,EAAE;UACjB,OAAO,EAAE;QACX;QACA,MAAM;UACJwC,aAAa,GAAG,KAAK;UACrBC,gBAAgB;UAChBC;QACF,CAAC,GAAG,IAAI,CAACzD,KAAK;;QAEd;QACA,IAAI0D,aAAa,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;QACnC,IAAIR,WAAW,EAAE;UACfO,aAAa,GAAGA,aAAa,CAACE,MAAM,CAAC9C,IAAI,IAAIA,IAAI,CAAC,CAAC8C,MAAM,CAAC9C,IAAI,IAAI;YAChE,MAAM;cACJ+C;YACF,CAAC,GAAG/C,IAAI;YACR,IAAI,CAAC+C,eAAe,EAAE;cACpB,OAAO,IAAI;YACb;YACA,MAAMC,WAAW,GAAGhF,OAAO,CAAC+E,eAAe,CAAC;YAC5C,OAAOC,WAAW,CAACC,QAAQ,CAACZ,WAAW,CAAC;UAC1C,CAAC,CAAC;QACJ;;QAEA;QACA,IAAIM,gBAAgB,IAAIN,WAAW,EAAE;UACnC,MAAM,IAAIR,OAAO,CAACC,OAAO,IAAI;YAC3BoB,UAAU,CAACpB,OAAO,EAAEa,gBAAgB,CAAC;UACvC,CAAC,CAAC;;UAEF;UACA,IAAI,IAAI,CAACtB,eAAe,KAAKkB,WAAW,EAAE;YACxC,OAAO,EAAE;UACX;QACF;QACA,MAAMY,OAAO,GAAGlF,aAAa,CAAC8C,QAAQ,EAAEqB,YAAY,EAAEQ,aAAa,EAAET,OAAO,EAAEM,aAAa,EAAEC,gBAAgB,CAAC;QAC9GS,OAAO,CAACC,KAAK,CAACC,CAAC,IAAIA,CAAC,CAAC,CAACb,IAAI,CAAC,YAA+B;UAAA,IAA9Bc,UAAU,GAAArG,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA4C,SAAA,GAAA5C,SAAA,MAAGqB,YAAY;UACnD,IAAIa,KAAI,CAACkC,eAAe,KAAKkB,WAAW,EAAE;YAAA,IAAAgB,mBAAA;YACxCpE,KAAI,CAACkC,eAAe,GAAG,IAAI;;YAE3B;YACA,MAAMmC,UAAU,GAAG,EAAE;YACrB,MAAMC,YAAY,GAAG,EAAE;YACvB,CAAAF,mBAAA,GAAAD,UAAU,CAACI,OAAO,cAAAH,mBAAA,eAAlBA,mBAAA,CAAAhG,IAAA,CAAA+F,UAAU,EAAWK,KAAA,IAKf;cAAA,IALgB;gBACpB3D,IAAI,EAAE;kBACJ4D;gBACF,CAAC;gBACDtC,MAAM,GAAGhD;cACX,CAAC,GAAAqF,KAAA;cACC,IAAIC,WAAW,EAAE;gBACfH,YAAY,CAACI,IAAI,CAAC,GAAGvC,MAAM,CAAC;cAC9B,CAAC,MAAM;gBACLkC,UAAU,CAACK,IAAI,CAAC,GAAGvC,MAAM,CAAC;cAC5B;YACF,CAAC,CAAC;YACFnC,KAAI,CAACmC,MAAM,GAAGkC,UAAU;YACxBrE,KAAI,CAACoC,QAAQ,GAAGkC,YAAY;YAC5BtE,KAAI,CAACqC,gBAAgB,CAAC,CAAC;YACvBrC,KAAI,CAACuC,QAAQ,CAAC,CAAC;UACjB;QACF,CAAC,CAAC;QACF,OAAOyB,OAAO;MAChB,CAAC,CAAC;MACF,IAAIb,YAAY,EAAE;QAChB,OAAOC,WAAW;MACpB;MACA,IAAI,CAAClB,eAAe,GAAGkB,WAAW;MAClC,IAAI,CAACnB,KAAK,GAAG,IAAI;MACjB,IAAI,CAACE,MAAM,GAAGhD,YAAY;MAC1B,IAAI,CAACiD,QAAQ,GAAGhD,cAAc;MAC9B,IAAI,CAACiD,gBAAgB,CAAC,CAAC;;MAEvB;MACA,IAAI,CAACE,QAAQ,CAAC,CAAC;MACf,OAAOa,WAAW;IACpB,CAAC;IAAAlD,eAAA,4BACmB,MAAM,CAAC,CAAC,IAAI,CAACgC,eAAe;IAAAhC,eAAA,yBAC/B,MAAM,IAAI,CAAC8B,OAAO;IAAA9B,eAAA,uBACpB,MAAM;MACnB;MACA,IAAI,IAAI,CAAC+B,KAAK,IAAI,IAAI,CAAClC,KAAK,CAAC4E,YAAY,KAAKjE,SAAS,EAAE;QACvD,OAAO,IAAI;MACb;;MAEA;MACA,MAAM;QACJF;MACF,CAAC,GAAG,IAAI,CAACT,KAAK;MACd,MAAM;QACJ6E;MACF,CAAC,GAAGpE,YAAY,CAACqE,gBAAgB,CAAClG,SAAS,CAAC;MAC5C,IAAIiG,eAAe,CAAC,IAAI,CAAC3F,WAAW,CAAC,CAAC,CAAC,KAAKyB,SAAS,EAAE;QACrD,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC;IAAAR,eAAA,oBACW,MAAM,IAAI,CAACiC,MAAM;IAAAjC,eAAA,sBACf,MAAM,IAAI,CAACkC,QAAQ;IAAAlC,eAAA,sBACnB,MAAM,IAAI,CAACH,KAAK,CAACM,WAAW;IAAAH,eAAA,iBACjC,MAAM,IAAI,CAACH,KAAK,CAAC+E,MAAM;IAAA5E,eAAA,qBACnB,MAAM,IAAI,CAACH,KAAK,CAACK,QAAQ;IAEtC;IAAAF,eAAA,kBACU,MAAM;MACd;MACA,IAAI,CAAC6E,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;MAC9C,MAAM7D,IAAI,GAAG;QACXa,OAAO,EAAE,IAAI,CAACiD,cAAc,CAAC,CAAC;QAC9BxC,UAAU,EAAE,IAAI,CAACsC,cAAc;QAC/B5C,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBC,QAAQ,EAAE,IAAI,CAACA,QAAQ;QACvB9B,IAAI,EAAE,IAAI,CAACrB,WAAW,CAAC,CAAC;QACxBiG,SAAS,EAAE,IAAI,CAAChD,eAAe,KAAK;MACtC,CAAC;MACD,OAAOf,IAAI;IACb,CAAC;IAED;IAAAjB,eAAA,uBACeiF,QAAQ,IAAI;MACzB;MACA,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;QAClC,MAAMhE,IAAI,GAAG,IAAI,CAACE,OAAO,CAAC,CAAC;QAC3B,OAAAD,aAAA,CAAAA,aAAA,KACK,IAAI,CAACgE,YAAY,CAACD,QAAQ,CAAC,IAAI,CAACE,aAAa,CAAC,CAAC,EAAElE,IAAI,EAAE,IAAI,CAACpB,KAAK,CAACS,YAAY,CAAC,CAAC;UACnF8E,UAAU,EAAE;QAAI;MAEpB;;MAEA;MACA,MAAMC,SAAS,GAAGjH,eAAe,CAAC6G,QAAQ,CAAC;MAC3C,IAAII,SAAS,CAACxH,MAAM,KAAK,CAAC,IAAI,EAAE,aAAaU,KAAK,CAAC+G,cAAc,CAACD,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;QAC/E,OAAO;UACLE,KAAK,EAAEF,SAAS;UAChBD,UAAU,EAAE;QACd,CAAC;MACH;MACA,OAAO;QACLG,KAAK,EAAEF,SAAS,CAAC,CAAC,CAAC;QACnBD,UAAU,EAAE;MACd,CAAC;IACH,CAAC;IAED;IAAApF,eAAA,mBACWyB,KAAK,IAAI;MAClB,MAAM;QACJ+D;MACF,CAAC,GAAG,IAAI,CAAC3F,KAAK,CAACS,YAAY;MAC3B,MAAMoB,QAAQ,GAAG,IAAI,CAAC3C,WAAW,CAAC,CAAC;MACnC,OAAOC,QAAQ,CAACyC,KAAK,IAAI+D,cAAc,CAAC,IAAI,CAAC,EAAE9D,QAAQ,CAAC;IAC1D,CAAC;IAAA1B,eAAA,wBACe,YAAqB;MAAA,IAApByF,UAAU,GAAA7H,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA4C,SAAA,GAAA5C,SAAA,MAAG,CAAC,CAAC;MAC9B,MAAM;QACJwC,IAAI;QACJsF,OAAO,GAAG,UAAU;QACpBhC,eAAe;QACfiC,iBAAiB;QACjBC,SAAS;QACTC,aAAa,GAAG,OAAO;QACvBC,aAAa;QACbxF;MACF,CAAC,GAAGR,KAAI,CAACD,KAAK;MACd,MAAMkG,qBAAqB,GAAGrC,eAAe,KAAKlD,SAAS,GAAGkD,eAAe,GAAGpD,YAAY,CAACoD,eAAe;MAC5G,MAAMhC,QAAQ,GAAG5B,KAAI,CAACf,WAAW,CAAC,CAAC;MACnC,MAAM;QACJ4F,gBAAgB;QAChBa;MACF,CAAC,GAAGlF,YAAY;MAChB,MAAM;QACJ0F;MACF,CAAC,GAAGrB,gBAAgB,CAAClG,SAAS,CAAC;MAC/B,MAAMwH,KAAK,GAAGnG,KAAI,CAACd,QAAQ,CAAC,CAAC;MAC7B,MAAMkH,mBAAmB,GAAGJ,aAAa,KAAKK,GAAG,KAAK;QACpD,CAACN,aAAa,GAAGM;MACnB,CAAC,CAAC,CAAC;MACH,MAAMC,iBAAiB,GAAGX,UAAU,CAACC,OAAO,CAAC;MAC7C,MAAMW,UAAU,GAAGjG,IAAI,KAAKI,SAAS,GAAG0F,mBAAmB,CAACD,KAAK,CAAC,GAAG,CAAC,CAAC;;MAEvE;MACA,IAAIK,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAIH,UAAU,EAAE;QACvD9I,MAAM,CAACkJ,IAAI,CAACJ,UAAU,CAAC,CAAChC,OAAO,CAACtG,GAAG,IAAI;UACrCO,OAAO,CAAC,OAAO+H,UAAU,CAACtI,GAAG,CAAC,KAAK,UAAU,kIAAA2I,MAAA,CAAoI3I,GAAG,MAAG,CAAC;QAC1L,CAAC,CAAC;MACJ;MACA,MAAM4I,OAAO,GAAAzF,aAAA,CAAAA,aAAA,KACRuE,UAAU,GACVY,UAAU,CACd;;MAED;MACAM,OAAO,CAACjB,OAAO,CAAC,GAAG,YAAa;QAC9B;QACA5F,KAAI,CAACgC,OAAO,GAAG,IAAI;QACnBhC,KAAI,CAACiC,KAAK,GAAG,IAAI;QACjBjC,KAAI,CAACqC,gBAAgB,CAAC,CAAC;QACvB,IAAIyE,QAAQ;QAAC,SAAAC,IAAA,GAAAjJ,SAAA,CAAAC,MAAA,EALQiJ,IAAI,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;UAAJF,IAAI,CAAAE,IAAA,IAAApJ,SAAA,CAAAoJ,IAAA;QAAA;QAMzB,IAAIrB,iBAAiB,EAAE;UACrBiB,QAAQ,GAAGjB,iBAAiB,CAAC,GAAGmB,IAAI,CAAC;QACvC,CAAC,MAAM;UACLF,QAAQ,GAAG9H,wBAAwB,CAAC+G,aAAa,EAAE,GAAGiB,IAAI,CAAC;QAC7D;QACA,IAAIlB,SAAS,EAAE;UACbgB,QAAQ,GAAGhB,SAAS,CAACgB,QAAQ,EAAEX,KAAK,EAAET,cAAc,CAAC,IAAI,CAAC,CAAC;QAC7D;QACA,IAAIoB,QAAQ,KAAKX,KAAK,EAAE;UACtBD,QAAQ,CAAC;YACPnE,IAAI,EAAE,aAAa;YACnBH,QAAQ;YACRuE,KAAK,EAAEW;UACT,CAAC,CAAC;QACJ;QACA,IAAIR,iBAAiB,EAAE;UACrBA,iBAAiB,CAAC,GAAGU,IAAI,CAAC;QAC5B;MACF,CAAC;;MAED;MACA,MAAMG,mBAAmB,GAAGtI,OAAO,CAACoH,qBAAqB,IAAI,EAAE,CAAC;MAChEkB,mBAAmB,CAAC5C,OAAO,CAACrB,WAAW,IAAI;QACzC;QACA,MAAMkE,aAAa,GAAGP,OAAO,CAAC3D,WAAW,CAAC;QAC1C2D,OAAO,CAAC3D,WAAW,CAAC,GAAG,YAAa;UAClC,IAAIkE,aAAa,EAAE;YACjBA,aAAa,CAAC,GAAAtJ,SAAO,CAAC;UACxB;;UAEA;UACA,MAAM;YACJ6C;UACF,CAAC,GAAGX,KAAI,CAACD,KAAK;UACd,IAAIY,KAAK,IAAIA,KAAK,CAAC5C,MAAM,EAAE;YACzB;YACA;YACAmI,QAAQ,CAAC;cACPnE,IAAI,EAAE,eAAe;cACrBH,QAAQ;cACRsB;YACF,CAAC,CAAC;UACJ;QACF,CAAC;MACH,CAAC,CAAC;MACF,OAAO2D,OAAO;IAChB,CAAC;IAxeC,IAAI9G,KAAK,CAACS,YAAY,EAAE;MACtB,MAAM;QACJqE;MACF,CAAC,GAAG9E,KAAK,CAACS,YAAY;MACtB,MAAM;QACJ6G;MACF,CAAC,GAAGxC,gBAAgB,CAAClG,SAAS,CAAC;MAC/B0I,eAAe,CAAC,IAAI,CAAC;IACvB;EACF;EACAC,iBAAiBA,CAAA,EAAG;IAClB,MAAM;MACJhI,YAAY;MACZkB;IACF,CAAC,GAAG,IAAI,CAACT,KAAK;IACd,IAAI,CAACe,OAAO,GAAG,IAAI;;IAEnB;IACA,IAAIN,YAAY,EAAE;MAChB,MAAM;QACJqE;MACF,CAAC,GAAGrE,YAAY;MAChB,MAAM;QACJ+G;MACF,CAAC,GAAG1C,gBAAgB,CAAClG,SAAS,CAAC;MAC/B,IAAI,CAAC4B,kBAAkB,GAAGgH,aAAa,CAAC,IAAI,CAAC;IAC/C;;IAEA;IACA,IAAIjI,YAAY,KAAK,IAAI,EAAE;MACzB,IAAI,CAACiD,QAAQ,CAAC,CAAC;IACjB;EACF;EACAiF,oBAAoBA,CAAA,EAAG;IACrB,IAAI,CAACC,cAAc,CAAC,CAAC;IACrB,IAAI,CAACpF,gBAAgB,CAAC,IAAI,CAAC;IAC3B,IAAI,CAACvB,OAAO,GAAG,KAAK;EACtB;EAoCAyB,QAAQA,CAAA,EAAG;IACT,IAAI,CAAC,IAAI,CAACzB,OAAO,EAAE;IACnB,IAAI,CAAC4G,WAAW,CAAC,CAAC;EACpB;EA6ZAC,MAAMA,CAAA,EAAG;IACP,MAAM;MACJxH;IACF,CAAC,GAAG,IAAI,CAACyH,KAAK;IACd,MAAM;MACJzC;IACF,CAAC,GAAG,IAAI,CAACpF,KAAK;IACd,MAAM;MACJ0F,KAAK;MACLH;IACF,CAAC,GAAG,IAAI,CAACF,YAAY,CAACD,QAAQ,CAAC;;IAE/B;IACA,IAAI0C,eAAe;IACnB,IAAIvC,UAAU,EAAE;MACduC,eAAe,GAAGpC,KAAK;IACzB,CAAC,MAAM,IAAK,aAAahH,KAAK,CAAC+G,cAAc,CAACC,KAAK,CAAC,EAAE;MACpDoC,eAAe,GAAG,aAAapJ,KAAK,CAACqJ,YAAY,CAACrC,KAAK,EAAE,IAAI,CAACJ,aAAa,CAACI,KAAK,CAAC1F,KAAK,CAAC,CAAC;IAC3F,CAAC,MAAM;MACLvB,OAAO,CAAC,CAACiH,KAAK,EAAE,mDAAmD,CAAC;MACpEoC,eAAe,GAAGpC,KAAK;IACzB;IACA,OAAO,aAAahH,KAAK,CAACsJ,aAAa,CAACtJ,KAAK,CAACuJ,QAAQ,EAAE;MACtD/J,GAAG,EAAEkC;IACP,CAAC,EAAE0H,eAAe,CAAC;EACrB;AACF;AAAC3H,eAAA,CAjiBKN,KAAK,iBACYlB,YAAY;AAiiBnC,SAASuJ,YAAYA,CAAAC,KAAA,EAGlB;EAAA,IAAAC,qBAAA;EAAA,IAHmB;MACpB7H;IAEF,CAAC,GAAA4H,KAAA;IADIE,SAAS,GAAAC,wBAAA,CAAAH,KAAA,EAAAI,SAAA;EAEZ,MAAM9H,YAAY,GAAG/B,KAAK,CAAC8J,UAAU,CAAC7J,YAAY,CAAC;EACnD,MAAM8J,WAAW,GAAG/J,KAAK,CAAC8J,UAAU,CAAC3J,WAAW,CAAC;EACjD,MAAMgD,QAAQ,GAAGtB,IAAI,KAAKI,SAAS,GAAGzB,WAAW,CAACqB,IAAI,CAAC,GAAGI,SAAS;EACnE,MAAM+H,iBAAiB,IAAAN,qBAAA,GAAGC,SAAS,CAAC/H,WAAW,cAAA8H,qBAAA,cAAAA,qBAAA,GAAI,CAAC,CAACK,WAAW;EAChE,IAAIvK,GAAG,GAAG,MAAM;EAChB,IAAI,CAACwK,iBAAiB,EAAE;IACtBxK,GAAG,OAAA2I,MAAA,CAAO,CAAChF,QAAQ,IAAI,EAAE,EAAE8G,IAAI,CAAC,GAAG,CAAC,CAAE;EACxC;;EAEA;EACA;EACA,IAAIlC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAI0B,SAAS,CAAChI,QAAQ,KAAK,KAAK,IAAIqI,iBAAiB,IAAI7G,QAAQ,CAAC7D,MAAM,IAAI,CAAC,EAAE;IACtHS,OAAO,CAAC,KAAK,EAAE,kDAAkD,CAAC;EACpE;EACA,OAAO,aAAaC,KAAK,CAACsJ,aAAa,CAACnI,KAAK,EAAEpC,QAAQ,CAAC;IACtDS,GAAG,EAAEA,GAAG;IACRqC,IAAI,EAAEsB,QAAQ;IACdvB,WAAW,EAAEoI;EACf,CAAC,EAAEL,SAAS,EAAE;IACZ5H,YAAY,EAAEA;EAChB,CAAC,CAAC,CAAC;AACL;AACA,eAAeyH,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}