{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"style\", \"offsetTop\", \"offsetBottom\", \"prefixCls\", \"className\", \"rootClassName\", \"children\", \"target\", \"onChange\", \"onTestUpdatePosition\"];\nimport React from 'react';\nimport ResizeObserver from '@rc-component/resize-observer';\nimport { clsx } from 'clsx';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext, useComponentConfig } from '../config-provider/context';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nconst AFFIX_STATUS_NONE = 0;\nconst AFFIX_STATUS_PREPARE = 1;\nconst Affix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _ref;\n  const {\n      style,\n      offsetTop,\n      offsetBottom,\n      prefixCls,\n      className,\n      rootClassName,\n      children,\n      target,\n      onChange,\n      onTestUpdatePosition\n    } = props,\n    restProps = _objectWithoutProperties(props, _excluded);\n  const {\n    getPrefixCls,\n    className: contextClassName,\n    style: contextStyle\n  } = useComponentConfig('affix');\n  const {\n    getTargetContainer\n  } = React.useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', prefixCls);\n  const [lastAffix, setLastAffix] = React.useState(false);\n  const [affixStyle, setAffixStyle] = React.useState();\n  const [placeholderStyle, setPlaceholderStyle] = React.useState();\n  const status = React.useRef(AFFIX_STATUS_NONE);\n  const prevTarget = React.useRef(null);\n  const prevListener = React.useRef(null);\n  const placeholderNodeRef = React.useRef(null);\n  const fixedNodeRef = React.useRef(null);\n  const timer = React.useRef(null);\n  const targetFunc = (_ref = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _ref !== void 0 ? _ref : getDefaultTarget;\n  const internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n  // =================== Measure ===================\n  const measure = () => {\n    if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n    const targetNode = targetFunc();\n    if (targetNode) {\n      const newState = {\n        status: AFFIX_STATUS_NONE\n      };\n      const placeholderRect = getTargetRect(placeholderNodeRef.current);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        onChange === null || onChange === void 0 || onChange(newState.lastAffix);\n      }\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n  const prepareMeasure = () => {\n    status.current = AFFIX_STATUS_PREPARE;\n    measure();\n    if (process.env.NODE_ENV === 'test') {\n      onTestUpdatePosition === null || onTestUpdatePosition === void 0 || onTestUpdatePosition();\n    }\n  };\n  const updatePosition = throttleByAnimationFrame(() => {\n    prepareMeasure();\n  });\n  const lazyUpdatePosition = throttleByAnimationFrame(() => {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      const targetNode = targetFunc();\n      if (targetNode && placeholderNodeRef.current) {\n        const targetRect = getTargetRect(targetNode);\n        const placeholderRect = getTargetRect(placeholderNodeRef.current);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    }\n    // Directly call prepare measure since it's already throttled.\n    prepareMeasure();\n  });\n  const addListeners = () => {\n    const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    if (!listenerTarget) {\n      return;\n    }\n    TRIGGER_EVENTS.forEach(eventName => {\n      if (prevListener.current) {\n        var _prevTarget$current;\n        (_prevTarget$current = prevTarget.current) === null || _prevTarget$current === void 0 || _prevTarget$current.removeEventListener(eventName, prevListener.current);\n      }\n      listenerTarget === null || listenerTarget === void 0 || listenerTarget.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n  const removeListeners = () => {\n    const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(eventName => {\n      newTarget === null || newTarget === void 0 || newTarget.removeEventListener(eventName, lazyUpdatePosition);\n      if (prevListener.current) {\n        var _prevTarget$current2;\n        (_prevTarget$current2 = prevTarget.current) === null || _prevTarget$current2 === void 0 || _prevTarget$current2.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n  React.useImperativeHandle(ref, () => ({\n    updatePosition\n  }));\n  // mount & unmount\n  React.useEffect(() => {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return () => {\n      if (timer.current) {\n        clearTimeout(timer.current);\n        timer.current = null;\n      }\n      removeListeners();\n    };\n  }, []);\n  React.useEffect(() => {\n    addListeners();\n    return () => removeListeners();\n  }, [target, affixStyle, lastAffix, offsetTop, offsetBottom]);\n  React.useEffect(() => {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  const [hashId, cssVarCls] = useStyle(affixPrefixCls);\n  const rootCls = clsx(rootClassName, hashId, affixPrefixCls, cssVarCls);\n  const mergedCls = clsx({\n    [rootCls]: affixStyle\n  });\n  return /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", _objectSpread({\n    style: _objectSpread(_objectSpread({}, contextStyle), style),\n    className: clsx(className, contextClassName),\n    ref: placeholderNodeRef\n  }, restProps), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: mergedCls,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children))));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","React","ResizeObserver","clsx","throttleByAnimationFrame","ConfigContext","useComponentConfig","useStyle","getFixedBottom","getFixedTop","getTargetRect","TRIGGER_EVENTS","getDefaultTarget","window","AFFIX_STATUS_NONE","AFFIX_STATUS_PREPARE","Affix","forwardRef","props","ref","_ref","style","offsetTop","offsetBottom","prefixCls","className","rootClassName","children","target","onChange","onTestUpdatePosition","restProps","getPrefixCls","contextClassName","contextStyle","getTargetContainer","useContext","affixPrefixCls","lastAffix","setLastAffix","useState","affixStyle","setAffixStyle","placeholderStyle","setPlaceholderStyle","status","useRef","prevTarget","prevListener","placeholderNodeRef","fixedNodeRef","timer","targetFunc","internalOffsetTop","undefined","measure","current","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","position","bottom","prepareMeasure","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","addListeners","listenerTarget","forEach","eventName","_prevTarget$current","removeEventListener","addEventListener","removeListeners","newTarget","_prevTarget$current2","cancel","useImperativeHandle","useEffect","setTimeout","clearTimeout","hashId","cssVarCls","rootCls","mergedCls","createElement","onResize","displayName"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/antd/es/affix/index.js"],"sourcesContent":["\"use client\";\n\nimport React from 'react';\nimport ResizeObserver from '@rc-component/resize-observer';\nimport { clsx } from 'clsx';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext, useComponentConfig } from '../config-provider/context';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nconst AFFIX_STATUS_NONE = 0;\nconst AFFIX_STATUS_PREPARE = 1;\nconst Affix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    style,\n    offsetTop,\n    offsetBottom,\n    prefixCls,\n    className,\n    rootClassName,\n    children,\n    target,\n    onChange,\n    onTestUpdatePosition,\n    ...restProps\n  } = props;\n  const {\n    getPrefixCls,\n    className: contextClassName,\n    style: contextStyle\n  } = useComponentConfig('affix');\n  const {\n    getTargetContainer\n  } = React.useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', prefixCls);\n  const [lastAffix, setLastAffix] = React.useState(false);\n  const [affixStyle, setAffixStyle] = React.useState();\n  const [placeholderStyle, setPlaceholderStyle] = React.useState();\n  const status = React.useRef(AFFIX_STATUS_NONE);\n  const prevTarget = React.useRef(null);\n  const prevListener = React.useRef(null);\n  const placeholderNodeRef = React.useRef(null);\n  const fixedNodeRef = React.useRef(null);\n  const timer = React.useRef(null);\n  const targetFunc = target ?? getTargetContainer ?? getDefaultTarget;\n  const internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n  // =================== Measure ===================\n  const measure = () => {\n    if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n    const targetNode = targetFunc();\n    if (targetNode) {\n      const newState = {\n        status: AFFIX_STATUS_NONE\n      };\n      const placeholderRect = getTargetRect(placeholderNodeRef.current);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        onChange?.(newState.lastAffix);\n      }\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n  const prepareMeasure = () => {\n    status.current = AFFIX_STATUS_PREPARE;\n    measure();\n    if (process.env.NODE_ENV === 'test') {\n      onTestUpdatePosition?.();\n    }\n  };\n  const updatePosition = throttleByAnimationFrame(() => {\n    prepareMeasure();\n  });\n  const lazyUpdatePosition = throttleByAnimationFrame(() => {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      const targetNode = targetFunc();\n      if (targetNode && placeholderNodeRef.current) {\n        const targetRect = getTargetRect(targetNode);\n        const placeholderRect = getTargetRect(placeholderNodeRef.current);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    }\n    // Directly call prepare measure since it's already throttled.\n    prepareMeasure();\n  });\n  const addListeners = () => {\n    const listenerTarget = targetFunc?.();\n    if (!listenerTarget) {\n      return;\n    }\n    TRIGGER_EVENTS.forEach(eventName => {\n      if (prevListener.current) {\n        prevTarget.current?.removeEventListener(eventName, prevListener.current);\n      }\n      listenerTarget?.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n  const removeListeners = () => {\n    const newTarget = targetFunc?.();\n    TRIGGER_EVENTS.forEach(eventName => {\n      newTarget?.removeEventListener(eventName, lazyUpdatePosition);\n      if (prevListener.current) {\n        prevTarget.current?.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n  React.useImperativeHandle(ref, () => ({\n    updatePosition\n  }));\n  // mount & unmount\n  React.useEffect(() => {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return () => {\n      if (timer.current) {\n        clearTimeout(timer.current);\n        timer.current = null;\n      }\n      removeListeners();\n    };\n  }, []);\n  React.useEffect(() => {\n    addListeners();\n    return () => removeListeners();\n  }, [target, affixStyle, lastAffix, offsetTop, offsetBottom]);\n  React.useEffect(() => {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  const [hashId, cssVarCls] = useStyle(affixPrefixCls);\n  const rootCls = clsx(rootClassName, hashId, affixPrefixCls, cssVarCls);\n  const mergedCls = clsx({\n    [rootCls]: affixStyle\n  });\n  return /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      ...contextStyle,\n      ...style\n    },\n    className: clsx(className, contextClassName),\n    ref: placeholderNodeRef,\n    ...restProps\n  }, affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: mergedCls,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children))));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}