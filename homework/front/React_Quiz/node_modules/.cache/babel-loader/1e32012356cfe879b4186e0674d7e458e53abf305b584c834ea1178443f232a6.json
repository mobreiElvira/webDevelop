{"ast":null,"code":"import * as React from 'react';\n\n/** Format the value in the range of [min, max] */\n\n/** Format value align with step */\n\n/** Format value align with step & marks */\n\nexport default function useOffset(min, max, step, markList, allowCross, pushable) {\n  const formatRangeValue = React.useCallback(val => Math.max(min, Math.min(max, val)), [min, max]);\n  const formatStepValue = React.useCallback(val => {\n    if (step !== null) {\n      const stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;\n\n      // Cut number in case to be like 0.30000000000000004\n      const getDecimal = num => (String(num).split('.')[1] || '').length;\n      const maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));\n      const fixedValue = Number(stepValue.toFixed(maxDecimal));\n      return min <= fixedValue && fixedValue <= max ? fixedValue : null;\n    }\n    return null;\n  }, [step, min, max, formatRangeValue]);\n  const formatValue = React.useCallback(val => {\n    const formatNextValue = formatRangeValue(val);\n\n    // List align values\n    const alignValues = markList.map(mark => mark.value);\n    if (step !== null) {\n      alignValues.push(formatStepValue(val));\n    }\n\n    // min & max\n    alignValues.push(min, max);\n\n    // Align with marks\n    let closeValue = alignValues[0];\n    let closeDist = max - min;\n    alignValues.forEach(alignValue => {\n      const dist = Math.abs(formatNextValue - alignValue);\n      if (dist <= closeDist) {\n        closeValue = alignValue;\n        closeDist = dist;\n      }\n    });\n    return closeValue;\n  }, [min, max, markList, step, formatRangeValue, formatStepValue]);\n\n  // ========================== Offset ==========================\n  // Single Value\n  const offsetValue = function (values, offset, valueIndex) {\n    let mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    if (typeof offset === 'number') {\n      let nextValue;\n      const originValue = values[valueIndex];\n\n      // Only used for `dist` mode\n      const targetDistValue = originValue + offset;\n\n      // Compare next step value & mark value which is best match\n      let potentialValues = [];\n      markList.forEach(mark => {\n        potentialValues.push(mark.value);\n      });\n\n      // Min & Max\n      potentialValues.push(min, max);\n\n      // In case origin value is align with mark but not with step\n      potentialValues.push(formatStepValue(originValue));\n\n      // Put offset step value also\n      const sign = offset > 0 ? 1 : -1;\n      if (mode === 'unit') {\n        potentialValues.push(formatStepValue(originValue + sign * step));\n      } else {\n        potentialValues.push(formatStepValue(targetDistValue));\n      }\n\n      // Find close one\n      potentialValues = potentialValues.filter(val => val !== null)\n      // Remove reverse value\n      .filter(val => offset < 0 ? val <= originValue : val >= originValue);\n      if (mode === 'unit') {\n        // `unit` mode can not contain itself\n        potentialValues = potentialValues.filter(val => val !== originValue);\n      }\n      const compareValue = mode === 'unit' ? originValue : targetDistValue;\n      nextValue = potentialValues[0];\n      let valueDist = Math.abs(nextValue - compareValue);\n      potentialValues.forEach(potentialValue => {\n        const dist = Math.abs(potentialValue - compareValue);\n        if (dist < valueDist) {\n          nextValue = potentialValue;\n          valueDist = dist;\n        }\n      });\n\n      // Out of range will back to range\n      if (nextValue === undefined) {\n        return offset < 0 ? min : max;\n      }\n\n      // `dist` mode\n      if (mode === 'dist') {\n        return nextValue;\n      }\n\n      // `unit` mode may need another round\n      if (Math.abs(offset) > 1) {\n        const cloneValues = [...values];\n        cloneValues[valueIndex] = nextValue;\n        return offsetValue(cloneValues, offset - sign, valueIndex, mode);\n      }\n      return nextValue;\n    } else if (offset === 'min') {\n      return min;\n    } else if (offset === 'max') {\n      return max;\n    }\n  };\n\n  /** Same as `offsetValue` but return `changed` mark to tell value changed */\n  const offsetChangedValue = function (values, offset, valueIndex) {\n    let mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    const originValue = values[valueIndex];\n    const nextValue = offsetValue(values, offset, valueIndex, mode);\n    return {\n      value: nextValue,\n      changed: nextValue !== originValue\n    };\n  };\n  const needPush = dist => {\n    return pushable === null && dist === 0 || typeof pushable === 'number' && dist < pushable;\n  };\n\n  // Values\n  const offsetValues = function (values, offset, valueIndex) {\n    let mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    const nextValues = values.map(formatValue);\n    const originValue = nextValues[valueIndex];\n    const nextValue = offsetValue(nextValues, offset, valueIndex, mode);\n    nextValues[valueIndex] = nextValue;\n    if (allowCross === false) {\n      // >>>>> Allow Cross\n      const pushNum = pushable || 0;\n\n      // ============ AllowCross ===============\n      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {\n        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);\n      }\n      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {\n        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);\n      }\n    } else if (typeof pushable === 'number' || pushable === null) {\n      // >>>>> Pushable\n      // =============== Push ==================\n\n      // >>>>>> Basic push\n      // End values\n      for (let i = valueIndex + 1; i < nextValues.length; i += 1) {\n        let changed = true;\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          ({\n            value: nextValues[i],\n            changed\n          } = offsetChangedValue(nextValues, 1, i));\n        }\n      }\n\n      // Start values\n      for (let i = valueIndex; i > 0; i -= 1) {\n        let changed = true;\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          ({\n            value: nextValues[i - 1],\n            changed\n          } = offsetChangedValue(nextValues, -1, i - 1));\n        }\n      }\n\n      // >>>>> Revert back to safe push range\n      // End to Start\n      for (let i = nextValues.length - 1; i > 0; i -= 1) {\n        let changed = true;\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          ({\n            value: nextValues[i - 1],\n            changed\n          } = offsetChangedValue(nextValues, -1, i - 1));\n        }\n      }\n\n      // Start to End\n      for (let i = 0; i < nextValues.length - 1; i += 1) {\n        let changed = true;\n        while (needPush(nextValues[i + 1] - nextValues[i]) && changed) {\n          ({\n            value: nextValues[i + 1],\n            changed\n          } = offsetChangedValue(nextValues, 1, i + 1));\n        }\n      }\n    }\n    return {\n      value: nextValues[valueIndex],\n      values: nextValues\n    };\n  };\n  return [formatValue, offsetValues];\n}","map":{"version":3,"names":["React","useOffset","min","max","step","markList","allowCross","pushable","formatRangeValue","useCallback","val","Math","formatStepValue","stepValue","round","getDecimal","num","String","split","length","maxDecimal","fixedValue","Number","toFixed","formatValue","formatNextValue","alignValues","map","mark","value","push","closeValue","closeDist","forEach","alignValue","dist","abs","offsetValue","values","offset","valueIndex","mode","arguments","undefined","nextValue","originValue","targetDistValue","potentialValues","sign","filter","compareValue","valueDist","potentialValue","cloneValues","offsetChangedValue","changed","needPush","offsetValues","nextValues","pushNum","i"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/slider/es/hooks/useOffset.js"],"sourcesContent":["import * as React from 'react';\n\n/** Format the value in the range of [min, max] */\n\n/** Format value align with step */\n\n/** Format value align with step & marks */\n\nexport default function useOffset(min, max, step, markList, allowCross, pushable) {\n  const formatRangeValue = React.useCallback(val => Math.max(min, Math.min(max, val)), [min, max]);\n  const formatStepValue = React.useCallback(val => {\n    if (step !== null) {\n      const stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;\n\n      // Cut number in case to be like 0.30000000000000004\n      const getDecimal = num => (String(num).split('.')[1] || '').length;\n      const maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));\n      const fixedValue = Number(stepValue.toFixed(maxDecimal));\n      return min <= fixedValue && fixedValue <= max ? fixedValue : null;\n    }\n    return null;\n  }, [step, min, max, formatRangeValue]);\n  const formatValue = React.useCallback(val => {\n    const formatNextValue = formatRangeValue(val);\n\n    // List align values\n    const alignValues = markList.map(mark => mark.value);\n    if (step !== null) {\n      alignValues.push(formatStepValue(val));\n    }\n\n    // min & max\n    alignValues.push(min, max);\n\n    // Align with marks\n    let closeValue = alignValues[0];\n    let closeDist = max - min;\n    alignValues.forEach(alignValue => {\n      const dist = Math.abs(formatNextValue - alignValue);\n      if (dist <= closeDist) {\n        closeValue = alignValue;\n        closeDist = dist;\n      }\n    });\n    return closeValue;\n  }, [min, max, markList, step, formatRangeValue, formatStepValue]);\n\n  // ========================== Offset ==========================\n  // Single Value\n  const offsetValue = (values, offset, valueIndex, mode = 'unit') => {\n    if (typeof offset === 'number') {\n      let nextValue;\n      const originValue = values[valueIndex];\n\n      // Only used for `dist` mode\n      const targetDistValue = originValue + offset;\n\n      // Compare next step value & mark value which is best match\n      let potentialValues = [];\n      markList.forEach(mark => {\n        potentialValues.push(mark.value);\n      });\n\n      // Min & Max\n      potentialValues.push(min, max);\n\n      // In case origin value is align with mark but not with step\n      potentialValues.push(formatStepValue(originValue));\n\n      // Put offset step value also\n      const sign = offset > 0 ? 1 : -1;\n      if (mode === 'unit') {\n        potentialValues.push(formatStepValue(originValue + sign * step));\n      } else {\n        potentialValues.push(formatStepValue(targetDistValue));\n      }\n\n      // Find close one\n      potentialValues = potentialValues.filter(val => val !== null)\n      // Remove reverse value\n      .filter(val => offset < 0 ? val <= originValue : val >= originValue);\n      if (mode === 'unit') {\n        // `unit` mode can not contain itself\n        potentialValues = potentialValues.filter(val => val !== originValue);\n      }\n      const compareValue = mode === 'unit' ? originValue : targetDistValue;\n      nextValue = potentialValues[0];\n      let valueDist = Math.abs(nextValue - compareValue);\n      potentialValues.forEach(potentialValue => {\n        const dist = Math.abs(potentialValue - compareValue);\n        if (dist < valueDist) {\n          nextValue = potentialValue;\n          valueDist = dist;\n        }\n      });\n\n      // Out of range will back to range\n      if (nextValue === undefined) {\n        return offset < 0 ? min : max;\n      }\n\n      // `dist` mode\n      if (mode === 'dist') {\n        return nextValue;\n      }\n\n      // `unit` mode may need another round\n      if (Math.abs(offset) > 1) {\n        const cloneValues = [...values];\n        cloneValues[valueIndex] = nextValue;\n        return offsetValue(cloneValues, offset - sign, valueIndex, mode);\n      }\n      return nextValue;\n    } else if (offset === 'min') {\n      return min;\n    } else if (offset === 'max') {\n      return max;\n    }\n  };\n\n  /** Same as `offsetValue` but return `changed` mark to tell value changed */\n  const offsetChangedValue = (values, offset, valueIndex, mode = 'unit') => {\n    const originValue = values[valueIndex];\n    const nextValue = offsetValue(values, offset, valueIndex, mode);\n    return {\n      value: nextValue,\n      changed: nextValue !== originValue\n    };\n  };\n  const needPush = dist => {\n    return pushable === null && dist === 0 || typeof pushable === 'number' && dist < pushable;\n  };\n\n  // Values\n  const offsetValues = (values, offset, valueIndex, mode = 'unit') => {\n    const nextValues = values.map(formatValue);\n    const originValue = nextValues[valueIndex];\n    const nextValue = offsetValue(nextValues, offset, valueIndex, mode);\n    nextValues[valueIndex] = nextValue;\n    if (allowCross === false) {\n      // >>>>> Allow Cross\n      const pushNum = pushable || 0;\n\n      // ============ AllowCross ===============\n      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {\n        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);\n      }\n      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {\n        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);\n      }\n    } else if (typeof pushable === 'number' || pushable === null) {\n      // >>>>> Pushable\n      // =============== Push ==================\n\n      // >>>>>> Basic push\n      // End values\n      for (let i = valueIndex + 1; i < nextValues.length; i += 1) {\n        let changed = true;\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          ({\n            value: nextValues[i],\n            changed\n          } = offsetChangedValue(nextValues, 1, i));\n        }\n      }\n\n      // Start values\n      for (let i = valueIndex; i > 0; i -= 1) {\n        let changed = true;\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          ({\n            value: nextValues[i - 1],\n            changed\n          } = offsetChangedValue(nextValues, -1, i - 1));\n        }\n      }\n\n      // >>>>> Revert back to safe push range\n      // End to Start\n      for (let i = nextValues.length - 1; i > 0; i -= 1) {\n        let changed = true;\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          ({\n            value: nextValues[i - 1],\n            changed\n          } = offsetChangedValue(nextValues, -1, i - 1));\n        }\n      }\n\n      // Start to End\n      for (let i = 0; i < nextValues.length - 1; i += 1) {\n        let changed = true;\n        while (needPush(nextValues[i + 1] - nextValues[i]) && changed) {\n          ({\n            value: nextValues[i + 1],\n            changed\n          } = offsetChangedValue(nextValues, 1, i + 1));\n        }\n      }\n    }\n    return {\n      value: nextValues[valueIndex],\n      values: nextValues\n    };\n  };\n  return [formatValue, offsetValues];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}