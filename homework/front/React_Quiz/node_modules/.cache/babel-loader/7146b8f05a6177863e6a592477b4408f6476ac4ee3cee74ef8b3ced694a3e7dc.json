{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst getResponsiveMap = token => ({\n  xs: \"(max-width: \".concat(token.screenXSMax, \"px)\"),\n  sm: \"(min-width: \".concat(token.screenSM, \"px)\"),\n  md: \"(min-width: \".concat(token.screenMD, \"px)\"),\n  lg: \"(min-width: \".concat(token.screenLG, \"px)\"),\n  xl: \"(min-width: \".concat(token.screenXL, \"px)\"),\n  xxl: \"(min-width: \".concat(token.screenXXL, \"px)\")\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = \"screen\".concat(breakpointUpper, \"Min\");\n    const screen = \"screen\".concat(breakpointUpper);\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(\"\".concat(screenMin, \"<=\").concat(screen, \" fails : !(\").concat(indexableToken[screenMin], \"<=\").concat(indexableToken[screen], \")\"));\n    }\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = \"screen\".concat(breakpointUpper, \"Max\");\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(\"\".concat(screen, \"<=\").concat(screenMax, \" fails : !(\").concat(indexableToken[screen], \"<=\").concat(indexableToken[screenMax], \")\"));\n      }\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = \"screen\".concat(nextBreakpointUpperMin, \"Min\");\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(\"\".concat(screenMax, \"<=\").concat(nextScreenMin, \" fails : !(\").concat(indexableToken[screenMax], \"<=\").concat(indexableToken[nextScreenMin], \")\"));\n      }\n    }\n  });\n  return token;\n};\nexport const matchScreen = (screens, screenSizes) => {\n  if (!screenSizes) {\n    return;\n  }\n  for (const breakpoint of responsiveArray) {\n    if (screens[breakpoint] && (screenSizes === null || screenSizes === void 0 ? void 0 : screenSizes[breakpoint]) !== undefined) {\n      return screenSizes[breakpoint];\n    }\n  }\n};\nconst useResponsiveObserver = () => {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      responsiveMap,\n      matchHandlers: {},\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n      subscribe(func) {\n        if (!subscribers.size) {\n          this.register();\n        }\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) {\n          this.unregister();\n        }\n      },\n      register() {\n        Object.entries(responsiveMap).forEach(_ref => {\n          let [screen, mediaQuery] = _ref;\n          const listener = _ref2 => {\n            let {\n              matches\n            } = _ref2;\n            this.dispatch(_objectSpread(_objectSpread({}, screens), {}, {\n              [screen]: matches\n            }));\n          };\n          const mql = window.matchMedia(mediaQuery);\n          if (typeof (mql === null || mql === void 0 ? void 0 : mql.addEventListener) === 'function') {\n            mql.addEventListener('change', listener);\n          }\n          this.matchHandlers[mediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n      unregister() {\n        Object.values(responsiveMap).forEach(mediaQuery => {\n          var _handler$mql;\n          const handler = this.matchHandlers[mediaQuery];\n          if (typeof (handler === null || handler === void 0 || (_handler$mql = handler.mql) === null || _handler$mql === void 0 ? void 0 : _handler$mql.removeEventListener) === 'function') {\n            handler.mql.removeEventListener('change', handler === null || handler === void 0 ? void 0 : handler.listener);\n          }\n        });\n        subscribers.clear();\n      }\n    };\n  }, [responsiveMap]);\n};\nexport default useResponsiveObserver;","map":{"version":3,"names":["React","useToken","responsiveArray","getResponsiveMap","token","xs","concat","screenXSMax","sm","screenSM","md","screenMD","lg","screenLG","xl","screenXL","xxl","screenXXL","validateBreakpoints","indexableToken","revBreakpoints","reverse","forEach","breakpoint","i","breakpointUpper","toUpperCase","screenMin","screen","Error","length","screenMax","nextBreakpointUpperMin","nextScreenMin","matchScreen","screens","screenSizes","undefined","useResponsiveObserver","responsiveMap","useMemo","subscribers","Map","subUid","matchHandlers","dispatch","pointMap","func","size","subscribe","register","set","unsubscribe","paramToken","delete","unregister","Object","entries","_ref","mediaQuery","listener","_ref2","matches","_objectSpread","mql","window","matchMedia","addEventListener","values","_handler$mql","handler","removeEventListener","clear"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/antd/es/_util/responsiveObserver.js"],"sourcesContent":["import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\nexport const matchScreen = (screens, screenSizes) => {\n  if (!screenSizes) {\n    return;\n  }\n  for (const breakpoint of responsiveArray) {\n    if (screens[breakpoint] && screenSizes?.[breakpoint] !== undefined) {\n      return screenSizes[breakpoint];\n    }\n  }\n};\nconst useResponsiveObserver = () => {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      responsiveMap,\n      matchHandlers: {},\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n      subscribe(func) {\n        if (!subscribers.size) {\n          this.register();\n        }\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) {\n          this.unregister();\n        }\n      },\n      register() {\n        Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {\n          const listener = ({\n            matches\n          }) => {\n            this.dispatch({\n              ...screens,\n              [screen]: matches\n            });\n          };\n          const mql = window.matchMedia(mediaQuery);\n          if (typeof mql?.addEventListener === 'function') {\n            mql.addEventListener('change', listener);\n          }\n          this.matchHandlers[mediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n      unregister() {\n        Object.values(responsiveMap).forEach(mediaQuery => {\n          const handler = this.matchHandlers[mediaQuery];\n          if (typeof handler?.mql?.removeEventListener === 'function') {\n            handler.mql.removeEventListener('change', handler?.listener);\n          }\n        });\n        subscribers.clear();\n      }\n    };\n  }, [responsiveMap]);\n};\nexport default useResponsiveObserver;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}