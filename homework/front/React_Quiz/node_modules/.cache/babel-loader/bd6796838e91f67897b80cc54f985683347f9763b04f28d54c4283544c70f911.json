{"ast":null,"code":"import KeyCode from \"@rc-component/util/es/KeyCode\";\nimport * as React from 'react';\nimport { SEARCH_MARK } from \"../hooks/useSearchOptions\";\nimport { getFullPathKeys, toPathKey } from \"../utils/commonUtil\";\nexport default (ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) => {\n  const {\n    direction,\n    searchValue,\n    toggleOpen,\n    open\n  } = contextProps;\n  const rtl = direction === 'rtl';\n  const [validActiveValueCells, lastActiveIndex, lastActiveOptions, fullPathKeys] = React.useMemo(() => {\n    let activeIndex = -1;\n    let currentOptions = options;\n    const mergedActiveIndexes = [];\n    const mergedActiveValueCells = [];\n    const len = activeValueCells.length;\n    const pathKeys = getFullPathKeys(options, fieldNames);\n\n    // Fill validate active value cells and index\n    for (let i = 0; i < len && currentOptions; i += 1) {\n      // Mark the active index for current options\n      const nextActiveIndex = currentOptions.findIndex((option, index) => (pathKeys[index] ? toPathKey(pathKeys[index]) : option[fieldNames.value]) === activeValueCells[i]);\n      if (nextActiveIndex === -1) {\n        break;\n      }\n      activeIndex = nextActiveIndex;\n      mergedActiveIndexes.push(activeIndex);\n      mergedActiveValueCells.push(activeValueCells[i]);\n      currentOptions = currentOptions[activeIndex][fieldNames.children];\n    }\n\n    // Fill last active options\n    let activeOptions = options;\n    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {\n      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.children];\n    }\n    return [mergedActiveValueCells, activeIndex, activeOptions, pathKeys];\n  }, [activeValueCells, fieldNames, options]);\n\n  // Update active value cells and scroll to target element\n  const internalSetActiveValueCells = next => {\n    setActiveValueCells(next);\n  };\n\n  // Same options offset\n  const offsetActiveOption = offset => {\n    const len = lastActiveOptions.length;\n    let currentIndex = lastActiveIndex;\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n    for (let i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      const option = lastActiveOptions[currentIndex];\n      if (option && !option.disabled) {\n        const nextActiveCells = validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : option[fieldNames.value]);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  };\n\n  // Different options offset\n  const prevColumn = () => {\n    if (validActiveValueCells.length > 1) {\n      const nextActiveCells = validActiveValueCells.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      toggleOpen(false);\n    }\n  };\n  const nextColumn = () => {\n    var _lastActiveOptions$la;\n    const nextOptions = ((_lastActiveOptions$la = lastActiveOptions[lastActiveIndex]) === null || _lastActiveOptions$la === void 0 ? void 0 : _lastActiveOptions$la[fieldNames.children]) || [];\n    const nextOption = nextOptions.find(option => !option.disabled);\n    if (nextOption) {\n      const nextActiveCells = [...validActiveValueCells, nextOption[fieldNames.value]];\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n  React.useImperativeHandle(ref, () => ({\n    // scrollTo: treeRef.current?.scrollTo,\n    onKeyDown: event => {\n      const {\n        which\n      } = event;\n      switch (which) {\n        // >>> Arrow keys\n        case KeyCode.UP:\n        case KeyCode.DOWN:\n          {\n            let offset = 0;\n            if (which === KeyCode.UP) {\n              offset = -1;\n            } else if (which === KeyCode.DOWN) {\n              offset = 1;\n            }\n            if (offset !== 0) {\n              offsetActiveOption(offset);\n            }\n            break;\n          }\n        case KeyCode.LEFT:\n          {\n            if (searchValue) {\n              break;\n            }\n            if (rtl) {\n              nextColumn();\n            } else {\n              prevColumn();\n            }\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            if (searchValue) {\n              break;\n            }\n            if (rtl) {\n              prevColumn();\n            } else {\n              nextColumn();\n            }\n            break;\n          }\n        case KeyCode.BACKSPACE:\n          {\n            if (!searchValue) {\n              prevColumn();\n            }\n            break;\n          }\n\n        // >>> Select\n        case KeyCode.ENTER:\n          {\n            if (validActiveValueCells.length) {\n              const option = lastActiveOptions[lastActiveIndex];\n\n              // Search option should revert back of origin options\n              const originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];\n              if (originOptions.length) {\n                onKeyBoardSelect(originOptions.map(opt => opt[fieldNames.value]), originOptions[originOptions.length - 1]);\n              } else {\n                onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);\n              }\n            }\n            break;\n          }\n\n        // >>> Close\n        case KeyCode.ESC:\n          {\n            toggleOpen(false);\n            if (open) {\n              event.stopPropagation();\n            }\n          }\n      }\n    },\n    onKeyUp: () => {}\n  }));\n};","map":{"version":3,"names":["KeyCode","React","SEARCH_MARK","getFullPathKeys","toPathKey","ref","options","fieldNames","activeValueCells","setActiveValueCells","onKeyBoardSelect","contextProps","direction","searchValue","toggleOpen","open","rtl","validActiveValueCells","lastActiveIndex","lastActiveOptions","fullPathKeys","useMemo","activeIndex","currentOptions","mergedActiveIndexes","mergedActiveValueCells","len","length","pathKeys","i","nextActiveIndex","findIndex","option","index","value","push","children","activeOptions","internalSetActiveValueCells","next","offsetActiveOption","offset","currentIndex","disabled","nextActiveCells","slice","concat","prevColumn","nextColumn","_lastActiveOptions$la","nextOptions","nextOption","find","useImperativeHandle","onKeyDown","event","which","UP","DOWN","LEFT","RIGHT","BACKSPACE","ENTER","originOptions","map","opt","ESC","stopPropagation","onKeyUp"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/cascader/es/OptionList/useKeyboard.js"],"sourcesContent":["import KeyCode from \"@rc-component/util/es/KeyCode\";\nimport * as React from 'react';\nimport { SEARCH_MARK } from \"../hooks/useSearchOptions\";\nimport { getFullPathKeys, toPathKey } from \"../utils/commonUtil\";\nexport default ((ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) => {\n  const {\n    direction,\n    searchValue,\n    toggleOpen,\n    open\n  } = contextProps;\n  const rtl = direction === 'rtl';\n  const [validActiveValueCells, lastActiveIndex, lastActiveOptions, fullPathKeys] = React.useMemo(() => {\n    let activeIndex = -1;\n    let currentOptions = options;\n    const mergedActiveIndexes = [];\n    const mergedActiveValueCells = [];\n    const len = activeValueCells.length;\n    const pathKeys = getFullPathKeys(options, fieldNames);\n\n    // Fill validate active value cells and index\n    for (let i = 0; i < len && currentOptions; i += 1) {\n      // Mark the active index for current options\n      const nextActiveIndex = currentOptions.findIndex((option, index) => (pathKeys[index] ? toPathKey(pathKeys[index]) : option[fieldNames.value]) === activeValueCells[i]);\n      if (nextActiveIndex === -1) {\n        break;\n      }\n      activeIndex = nextActiveIndex;\n      mergedActiveIndexes.push(activeIndex);\n      mergedActiveValueCells.push(activeValueCells[i]);\n      currentOptions = currentOptions[activeIndex][fieldNames.children];\n    }\n\n    // Fill last active options\n    let activeOptions = options;\n    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {\n      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.children];\n    }\n    return [mergedActiveValueCells, activeIndex, activeOptions, pathKeys];\n  }, [activeValueCells, fieldNames, options]);\n\n  // Update active value cells and scroll to target element\n  const internalSetActiveValueCells = next => {\n    setActiveValueCells(next);\n  };\n\n  // Same options offset\n  const offsetActiveOption = offset => {\n    const len = lastActiveOptions.length;\n    let currentIndex = lastActiveIndex;\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n    for (let i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      const option = lastActiveOptions[currentIndex];\n      if (option && !option.disabled) {\n        const nextActiveCells = validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : option[fieldNames.value]);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  };\n\n  // Different options offset\n  const prevColumn = () => {\n    if (validActiveValueCells.length > 1) {\n      const nextActiveCells = validActiveValueCells.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      toggleOpen(false);\n    }\n  };\n  const nextColumn = () => {\n    const nextOptions = lastActiveOptions[lastActiveIndex]?.[fieldNames.children] || [];\n    const nextOption = nextOptions.find(option => !option.disabled);\n    if (nextOption) {\n      const nextActiveCells = [...validActiveValueCells, nextOption[fieldNames.value]];\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n  React.useImperativeHandle(ref, () => ({\n    // scrollTo: treeRef.current?.scrollTo,\n    onKeyDown: event => {\n      const {\n        which\n      } = event;\n      switch (which) {\n        // >>> Arrow keys\n        case KeyCode.UP:\n        case KeyCode.DOWN:\n          {\n            let offset = 0;\n            if (which === KeyCode.UP) {\n              offset = -1;\n            } else if (which === KeyCode.DOWN) {\n              offset = 1;\n            }\n            if (offset !== 0) {\n              offsetActiveOption(offset);\n            }\n            break;\n          }\n        case KeyCode.LEFT:\n          {\n            if (searchValue) {\n              break;\n            }\n            if (rtl) {\n              nextColumn();\n            } else {\n              prevColumn();\n            }\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            if (searchValue) {\n              break;\n            }\n            if (rtl) {\n              prevColumn();\n            } else {\n              nextColumn();\n            }\n            break;\n          }\n        case KeyCode.BACKSPACE:\n          {\n            if (!searchValue) {\n              prevColumn();\n            }\n            break;\n          }\n\n        // >>> Select\n        case KeyCode.ENTER:\n          {\n            if (validActiveValueCells.length) {\n              const option = lastActiveOptions[lastActiveIndex];\n\n              // Search option should revert back of origin options\n              const originOptions = option?.[SEARCH_MARK] || [];\n              if (originOptions.length) {\n                onKeyBoardSelect(originOptions.map(opt => opt[fieldNames.value]), originOptions[originOptions.length - 1]);\n              } else {\n                onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);\n              }\n            }\n            break;\n          }\n\n        // >>> Close\n        case KeyCode.ESC:\n          {\n            toggleOpen(false);\n            if (open) {\n              event.stopPropagation();\n            }\n          }\n      }\n    },\n    onKeyUp: () => {}\n  }));\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}