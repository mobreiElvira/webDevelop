{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useEvent } from '@rc-component/util';\nimport useState from \"@rc-component/util/es/hooks/useState\";\nimport useSyncState from \"@rc-component/util/es/hooks/useSyncState\";\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport { STATUS_APPEAR, STATUS_ENTER, STATUS_LEAVE, STATUS_NONE, STEP_ACTIVE, STEP_PREPARE, STEP_PREPARED, STEP_START } from \"../interface\";\nimport useDomMotionEvents from \"./useDomMotionEvents\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useStepQueue, { DoStep, isActive, SkipStep } from \"./useStepQueue\";\nexport default function useStatus(supportMotion, visible, getElement, _ref) {\n  let {\n    motionEnter = true,\n    motionAppear = true,\n    motionLeave = true,\n    motionDeadline,\n    motionLeaveImmediately,\n    onAppearPrepare,\n    onEnterPrepare,\n    onLeavePrepare,\n    onAppearStart,\n    onEnterStart,\n    onLeaveStart,\n    onAppearActive,\n    onEnterActive,\n    onLeaveActive,\n    onAppearEnd,\n    onEnterEnd,\n    onLeaveEnd,\n    onVisibleChanged\n  } = _ref;\n  // Used for outer render usage to avoid `visible: false & status: none` to render nothing\n  const [asyncVisible, setAsyncVisible] = useState();\n  const [getStatus, setStatus] = useSyncState(STATUS_NONE);\n  const [style, setStyle] = useState(null);\n  const currentStatus = getStatus();\n  const mountedRef = useRef(false);\n  const deadlineRef = useRef(null);\n\n  // =========================== Dom Node ===========================\n  function getDomElement() {\n    return getElement();\n  }\n\n  // ========================== Motion End ==========================\n  const activeRef = useRef(false);\n\n  /**\n   * Clean up status & style\n   */\n  function updateMotionEndStatus() {\n    setStatus(STATUS_NONE);\n    setStyle(null, true);\n  }\n  const onInternalMotionEnd = useEvent(event => {\n    const status = getStatus();\n    // Do nothing since not in any transition status.\n    // This may happen when `motionDeadline` trigger.\n    if (status === STATUS_NONE) {\n      return;\n    }\n    const element = getDomElement();\n    if (event && !event.deadline && event.target !== element) {\n      // event exists\n      // not initiated by deadline\n      // transitionEnd not fired by inner elements\n      return;\n    }\n    const currentActive = activeRef.current;\n    let canEnd;\n    if (status === STATUS_APPEAR && currentActive) {\n      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);\n    } else if (status === STATUS_ENTER && currentActive) {\n      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);\n    } else if (status === STATUS_LEAVE && currentActive) {\n      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);\n    }\n\n    // Only update status when `canEnd` and not destroyed\n    if (currentActive && canEnd !== false) {\n      updateMotionEndStatus();\n    }\n  });\n  const [patchMotionEvents] = useDomMotionEvents(onInternalMotionEnd);\n\n  // ============================= Step =============================\n  const getEventHandlers = targetStatus => {\n    switch (targetStatus) {\n      case STATUS_APPEAR:\n        return {\n          [STEP_PREPARE]: onAppearPrepare,\n          [STEP_START]: onAppearStart,\n          [STEP_ACTIVE]: onAppearActive\n        };\n      case STATUS_ENTER:\n        return {\n          [STEP_PREPARE]: onEnterPrepare,\n          [STEP_START]: onEnterStart,\n          [STEP_ACTIVE]: onEnterActive\n        };\n      case STATUS_LEAVE:\n        return {\n          [STEP_PREPARE]: onLeavePrepare,\n          [STEP_START]: onLeaveStart,\n          [STEP_ACTIVE]: onLeaveActive\n        };\n      default:\n        return {};\n    }\n  };\n  const eventHandlers = React.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);\n  const [startStep, step] = useStepQueue(currentStatus, !supportMotion, newStep => {\n    // Only prepare step can be skip\n    if (newStep === STEP_PREPARE) {\n      const onPrepare = eventHandlers[STEP_PREPARE];\n      if (!onPrepare) {\n        return SkipStep;\n      }\n      return onPrepare(getDomElement());\n    }\n\n    // Rest step is sync update\n    if (step in eventHandlers) {\n      var _eventHandlers$step;\n      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);\n    }\n    if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {\n      // Patch events when motion needed\n      patchMotionEvents(getDomElement());\n      if (motionDeadline > 0) {\n        clearTimeout(deadlineRef.current);\n        deadlineRef.current = setTimeout(() => {\n          onInternalMotionEnd({\n            deadline: true\n          });\n        }, motionDeadline);\n      }\n    }\n    if (step === STEP_PREPARED) {\n      updateMotionEndStatus();\n    }\n    return DoStep;\n  });\n  const active = isActive(step);\n  activeRef.current = active;\n\n  // ============================ Status ============================\n  const visibleRef = useRef(null);\n\n  // Update with new status\n  useIsomorphicLayoutEffect(() => {\n    // When use Suspense, the `visible` will repeat trigger,\n    // But not real change of the `visible`, we need to skip it.\n    // https://github.com/ant-design/ant-design/issues/44379\n    if (mountedRef.current && visibleRef.current === visible) {\n      return;\n    }\n    setAsyncVisible(visible);\n    const isMounted = mountedRef.current;\n    mountedRef.current = true;\n\n    // if (!supportMotion) {\n    //   return;\n    // }\n\n    let nextStatus;\n\n    // Appear\n    if (!isMounted && visible && motionAppear) {\n      nextStatus = STATUS_APPEAR;\n    }\n\n    // Enter\n    if (isMounted && visible && motionEnter) {\n      nextStatus = STATUS_ENTER;\n    }\n\n    // Leave\n    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {\n      nextStatus = STATUS_LEAVE;\n    }\n    const nextEventHandlers = getEventHandlers(nextStatus);\n\n    // Update to next status\n    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {\n      setStatus(nextStatus);\n      startStep();\n    } else {\n      // Set back in case no motion but prev status has prepare step\n      setStatus(STATUS_NONE);\n    }\n    visibleRef.current = visible;\n  }, [visible]);\n\n  // ============================ Effect ============================\n  // Reset when motion changed\n  useEffect(() => {\n    if (\n    // Cancel appear\n    currentStatus === STATUS_APPEAR && !motionAppear ||\n    // Cancel enter\n    currentStatus === STATUS_ENTER && !motionEnter ||\n    // Cancel leave\n    currentStatus === STATUS_LEAVE && !motionLeave) {\n      setStatus(STATUS_NONE);\n    }\n  }, [motionAppear, motionEnter, motionLeave]);\n  useEffect(() => () => {\n    mountedRef.current = false;\n    clearTimeout(deadlineRef.current);\n  }, []);\n\n  // Trigger `onVisibleChanged`\n  const firstMountChangeRef = React.useRef(false);\n  useEffect(() => {\n    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged\n    if (asyncVisible) {\n      firstMountChangeRef.current = true;\n    }\n    if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {\n      // Skip first render is invisible since it's nothing changed\n      if (firstMountChangeRef.current || asyncVisible) {\n        onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);\n      }\n      firstMountChangeRef.current = true;\n    }\n  }, [asyncVisible, currentStatus]);\n\n  // ============================ Styles ============================\n  let mergedStyle = style;\n  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {\n    mergedStyle = _objectSpread({\n      transition: 'none'\n    }, mergedStyle);\n  }\n  return [getStatus, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];\n}","map":{"version":3,"names":["useEvent","useState","useSyncState","React","useEffect","useRef","STATUS_APPEAR","STATUS_ENTER","STATUS_LEAVE","STATUS_NONE","STEP_ACTIVE","STEP_PREPARE","STEP_PREPARED","STEP_START","useDomMotionEvents","useIsomorphicLayoutEffect","useStepQueue","DoStep","isActive","SkipStep","useStatus","supportMotion","visible","getElement","_ref","motionEnter","motionAppear","motionLeave","motionDeadline","motionLeaveImmediately","onAppearPrepare","onEnterPrepare","onLeavePrepare","onAppearStart","onEnterStart","onLeaveStart","onAppearActive","onEnterActive","onLeaveActive","onAppearEnd","onEnterEnd","onLeaveEnd","onVisibleChanged","asyncVisible","setAsyncVisible","getStatus","setStatus","style","setStyle","currentStatus","mountedRef","deadlineRef","getDomElement","activeRef","updateMotionEndStatus","onInternalMotionEnd","event","status","element","deadline","target","currentActive","current","canEnd","patchMotionEvents","getEventHandlers","targetStatus","eventHandlers","useMemo","startStep","step","newStep","onPrepare","_eventHandlers$step","call","clearTimeout","setTimeout","active","visibleRef","isMounted","nextStatus","nextEventHandlers","firstMountChangeRef","undefined","mergedStyle","_objectSpread","transition"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/motion/es/hooks/useStatus.js"],"sourcesContent":["import { useEvent } from '@rc-component/util';\nimport useState from \"@rc-component/util/es/hooks/useState\";\nimport useSyncState from \"@rc-component/util/es/hooks/useSyncState\";\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport { STATUS_APPEAR, STATUS_ENTER, STATUS_LEAVE, STATUS_NONE, STEP_ACTIVE, STEP_PREPARE, STEP_PREPARED, STEP_START } from \"../interface\";\nimport useDomMotionEvents from \"./useDomMotionEvents\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useStepQueue, { DoStep, isActive, SkipStep } from \"./useStepQueue\";\nexport default function useStatus(supportMotion, visible, getElement, {\n  motionEnter = true,\n  motionAppear = true,\n  motionLeave = true,\n  motionDeadline,\n  motionLeaveImmediately,\n  onAppearPrepare,\n  onEnterPrepare,\n  onLeavePrepare,\n  onAppearStart,\n  onEnterStart,\n  onLeaveStart,\n  onAppearActive,\n  onEnterActive,\n  onLeaveActive,\n  onAppearEnd,\n  onEnterEnd,\n  onLeaveEnd,\n  onVisibleChanged\n}) {\n  // Used for outer render usage to avoid `visible: false & status: none` to render nothing\n  const [asyncVisible, setAsyncVisible] = useState();\n  const [getStatus, setStatus] = useSyncState(STATUS_NONE);\n  const [style, setStyle] = useState(null);\n  const currentStatus = getStatus();\n  const mountedRef = useRef(false);\n  const deadlineRef = useRef(null);\n\n  // =========================== Dom Node ===========================\n  function getDomElement() {\n    return getElement();\n  }\n\n  // ========================== Motion End ==========================\n  const activeRef = useRef(false);\n\n  /**\n   * Clean up status & style\n   */\n  function updateMotionEndStatus() {\n    setStatus(STATUS_NONE);\n    setStyle(null, true);\n  }\n  const onInternalMotionEnd = useEvent(event => {\n    const status = getStatus();\n    // Do nothing since not in any transition status.\n    // This may happen when `motionDeadline` trigger.\n    if (status === STATUS_NONE) {\n      return;\n    }\n    const element = getDomElement();\n    if (event && !event.deadline && event.target !== element) {\n      // event exists\n      // not initiated by deadline\n      // transitionEnd not fired by inner elements\n      return;\n    }\n    const currentActive = activeRef.current;\n    let canEnd;\n    if (status === STATUS_APPEAR && currentActive) {\n      canEnd = onAppearEnd?.(element, event);\n    } else if (status === STATUS_ENTER && currentActive) {\n      canEnd = onEnterEnd?.(element, event);\n    } else if (status === STATUS_LEAVE && currentActive) {\n      canEnd = onLeaveEnd?.(element, event);\n    }\n\n    // Only update status when `canEnd` and not destroyed\n    if (currentActive && canEnd !== false) {\n      updateMotionEndStatus();\n    }\n  });\n  const [patchMotionEvents] = useDomMotionEvents(onInternalMotionEnd);\n\n  // ============================= Step =============================\n  const getEventHandlers = targetStatus => {\n    switch (targetStatus) {\n      case STATUS_APPEAR:\n        return {\n          [STEP_PREPARE]: onAppearPrepare,\n          [STEP_START]: onAppearStart,\n          [STEP_ACTIVE]: onAppearActive\n        };\n      case STATUS_ENTER:\n        return {\n          [STEP_PREPARE]: onEnterPrepare,\n          [STEP_START]: onEnterStart,\n          [STEP_ACTIVE]: onEnterActive\n        };\n      case STATUS_LEAVE:\n        return {\n          [STEP_PREPARE]: onLeavePrepare,\n          [STEP_START]: onLeaveStart,\n          [STEP_ACTIVE]: onLeaveActive\n        };\n      default:\n        return {};\n    }\n  };\n  const eventHandlers = React.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);\n  const [startStep, step] = useStepQueue(currentStatus, !supportMotion, newStep => {\n    // Only prepare step can be skip\n    if (newStep === STEP_PREPARE) {\n      const onPrepare = eventHandlers[STEP_PREPARE];\n      if (!onPrepare) {\n        return SkipStep;\n      }\n      return onPrepare(getDomElement());\n    }\n\n    // Rest step is sync update\n    if (step in eventHandlers) {\n      setStyle(eventHandlers[step]?.(getDomElement(), null) || null);\n    }\n    if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {\n      // Patch events when motion needed\n      patchMotionEvents(getDomElement());\n      if (motionDeadline > 0) {\n        clearTimeout(deadlineRef.current);\n        deadlineRef.current = setTimeout(() => {\n          onInternalMotionEnd({\n            deadline: true\n          });\n        }, motionDeadline);\n      }\n    }\n    if (step === STEP_PREPARED) {\n      updateMotionEndStatus();\n    }\n    return DoStep;\n  });\n  const active = isActive(step);\n  activeRef.current = active;\n\n  // ============================ Status ============================\n  const visibleRef = useRef(null);\n\n  // Update with new status\n  useIsomorphicLayoutEffect(() => {\n    // When use Suspense, the `visible` will repeat trigger,\n    // But not real change of the `visible`, we need to skip it.\n    // https://github.com/ant-design/ant-design/issues/44379\n    if (mountedRef.current && visibleRef.current === visible) {\n      return;\n    }\n    setAsyncVisible(visible);\n    const isMounted = mountedRef.current;\n    mountedRef.current = true;\n\n    // if (!supportMotion) {\n    //   return;\n    // }\n\n    let nextStatus;\n\n    // Appear\n    if (!isMounted && visible && motionAppear) {\n      nextStatus = STATUS_APPEAR;\n    }\n\n    // Enter\n    if (isMounted && visible && motionEnter) {\n      nextStatus = STATUS_ENTER;\n    }\n\n    // Leave\n    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {\n      nextStatus = STATUS_LEAVE;\n    }\n    const nextEventHandlers = getEventHandlers(nextStatus);\n\n    // Update to next status\n    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {\n      setStatus(nextStatus);\n      startStep();\n    } else {\n      // Set back in case no motion but prev status has prepare step\n      setStatus(STATUS_NONE);\n    }\n    visibleRef.current = visible;\n  }, [visible]);\n\n  // ============================ Effect ============================\n  // Reset when motion changed\n  useEffect(() => {\n    if (\n    // Cancel appear\n    currentStatus === STATUS_APPEAR && !motionAppear ||\n    // Cancel enter\n    currentStatus === STATUS_ENTER && !motionEnter ||\n    // Cancel leave\n    currentStatus === STATUS_LEAVE && !motionLeave) {\n      setStatus(STATUS_NONE);\n    }\n  }, [motionAppear, motionEnter, motionLeave]);\n  useEffect(() => () => {\n    mountedRef.current = false;\n    clearTimeout(deadlineRef.current);\n  }, []);\n\n  // Trigger `onVisibleChanged`\n  const firstMountChangeRef = React.useRef(false);\n  useEffect(() => {\n    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged\n    if (asyncVisible) {\n      firstMountChangeRef.current = true;\n    }\n    if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {\n      // Skip first render is invisible since it's nothing changed\n      if (firstMountChangeRef.current || asyncVisible) {\n        onVisibleChanged?.(asyncVisible);\n      }\n      firstMountChangeRef.current = true;\n    }\n  }, [asyncVisible, currentStatus]);\n\n  // ============================ Styles ============================\n  let mergedStyle = style;\n  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {\n    mergedStyle = {\n      transition: 'none',\n      ...mergedStyle\n    };\n  }\n  return [getStatus, step, mergedStyle, asyncVisible ?? visible];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}