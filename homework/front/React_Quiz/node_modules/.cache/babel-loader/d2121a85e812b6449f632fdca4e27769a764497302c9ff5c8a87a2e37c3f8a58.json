{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport hash from '@emotion/hash';\nimport { removeCSS, updateCSS } from \"@rc-component/util/es/Dom/dynamicCSS\";\nimport * as React from 'react';\n// @ts-ignore\nimport unitless from '@emotion/unitless';\nimport { compile, middleware, prefixer, serialize, stringify } from 'stylis';\nimport { contentQuotesLinter, hashedAnimationLinter } from \"../linters\";\nimport StyleContext, { ATTR_CACHE_PATH, ATTR_MARK, CSS_IN_JS_INSTANCE } from \"../StyleContext\";\nimport { isClientSide, toStyleStr } from \"../util\";\nimport { CSS_FILE_STYLE, existPath, getStyleAndHash } from \"../util/cacheMapUtil\";\nimport useGlobalCache from \"./useGlobalCache\";\nconst SKIP_CHECK = '_skip_check_';\nconst MULTI_VALUE = '_multi_value_';\n// ============================================================================\n// ==                                 Parser                                 ==\n// ============================================================================\n// Preprocessor style content to browser support one\nexport function normalizeStyle(styleStr, autoPrefix) {\n  const serialized = autoPrefix ? serialize(compile(styleStr), middleware([prefixer, stringify])) : serialize(compile(styleStr), stringify);\n  return serialized.replace(/\\{%%%\\:[^;];}/g, ';');\n}\nfunction isCompoundCSSProperty(value) {\n  return typeof value === 'object' && value && (SKIP_CHECK in value || MULTI_VALUE in value);\n}\n\n// 注入 hash 值\nfunction injectSelectorHash(key, hashId, hashPriority) {\n  if (!hashId) {\n    return key;\n  }\n  const hashClassName = \".\".concat(hashId);\n  const hashSelector = hashPriority === 'low' ? \":where(\".concat(hashClassName, \")\") : hashClassName;\n\n  // 注入 hashId\n  const keys = key.split(',').map(k => {\n    var _firstPath$match;\n    const fullPath = k.trim().split(/\\s+/);\n\n    // 如果 Selector 第一个是 HTML Element，那我们就插到它的后面。反之，就插到最前面。\n    let firstPath = fullPath[0] || '';\n    const htmlElement = ((_firstPath$match = firstPath.match(/^\\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || '';\n    firstPath = \"\".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));\n    return [firstPath, ...fullPath.slice(1)].join(' ');\n  });\n  return keys.join(',');\n}\n// Parse CSSObject to style content\nexport const parseStyle = function (interpolation) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    root,\n    injectHash,\n    parentSelectors\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    root: true,\n    parentSelectors: []\n  };\n  const {\n    hashId,\n    layer,\n    path,\n    hashPriority,\n    transformers = [],\n    linters = []\n  } = config;\n  let styleStr = '';\n  let effectStyle = {};\n  function parseKeyframes(keyframes) {\n    const animationName = keyframes.getName(hashId);\n    if (!effectStyle[animationName]) {\n      const [parsedStr] = parseStyle(keyframes.style, config, {\n        root: false,\n        parentSelectors\n      });\n      effectStyle[animationName] = \"@keyframes \".concat(keyframes.getName(hashId)).concat(parsedStr);\n    }\n  }\n  function flattenList(list) {\n    let fullList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    list.forEach(item => {\n      if (Array.isArray(item)) {\n        flattenList(item, fullList);\n      } else if (item) {\n        fullList.push(item);\n      }\n    });\n    return fullList;\n  }\n  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);\n  flattenStyleList.forEach(originStyle => {\n    // Only root level can use raw string\n    const style = typeof originStyle === 'string' && !root ? {} : originStyle;\n    if (typeof style === 'string') {\n      styleStr += \"\".concat(style, \"\\n\");\n    } else if (style._keyframe) {\n      // Keyframe\n      parseKeyframes(style);\n    } else {\n      const mergedStyle = transformers.reduce((prev, trans) => {\n        var _trans$visit;\n        return (trans === null || trans === void 0 || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev)) || prev;\n      }, style);\n\n      // Normal CSSObject\n      Object.keys(mergedStyle).forEach(key => {\n        const value = mergedStyle[key];\n        if (typeof value === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {\n          let subInjectHash = false;\n\n          // 当成嵌套对象来处理\n          let mergedKey = key.trim();\n          // Whether treat child as root. In most case it is false.\n          let nextRoot = false;\n\n          // 拆分多个选择器\n          if ((root || injectHash) && hashId) {\n            if (mergedKey.startsWith('@')) {\n              // 略过媒体查询，交给子节点继续插入 hashId\n              subInjectHash = true;\n            } else if (mergedKey === '&') {\n              // 抹掉 root selector 上的单个 &\n              mergedKey = injectSelectorHash('', hashId, hashPriority);\n            } else {\n              // 注入 hashId\n              mergedKey = injectSelectorHash(key, hashId, hashPriority);\n            }\n          } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {\n            // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,\n            // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.\n            // But it does not conform to stylis syntax,\n            // and finally we will get `{color:red;}` as css, which is wrong.\n            // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.\n            mergedKey = '';\n            nextRoot = true;\n          }\n          const [parsedStr, childEffectStyle] = parseStyle(value, config, {\n            root: nextRoot,\n            injectHash: subInjectHash,\n            parentSelectors: [...parentSelectors, mergedKey]\n          });\n          effectStyle = _objectSpread(_objectSpread({}, effectStyle), childEffectStyle);\n          styleStr += \"\".concat(mergedKey).concat(parsedStr);\n        } else {\n          var _value$value;\n          function appendStyle(cssKey, cssValue) {\n            if (process.env.NODE_ENV !== 'production' && (typeof value !== 'object' || !(value !== null && value !== void 0 && value[SKIP_CHECK]))) {\n              [contentQuotesLinter, hashedAnimationLinter, ...linters].forEach(linter => linter(cssKey, cssValue, {\n                path,\n                hashId,\n                parentSelectors\n              }));\n            }\n\n            // 如果是样式则直接插入\n            const styleName = cssKey.replace(/[A-Z]/g, match => \"-\".concat(match.toLowerCase()));\n\n            // Auto suffix with px\n            let formatValue = cssValue;\n            if (!unitless[cssKey] && typeof formatValue === 'number' && formatValue !== 0) {\n              formatValue = \"\".concat(formatValue, \"px\");\n            }\n\n            // handle animationName & Keyframe value\n            if (cssKey === 'animationName' && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {\n              parseKeyframes(cssValue);\n              formatValue = cssValue.getName(hashId);\n            }\n            styleStr += \"\".concat(styleName, \":\").concat(formatValue, \";\");\n          }\n          const actualValue = (_value$value = value === null || value === void 0 ? void 0 : value.value) !== null && _value$value !== void 0 ? _value$value : value;\n          if (typeof value === 'object' && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {\n            actualValue.forEach(item => {\n              appendStyle(key, item);\n            });\n          } else {\n            appendStyle(key, actualValue);\n          }\n        }\n      });\n    }\n  });\n  if (!root) {\n    styleStr = \"{\".concat(styleStr, \"}\");\n  } else if (layer) {\n    // fixme: https://github.com/thysultan/stylis/pull/339\n    if (styleStr) {\n      styleStr = \"@layer \".concat(layer.name, \" {\").concat(styleStr, \"}\");\n    }\n    if (layer.dependencies) {\n      effectStyle[\"@layer \".concat(layer.name)] = layer.dependencies.map(deps => \"@layer \".concat(deps, \", \").concat(layer.name, \";\")).join('\\n');\n    }\n  }\n  return [styleStr, effectStyle];\n};\n\n// ============================================================================\n// ==                                Register                                ==\n// ============================================================================\nexport function uniqueHash(path, styleStr) {\n  return hash(\"\".concat(path.join('%')).concat(styleStr));\n}\nexport const STYLE_PREFIX = 'style';\n/**\n * Register a style to the global style sheet.\n */\nexport default function useStyleRegister(info, styleFn) {\n  const {\n    path,\n    hashId,\n    layer,\n    nonce,\n    clientOnly,\n    order = 0\n  } = info;\n  const {\n    mock,\n    hashPriority,\n    container,\n    transformers,\n    linters,\n    cache,\n    layer: enableLayer,\n    autoPrefix\n  } = React.useContext(StyleContext);\n  const fullPath = [hashId || ''];\n  if (enableLayer) {\n    fullPath.push('layer');\n  }\n  fullPath.push(...path);\n\n  // Check if need insert style\n  let isMergedClientSide = isClientSide;\n  if (process.env.NODE_ENV !== 'production' && mock !== undefined) {\n    isMergedClientSide = mock === 'client';\n  }\n  useGlobalCache(STYLE_PREFIX, fullPath,\n  // Create cache if needed\n  () => {\n    const cachePath = fullPath.join('|');\n\n    // Get style from SSR inline style directly\n    if (existPath(cachePath)) {\n      const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);\n      if (inlineCacheStyleStr) {\n        return [inlineCacheStyleStr, styleHash, {}, clientOnly, order];\n      }\n    }\n\n    // Generate style\n    const styleObj = styleFn();\n    const [parsedStyle, effectStyle] = parseStyle(styleObj, {\n      hashId,\n      hashPriority,\n      layer: enableLayer ? layer : undefined,\n      path: path.join('-'),\n      transformers,\n      linters\n    });\n    const styleStr = normalizeStyle(parsedStyle, autoPrefix || false);\n    const styleId = uniqueHash(fullPath, styleStr);\n    return [styleStr, styleId, effectStyle, clientOnly, order];\n  },\n  // Remove cache if no need\n  (cacheValue, fromHMR) => {\n    const [, styleId] = cacheValue;\n    if (fromHMR && isClientSide) {\n      removeCSS(styleId, {\n        mark: ATTR_MARK,\n        attachTo: container\n      });\n    }\n  },\n  // Effect: Inject style here\n  cacheValue => {\n    const [styleStr, styleId, effectStyle,, priority] = cacheValue;\n    if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {\n      const mergedCSSConfig = {\n        mark: ATTR_MARK,\n        prepend: enableLayer ? false : 'queue',\n        attachTo: container,\n        priority\n      };\n      const nonceStr = typeof nonce === 'function' ? nonce() : nonce;\n      if (nonceStr) {\n        mergedCSSConfig.csp = {\n          nonce: nonceStr\n        };\n      }\n\n      // ================= Split Effect Style =================\n      // We will split effectStyle here since @layer should be at the top level\n      const effectLayerKeys = [];\n      const effectRestKeys = [];\n      Object.keys(effectStyle).forEach(key => {\n        if (key.startsWith('@layer')) {\n          effectLayerKeys.push(key);\n        } else {\n          effectRestKeys.push(key);\n        }\n      });\n\n      // ================= Inject Layer Style =================\n      // Inject layer style\n      effectLayerKeys.forEach(effectKey => {\n        updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), \"_layer-\".concat(effectKey), _objectSpread(_objectSpread({}, mergedCSSConfig), {}, {\n          prepend: true\n        }));\n      });\n\n      // ==================== Inject Style ====================\n      // Inject style\n      const style = updateCSS(styleStr, styleId, mergedCSSConfig);\n      style[CSS_IN_JS_INSTANCE] = cache.instanceId;\n\n      // Debug usage. Dev only\n      if (process.env.NODE_ENV !== 'production') {\n        style.setAttribute(ATTR_CACHE_PATH, fullPath.join('|'));\n      }\n\n      // ================ Inject Effect Style =================\n      // Inject client side effect style\n      effectRestKeys.forEach(effectKey => {\n        updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), \"_effect-\".concat(effectKey), mergedCSSConfig);\n      });\n    }\n  });\n}\nexport const extract = (cache, effectStyles, options) => {\n  const [styleStr, styleId, effectStyle, clientOnly, order] = cache;\n  const {\n    plain,\n    autoPrefix\n  } = options || {};\n\n  // Skip client only style\n  if (clientOnly) {\n    return null;\n  }\n  let keyStyleText = styleStr;\n\n  // ====================== Share ======================\n  // Used for @rc-component/util\n  const sharedAttrs = {\n    'data-rc-order': 'prependQueue',\n    'data-rc-priority': \"\".concat(order)\n  };\n\n  // ====================== Style ======================\n  keyStyleText = toStyleStr(styleStr, undefined, styleId, sharedAttrs, plain);\n\n  // =============== Create effect style ===============\n  if (effectStyle) {\n    Object.keys(effectStyle).forEach(effectKey => {\n      // Effect style can be reused\n      if (!effectStyles[effectKey]) {\n        effectStyles[effectKey] = true;\n        const effectStyleStr = normalizeStyle(effectStyle[effectKey], autoPrefix || false);\n        const effectStyleHTML = toStyleStr(effectStyleStr, undefined, \"_effect-\".concat(effectKey), sharedAttrs, plain);\n        if (effectKey.startsWith('@layer')) {\n          keyStyleText = effectStyleHTML + keyStyleText;\n        } else {\n          keyStyleText += effectStyleHTML;\n        }\n      }\n    });\n  }\n  return [order, styleId, keyStyleText];\n};","map":{"version":3,"names":["hash","removeCSS","updateCSS","React","unitless","compile","middleware","prefixer","serialize","stringify","contentQuotesLinter","hashedAnimationLinter","StyleContext","ATTR_CACHE_PATH","ATTR_MARK","CSS_IN_JS_INSTANCE","isClientSide","toStyleStr","CSS_FILE_STYLE","existPath","getStyleAndHash","useGlobalCache","SKIP_CHECK","MULTI_VALUE","normalizeStyle","styleStr","autoPrefix","serialized","replace","isCompoundCSSProperty","value","injectSelectorHash","key","hashId","hashPriority","hashClassName","concat","hashSelector","keys","split","map","k","_firstPath$match","fullPath","trim","firstPath","htmlElement","match","slice","length","join","parseStyle","interpolation","config","arguments","undefined","root","injectHash","parentSelectors","layer","path","transformers","linters","effectStyle","parseKeyframes","keyframes","animationName","getName","parsedStr","style","flattenList","list","fullList","forEach","item","Array","isArray","push","flattenStyleList","originStyle","_keyframe","mergedStyle","reduce","prev","trans","_trans$visit","visit","call","Object","subInjectHash","mergedKey","nextRoot","startsWith","childEffectStyle","_objectSpread","_value$value","appendStyle","cssKey","cssValue","process","env","NODE_ENV","linter","styleName","toLowerCase","formatValue","actualValue","name","dependencies","deps","uniqueHash","STYLE_PREFIX","useStyleRegister","info","styleFn","nonce","clientOnly","order","mock","container","cache","enableLayer","useContext","isMergedClientSide","cachePath","inlineCacheStyleStr","styleHash","styleObj","parsedStyle","styleId","cacheValue","fromHMR","mark","attachTo","priority","mergedCSSConfig","prepend","nonceStr","csp","effectLayerKeys","effectRestKeys","effectKey","instanceId","setAttribute","extract","effectStyles","options","plain","keyStyleText","sharedAttrs","effectStyleStr","effectStyleHTML"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js"],"sourcesContent":["import hash from '@emotion/hash';\nimport { removeCSS, updateCSS } from \"@rc-component/util/es/Dom/dynamicCSS\";\nimport * as React from 'react';\n// @ts-ignore\nimport unitless from '@emotion/unitless';\nimport { compile, middleware, prefixer, serialize, stringify } from 'stylis';\nimport { contentQuotesLinter, hashedAnimationLinter } from \"../linters\";\nimport StyleContext, { ATTR_CACHE_PATH, ATTR_MARK, CSS_IN_JS_INSTANCE } from \"../StyleContext\";\nimport { isClientSide, toStyleStr } from \"../util\";\nimport { CSS_FILE_STYLE, existPath, getStyleAndHash } from \"../util/cacheMapUtil\";\nimport useGlobalCache from \"./useGlobalCache\";\nconst SKIP_CHECK = '_skip_check_';\nconst MULTI_VALUE = '_multi_value_';\n// ============================================================================\n// ==                                 Parser                                 ==\n// ============================================================================\n// Preprocessor style content to browser support one\nexport function normalizeStyle(styleStr, autoPrefix) {\n  const serialized = autoPrefix ? serialize(compile(styleStr), middleware([prefixer, stringify])) : serialize(compile(styleStr), stringify);\n  return serialized.replace(/\\{%%%\\:[^;];}/g, ';');\n}\nfunction isCompoundCSSProperty(value) {\n  return typeof value === 'object' && value && (SKIP_CHECK in value || MULTI_VALUE in value);\n}\n\n// 注入 hash 值\nfunction injectSelectorHash(key, hashId, hashPriority) {\n  if (!hashId) {\n    return key;\n  }\n  const hashClassName = `.${hashId}`;\n  const hashSelector = hashPriority === 'low' ? `:where(${hashClassName})` : hashClassName;\n\n  // 注入 hashId\n  const keys = key.split(',').map(k => {\n    const fullPath = k.trim().split(/\\s+/);\n\n    // 如果 Selector 第一个是 HTML Element，那我们就插到它的后面。反之，就插到最前面。\n    let firstPath = fullPath[0] || '';\n    const htmlElement = firstPath.match(/^\\w+/)?.[0] || '';\n    firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;\n    return [firstPath, ...fullPath.slice(1)].join(' ');\n  });\n  return keys.join(',');\n}\n// Parse CSSObject to style content\nexport const parseStyle = (interpolation, config = {}, {\n  root,\n  injectHash,\n  parentSelectors\n} = {\n  root: true,\n  parentSelectors: []\n}) => {\n  const {\n    hashId,\n    layer,\n    path,\n    hashPriority,\n    transformers = [],\n    linters = []\n  } = config;\n  let styleStr = '';\n  let effectStyle = {};\n  function parseKeyframes(keyframes) {\n    const animationName = keyframes.getName(hashId);\n    if (!effectStyle[animationName]) {\n      const [parsedStr] = parseStyle(keyframes.style, config, {\n        root: false,\n        parentSelectors\n      });\n      effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;\n    }\n  }\n  function flattenList(list, fullList = []) {\n    list.forEach(item => {\n      if (Array.isArray(item)) {\n        flattenList(item, fullList);\n      } else if (item) {\n        fullList.push(item);\n      }\n    });\n    return fullList;\n  }\n  const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);\n  flattenStyleList.forEach(originStyle => {\n    // Only root level can use raw string\n    const style = typeof originStyle === 'string' && !root ? {} : originStyle;\n    if (typeof style === 'string') {\n      styleStr += `${style}\\n`;\n    } else if (style._keyframe) {\n      // Keyframe\n      parseKeyframes(style);\n    } else {\n      const mergedStyle = transformers.reduce((prev, trans) => trans?.visit?.(prev) || prev, style);\n\n      // Normal CSSObject\n      Object.keys(mergedStyle).forEach(key => {\n        const value = mergedStyle[key];\n        if (typeof value === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {\n          let subInjectHash = false;\n\n          // 当成嵌套对象来处理\n          let mergedKey = key.trim();\n          // Whether treat child as root. In most case it is false.\n          let nextRoot = false;\n\n          // 拆分多个选择器\n          if ((root || injectHash) && hashId) {\n            if (mergedKey.startsWith('@')) {\n              // 略过媒体查询，交给子节点继续插入 hashId\n              subInjectHash = true;\n            } else if (mergedKey === '&') {\n              // 抹掉 root selector 上的单个 &\n              mergedKey = injectSelectorHash('', hashId, hashPriority);\n            } else {\n              // 注入 hashId\n              mergedKey = injectSelectorHash(key, hashId, hashPriority);\n            }\n          } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {\n            // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,\n            // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.\n            // But it does not conform to stylis syntax,\n            // and finally we will get `{color:red;}` as css, which is wrong.\n            // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.\n            mergedKey = '';\n            nextRoot = true;\n          }\n          const [parsedStr, childEffectStyle] = parseStyle(value, config, {\n            root: nextRoot,\n            injectHash: subInjectHash,\n            parentSelectors: [...parentSelectors, mergedKey]\n          });\n          effectStyle = {\n            ...effectStyle,\n            ...childEffectStyle\n          };\n          styleStr += `${mergedKey}${parsedStr}`;\n        } else {\n          function appendStyle(cssKey, cssValue) {\n            if (process.env.NODE_ENV !== 'production' && (typeof value !== 'object' || !value?.[SKIP_CHECK])) {\n              [contentQuotesLinter, hashedAnimationLinter, ...linters].forEach(linter => linter(cssKey, cssValue, {\n                path,\n                hashId,\n                parentSelectors\n              }));\n            }\n\n            // 如果是样式则直接插入\n            const styleName = cssKey.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n\n            // Auto suffix with px\n            let formatValue = cssValue;\n            if (!unitless[cssKey] && typeof formatValue === 'number' && formatValue !== 0) {\n              formatValue = `${formatValue}px`;\n            }\n\n            // handle animationName & Keyframe value\n            if (cssKey === 'animationName' && cssValue?._keyframe) {\n              parseKeyframes(cssValue);\n              formatValue = cssValue.getName(hashId);\n            }\n            styleStr += `${styleName}:${formatValue};`;\n          }\n          const actualValue = value?.value ?? value;\n          if (typeof value === 'object' && value?.[MULTI_VALUE] && Array.isArray(actualValue)) {\n            actualValue.forEach(item => {\n              appendStyle(key, item);\n            });\n          } else {\n            appendStyle(key, actualValue);\n          }\n        }\n      });\n    }\n  });\n  if (!root) {\n    styleStr = `{${styleStr}}`;\n  } else if (layer) {\n    // fixme: https://github.com/thysultan/stylis/pull/339\n    if (styleStr) {\n      styleStr = `@layer ${layer.name} {${styleStr}}`;\n    }\n    if (layer.dependencies) {\n      effectStyle[`@layer ${layer.name}`] = layer.dependencies.map(deps => `@layer ${deps}, ${layer.name};`).join('\\n');\n    }\n  }\n  return [styleStr, effectStyle];\n};\n\n// ============================================================================\n// ==                                Register                                ==\n// ============================================================================\nexport function uniqueHash(path, styleStr) {\n  return hash(`${path.join('%')}${styleStr}`);\n}\nexport const STYLE_PREFIX = 'style';\n/**\n * Register a style to the global style sheet.\n */\nexport default function useStyleRegister(info, styleFn) {\n  const {\n    path,\n    hashId,\n    layer,\n    nonce,\n    clientOnly,\n    order = 0\n  } = info;\n  const {\n    mock,\n    hashPriority,\n    container,\n    transformers,\n    linters,\n    cache,\n    layer: enableLayer,\n    autoPrefix\n  } = React.useContext(StyleContext);\n  const fullPath = [hashId || ''];\n  if (enableLayer) {\n    fullPath.push('layer');\n  }\n  fullPath.push(...path);\n\n  // Check if need insert style\n  let isMergedClientSide = isClientSide;\n  if (process.env.NODE_ENV !== 'production' && mock !== undefined) {\n    isMergedClientSide = mock === 'client';\n  }\n  useGlobalCache(STYLE_PREFIX, fullPath,\n  // Create cache if needed\n  () => {\n    const cachePath = fullPath.join('|');\n\n    // Get style from SSR inline style directly\n    if (existPath(cachePath)) {\n      const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);\n      if (inlineCacheStyleStr) {\n        return [inlineCacheStyleStr, styleHash, {}, clientOnly, order];\n      }\n    }\n\n    // Generate style\n    const styleObj = styleFn();\n    const [parsedStyle, effectStyle] = parseStyle(styleObj, {\n      hashId,\n      hashPriority,\n      layer: enableLayer ? layer : undefined,\n      path: path.join('-'),\n      transformers,\n      linters\n    });\n    const styleStr = normalizeStyle(parsedStyle, autoPrefix || false);\n    const styleId = uniqueHash(fullPath, styleStr);\n    return [styleStr, styleId, effectStyle, clientOnly, order];\n  },\n  // Remove cache if no need\n  (cacheValue, fromHMR) => {\n    const [, styleId] = cacheValue;\n    if (fromHMR && isClientSide) {\n      removeCSS(styleId, {\n        mark: ATTR_MARK,\n        attachTo: container\n      });\n    }\n  },\n  // Effect: Inject style here\n  cacheValue => {\n    const [styleStr, styleId, effectStyle,, priority] = cacheValue;\n    if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {\n      const mergedCSSConfig = {\n        mark: ATTR_MARK,\n        prepend: enableLayer ? false : 'queue',\n        attachTo: container,\n        priority\n      };\n      const nonceStr = typeof nonce === 'function' ? nonce() : nonce;\n      if (nonceStr) {\n        mergedCSSConfig.csp = {\n          nonce: nonceStr\n        };\n      }\n\n      // ================= Split Effect Style =================\n      // We will split effectStyle here since @layer should be at the top level\n      const effectLayerKeys = [];\n      const effectRestKeys = [];\n      Object.keys(effectStyle).forEach(key => {\n        if (key.startsWith('@layer')) {\n          effectLayerKeys.push(key);\n        } else {\n          effectRestKeys.push(key);\n        }\n      });\n\n      // ================= Inject Layer Style =================\n      // Inject layer style\n      effectLayerKeys.forEach(effectKey => {\n        updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_layer-${effectKey}`, {\n          ...mergedCSSConfig,\n          prepend: true\n        });\n      });\n\n      // ==================== Inject Style ====================\n      // Inject style\n      const style = updateCSS(styleStr, styleId, mergedCSSConfig);\n      style[CSS_IN_JS_INSTANCE] = cache.instanceId;\n\n      // Debug usage. Dev only\n      if (process.env.NODE_ENV !== 'production') {\n        style.setAttribute(ATTR_CACHE_PATH, fullPath.join('|'));\n      }\n\n      // ================ Inject Effect Style =================\n      // Inject client side effect style\n      effectRestKeys.forEach(effectKey => {\n        updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_effect-${effectKey}`, mergedCSSConfig);\n      });\n    }\n  });\n}\nexport const extract = (cache, effectStyles, options) => {\n  const [styleStr, styleId, effectStyle, clientOnly, order] = cache;\n  const {\n    plain,\n    autoPrefix\n  } = options || {};\n\n  // Skip client only style\n  if (clientOnly) {\n    return null;\n  }\n  let keyStyleText = styleStr;\n\n  // ====================== Share ======================\n  // Used for @rc-component/util\n  const sharedAttrs = {\n    'data-rc-order': 'prependQueue',\n    'data-rc-priority': `${order}`\n  };\n\n  // ====================== Style ======================\n  keyStyleText = toStyleStr(styleStr, undefined, styleId, sharedAttrs, plain);\n\n  // =============== Create effect style ===============\n  if (effectStyle) {\n    Object.keys(effectStyle).forEach(effectKey => {\n      // Effect style can be reused\n      if (!effectStyles[effectKey]) {\n        effectStyles[effectKey] = true;\n        const effectStyleStr = normalizeStyle(effectStyle[effectKey], autoPrefix || false);\n        const effectStyleHTML = toStyleStr(effectStyleStr, undefined, `_effect-${effectKey}`, sharedAttrs, plain);\n        if (effectKey.startsWith('@layer')) {\n          keyStyleText = effectStyleHTML + keyStyleText;\n        } else {\n          keyStyleText += effectStyleHTML;\n        }\n      }\n    });\n  }\n  return [order, styleId, keyStyleText];\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}