{"ast":null,"code":"function isFixedStart(column) {\n  return column.fixed === 'start';\n}\nfunction isFixedEnd(column) {\n  return column.fixed === 'end';\n}\nexport function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets) {\n  const startColumn = columns[colStart] || {};\n  const endColumn = columns[colEnd] || {};\n  let fixStart = null;\n  let fixEnd = null;\n  if (isFixedStart(startColumn) && isFixedStart(endColumn)) {\n    fixStart = stickyOffsets.start[colStart];\n  } else if (isFixedEnd(endColumn) && isFixedEnd(startColumn)) {\n    fixEnd = stickyOffsets.end[colEnd];\n  }\n\n  // check if need to add shadow\n  let fixedStartShadow = false;\n  let fixedEndShadow = false;\n\n  // Calc `zIndex`.\n  // first fixed start (start -> end) column `zIndex` should be greater than next column.\n  // first fixed end (end -> start) column `zIndex` should be greater than next column.\n  let zIndex = 0;\n  let zIndexReverse = 0;\n  if (fixStart !== null) {\n    fixedStartShadow = !columns[colEnd + 1] || !isFixedStart(columns[colEnd + 1]);\n    zIndex = columns.length * 2 - colStart; // Fix start always overlay fix end\n    zIndexReverse = columns.length + colStart;\n  }\n  if (fixEnd !== null) {\n    fixedEndShadow = !columns[colStart - 1] || !isFixedEnd(columns[colStart - 1]);\n    zIndex = colEnd;\n    zIndexReverse = columns.length - colEnd; // Fix end always overlay fix start\n  }\n\n  // Check if scrollLeft will show the shadow\n  let offsetFixedStartShadow = 0;\n  let offsetFixedEndShadow = 0;\n  if (fixedStartShadow) {\n    for (let i = 0; i < colStart; i += 1) {\n      if (!isFixedStart(columns[i])) {\n        offsetFixedStartShadow += stickyOffsets.widths[i] || 0;\n      }\n    }\n  }\n  if (fixedEndShadow) {\n    for (let i = columns.length - 1; i > colEnd; i -= 1) {\n      if (!isFixedEnd(columns[i])) {\n        offsetFixedEndShadow += stickyOffsets.widths[i] || 0;\n      }\n    }\n  }\n  return {\n    fixStart,\n    fixEnd,\n    fixedStartShadow,\n    fixedEndShadow,\n    offsetFixedStartShadow,\n    offsetFixedEndShadow,\n    isSticky: stickyOffsets.isSticky,\n    zIndex,\n    zIndexReverse\n  };\n}","map":{"version":3,"names":["isFixedStart","column","fixed","isFixedEnd","getCellFixedInfo","colStart","colEnd","columns","stickyOffsets","startColumn","endColumn","fixStart","fixEnd","start","end","fixedStartShadow","fixedEndShadow","zIndex","zIndexReverse","length","offsetFixedStartShadow","offsetFixedEndShadow","i","widths","isSticky"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/table/es/utils/fixUtil.js"],"sourcesContent":["function isFixedStart(column) {\n  return column.fixed === 'start';\n}\nfunction isFixedEnd(column) {\n  return column.fixed === 'end';\n}\nexport function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets) {\n  const startColumn = columns[colStart] || {};\n  const endColumn = columns[colEnd] || {};\n  let fixStart = null;\n  let fixEnd = null;\n  if (isFixedStart(startColumn) && isFixedStart(endColumn)) {\n    fixStart = stickyOffsets.start[colStart];\n  } else if (isFixedEnd(endColumn) && isFixedEnd(startColumn)) {\n    fixEnd = stickyOffsets.end[colEnd];\n  }\n\n  // check if need to add shadow\n  let fixedStartShadow = false;\n  let fixedEndShadow = false;\n\n  // Calc `zIndex`.\n  // first fixed start (start -> end) column `zIndex` should be greater than next column.\n  // first fixed end (end -> start) column `zIndex` should be greater than next column.\n  let zIndex = 0;\n  let zIndexReverse = 0;\n  if (fixStart !== null) {\n    fixedStartShadow = !columns[colEnd + 1] || !isFixedStart(columns[colEnd + 1]);\n    zIndex = columns.length * 2 - colStart; // Fix start always overlay fix end\n    zIndexReverse = columns.length + colStart;\n  }\n  if (fixEnd !== null) {\n    fixedEndShadow = !columns[colStart - 1] || !isFixedEnd(columns[colStart - 1]);\n    zIndex = colEnd;\n    zIndexReverse = columns.length - colEnd; // Fix end always overlay fix start\n  }\n\n  // Check if scrollLeft will show the shadow\n  let offsetFixedStartShadow = 0;\n  let offsetFixedEndShadow = 0;\n  if (fixedStartShadow) {\n    for (let i = 0; i < colStart; i += 1) {\n      if (!isFixedStart(columns[i])) {\n        offsetFixedStartShadow += stickyOffsets.widths[i] || 0;\n      }\n    }\n  }\n  if (fixedEndShadow) {\n    for (let i = columns.length - 1; i > colEnd; i -= 1) {\n      if (!isFixedEnd(columns[i])) {\n        offsetFixedEndShadow += stickyOffsets.widths[i] || 0;\n      }\n    }\n  }\n  return {\n    fixStart,\n    fixEnd,\n    fixedStartShadow,\n    fixedEndShadow,\n    offsetFixedStartShadow,\n    offsetFixedEndShadow,\n    isSticky: stickyOffsets.isSticky,\n    zIndex,\n    zIndexReverse\n  };\n}"],"mappings":"AAAA,SAASA,YAAYA,CAACC,MAAM,EAAE;EAC5B,OAAOA,MAAM,CAACC,KAAK,KAAK,OAAO;AACjC;AACA,SAASC,UAAUA,CAACF,MAAM,EAAE;EAC1B,OAAOA,MAAM,CAACC,KAAK,KAAK,KAAK;AAC/B;AACA,OAAO,SAASE,gBAAgBA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE;EACzE,MAAMC,WAAW,GAAGF,OAAO,CAACF,QAAQ,CAAC,IAAI,CAAC,CAAC;EAC3C,MAAMK,SAAS,GAAGH,OAAO,CAACD,MAAM,CAAC,IAAI,CAAC,CAAC;EACvC,IAAIK,QAAQ,GAAG,IAAI;EACnB,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAIZ,YAAY,CAACS,WAAW,CAAC,IAAIT,YAAY,CAACU,SAAS,CAAC,EAAE;IACxDC,QAAQ,GAAGH,aAAa,CAACK,KAAK,CAACR,QAAQ,CAAC;EAC1C,CAAC,MAAM,IAAIF,UAAU,CAACO,SAAS,CAAC,IAAIP,UAAU,CAACM,WAAW,CAAC,EAAE;IAC3DG,MAAM,GAAGJ,aAAa,CAACM,GAAG,CAACR,MAAM,CAAC;EACpC;;EAEA;EACA,IAAIS,gBAAgB,GAAG,KAAK;EAC5B,IAAIC,cAAc,GAAG,KAAK;;EAE1B;EACA;EACA;EACA,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIP,QAAQ,KAAK,IAAI,EAAE;IACrBI,gBAAgB,GAAG,CAACR,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC,IAAI,CAACN,YAAY,CAACO,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC;IAC7EW,MAAM,GAAGV,OAAO,CAACY,MAAM,GAAG,CAAC,GAAGd,QAAQ,CAAC,CAAC;IACxCa,aAAa,GAAGX,OAAO,CAACY,MAAM,GAAGd,QAAQ;EAC3C;EACA,IAAIO,MAAM,KAAK,IAAI,EAAE;IACnBI,cAAc,GAAG,CAACT,OAAO,CAACF,QAAQ,GAAG,CAAC,CAAC,IAAI,CAACF,UAAU,CAACI,OAAO,CAACF,QAAQ,GAAG,CAAC,CAAC,CAAC;IAC7EY,MAAM,GAAGX,MAAM;IACfY,aAAa,GAAGX,OAAO,CAACY,MAAM,GAAGb,MAAM,CAAC,CAAC;EAC3C;;EAEA;EACA,IAAIc,sBAAsB,GAAG,CAAC;EAC9B,IAAIC,oBAAoB,GAAG,CAAC;EAC5B,IAAIN,gBAAgB,EAAE;IACpB,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,QAAQ,EAAEiB,CAAC,IAAI,CAAC,EAAE;MACpC,IAAI,CAACtB,YAAY,CAACO,OAAO,CAACe,CAAC,CAAC,CAAC,EAAE;QAC7BF,sBAAsB,IAAIZ,aAAa,CAACe,MAAM,CAACD,CAAC,CAAC,IAAI,CAAC;MACxD;IACF;EACF;EACA,IAAIN,cAAc,EAAE;IAClB,KAAK,IAAIM,CAAC,GAAGf,OAAO,CAACY,MAAM,GAAG,CAAC,EAAEG,CAAC,GAAGhB,MAAM,EAAEgB,CAAC,IAAI,CAAC,EAAE;MACnD,IAAI,CAACnB,UAAU,CAACI,OAAO,CAACe,CAAC,CAAC,CAAC,EAAE;QAC3BD,oBAAoB,IAAIb,aAAa,CAACe,MAAM,CAACD,CAAC,CAAC,IAAI,CAAC;MACtD;IACF;EACF;EACA,OAAO;IACLX,QAAQ;IACRC,MAAM;IACNG,gBAAgB;IAChBC,cAAc;IACdI,sBAAsB;IACtBC,oBAAoB;IACpBG,QAAQ,EAAEhB,aAAa,CAACgB,QAAQ;IAChCP,MAAM;IACNC;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}