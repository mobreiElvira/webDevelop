{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nexport const STATUS_ADD = 'add';\nexport const STATUS_KEEP = 'keep';\nexport const STATUS_REMOVE = 'remove';\nexport const STATUS_REMOVED = 'removed';\nexport function wrapKeyToObject(key) {\n  let keyObj;\n  if (key && typeof key === 'object' && 'key' in key) {\n    keyObj = key;\n  } else {\n    keyObj = {\n      key: key\n    };\n  }\n  return _objectSpread(_objectSpread({}, keyObj), {}, {\n    key: String(keyObj.key)\n  });\n}\nexport function parseKeys() {\n  let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return keys.map(wrapKeyToObject);\n}\nexport function diffKeys() {\n  let prevKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let currentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let list = [];\n  let currentIndex = 0;\n  const currentLen = currentKeys.length;\n  const prevKeyObjects = parseKeys(prevKeys);\n  const currentKeyObjects = parseKeys(currentKeys);\n\n  // Check prev keys to insert or keep\n  prevKeyObjects.forEach(keyObj => {\n    let hit = false;\n    for (let i = currentIndex; i < currentLen; i += 1) {\n      const currentKeyObj = currentKeyObjects[i];\n      if (currentKeyObj.key === keyObj.key) {\n        // New added keys should add before current key\n        if (currentIndex < i) {\n          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(obj => _objectSpread(_objectSpread({}, obj), {}, {\n            status: STATUS_ADD\n          })));\n          currentIndex = i;\n        }\n        list.push(_objectSpread(_objectSpread({}, currentKeyObj), {}, {\n          status: STATUS_KEEP\n        }));\n        currentIndex += 1;\n        hit = true;\n        break;\n      }\n    }\n\n    // If not hit, it means key is removed\n    if (!hit) {\n      list.push(_objectSpread(_objectSpread({}, keyObj), {}, {\n        status: STATUS_REMOVE\n      }));\n    }\n  });\n\n  // Add rest to the list\n  if (currentIndex < currentLen) {\n    list = list.concat(currentKeyObjects.slice(currentIndex).map(obj => _objectSpread(_objectSpread({}, obj), {}, {\n      status: STATUS_ADD\n    })));\n  }\n\n  /**\n   * Merge same key when it remove and add again:\n   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]\n   */\n  const keys = {};\n  list.forEach(_ref => {\n    let {\n      key\n    } = _ref;\n    keys[key] = (keys[key] || 0) + 1;\n  });\n  const duplicatedKeys = Object.keys(keys).filter(key => keys[key] > 1);\n  duplicatedKeys.forEach(matchKey => {\n    // Remove `STATUS_REMOVE` node.\n    list = list.filter(_ref2 => {\n      let {\n        key,\n        status\n      } = _ref2;\n      return key !== matchKey || status !== STATUS_REMOVE;\n    });\n\n    // Update `STATUS_ADD` to `STATUS_KEEP`\n    list.forEach(node => {\n      if (node.key === matchKey) {\n        // eslint-disable-next-line no-param-reassign\n        node.status = STATUS_KEEP;\n      }\n    });\n  });\n  return list;\n}","map":{"version":3,"names":["STATUS_ADD","STATUS_KEEP","STATUS_REMOVE","STATUS_REMOVED","wrapKeyToObject","key","keyObj","_objectSpread","String","parseKeys","keys","arguments","length","undefined","map","diffKeys","prevKeys","currentKeys","list","currentIndex","currentLen","prevKeyObjects","currentKeyObjects","forEach","hit","i","currentKeyObj","concat","slice","obj","status","push","_ref","duplicatedKeys","Object","filter","matchKey","_ref2","node"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/motion/es/util/diff.js"],"sourcesContent":["export const STATUS_ADD = 'add';\nexport const STATUS_KEEP = 'keep';\nexport const STATUS_REMOVE = 'remove';\nexport const STATUS_REMOVED = 'removed';\nexport function wrapKeyToObject(key) {\n  let keyObj;\n  if (key && typeof key === 'object' && 'key' in key) {\n    keyObj = key;\n  } else {\n    keyObj = {\n      key: key\n    };\n  }\n  return {\n    ...keyObj,\n    key: String(keyObj.key)\n  };\n}\nexport function parseKeys(keys = []) {\n  return keys.map(wrapKeyToObject);\n}\nexport function diffKeys(prevKeys = [], currentKeys = []) {\n  let list = [];\n  let currentIndex = 0;\n  const currentLen = currentKeys.length;\n  const prevKeyObjects = parseKeys(prevKeys);\n  const currentKeyObjects = parseKeys(currentKeys);\n\n  // Check prev keys to insert or keep\n  prevKeyObjects.forEach(keyObj => {\n    let hit = false;\n    for (let i = currentIndex; i < currentLen; i += 1) {\n      const currentKeyObj = currentKeyObjects[i];\n      if (currentKeyObj.key === keyObj.key) {\n        // New added keys should add before current key\n        if (currentIndex < i) {\n          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(obj => ({\n            ...obj,\n            status: STATUS_ADD\n          })));\n          currentIndex = i;\n        }\n        list.push({\n          ...currentKeyObj,\n          status: STATUS_KEEP\n        });\n        currentIndex += 1;\n        hit = true;\n        break;\n      }\n    }\n\n    // If not hit, it means key is removed\n    if (!hit) {\n      list.push({\n        ...keyObj,\n        status: STATUS_REMOVE\n      });\n    }\n  });\n\n  // Add rest to the list\n  if (currentIndex < currentLen) {\n    list = list.concat(currentKeyObjects.slice(currentIndex).map(obj => ({\n      ...obj,\n      status: STATUS_ADD\n    })));\n  }\n\n  /**\n   * Merge same key when it remove and add again:\n   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]\n   */\n  const keys = {};\n  list.forEach(({\n    key\n  }) => {\n    keys[key] = (keys[key] || 0) + 1;\n  });\n  const duplicatedKeys = Object.keys(keys).filter(key => keys[key] > 1);\n  duplicatedKeys.forEach(matchKey => {\n    // Remove `STATUS_REMOVE` node.\n    list = list.filter(({\n      key,\n      status\n    }) => key !== matchKey || status !== STATUS_REMOVE);\n\n    // Update `STATUS_ADD` to `STATUS_KEEP`\n    list.forEach(node => {\n      if (node.key === matchKey) {\n        // eslint-disable-next-line no-param-reassign\n        node.status = STATUS_KEEP;\n      }\n    });\n  });\n  return list;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}