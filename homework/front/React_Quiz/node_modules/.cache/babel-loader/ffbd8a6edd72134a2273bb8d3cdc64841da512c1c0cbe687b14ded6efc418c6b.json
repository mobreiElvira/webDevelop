{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport warning from \"@rc-component/util/es/warning\";\nfunction getKey(data, index) {\n  const {\n    key\n  } = data;\n  let value;\n  if ('value' in data) {\n    ({\n      value\n    } = data);\n  }\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n  if (value !== undefined) {\n    return value;\n  }\n  return \"rc-index-key-\".concat(index);\n}\nexport function isValidCount(value) {\n  return typeof value !== 'undefined' && !Number.isNaN(value);\n}\nexport function fillFieldNames(fieldNames, childrenAsData) {\n  const {\n    label,\n    value,\n    options,\n    groupLabel\n  } = fieldNames || {};\n  const mergedLabel = label || (childrenAsData ? 'children' : 'label');\n  return {\n    label: mergedLabel,\n    value: value || 'value',\n    options: options || 'options',\n    groupLabel: groupLabel || mergedLabel\n  };\n}\n\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\nexport function flattenOptions(options) {\n  let {\n    fieldNames,\n    childrenAsData\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const flattenList = [];\n  const {\n    label: fieldLabel,\n    value: fieldValue,\n    options: fieldOptions,\n    groupLabel\n  } = fillFieldNames(fieldNames, false);\n  function dig(list, isGroupOption) {\n    if (!Array.isArray(list)) {\n      return;\n    }\n    list.forEach(data => {\n      if (isGroupOption || !(fieldOptions in data)) {\n        const value = data[fieldValue];\n\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data,\n          label: data[fieldLabel],\n          value\n        });\n      } else {\n        let grpLabel = data[groupLabel];\n        if (grpLabel === undefined && childrenAsData) {\n          grpLabel = data.label;\n        }\n\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data,\n          label: grpLabel\n        });\n        dig(data[fieldOptions], true);\n      }\n    });\n  }\n  dig(options, false);\n  return flattenList;\n}\n\n/**\n * Inject `props` into `option` for legacy usage\n */\nexport function injectPropsWithOption(option) {\n  const newOption = _objectSpread({}, option);\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n  return newOption;\n}\nexport const getSeparatedContent = (text, tokens, end) => {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n  let match = false;\n  const separate = (str, _ref) => {\n    let [token, ...restTokens] = _ref;\n    if (!token) {\n      return [str];\n    }\n    const list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(Boolean);\n  };\n  const list = separate(text, tokens);\n  if (match) {\n    return typeof end !== 'undefined' ? list.slice(0, end) : list;\n  } else {\n    return null;\n  }\n};","map":{"version":3,"names":["warning","getKey","data","index","key","value","undefined","concat","isValidCount","Number","isNaN","fillFieldNames","fieldNames","childrenAsData","label","options","groupLabel","mergedLabel","flattenOptions","arguments","length","flattenList","fieldLabel","fieldValue","fieldOptions","dig","list","isGroupOption","Array","isArray","forEach","push","groupOption","grpLabel","group","injectPropsWithOption","option","newOption","_objectSpread","Object","defineProperty","get","getSeparatedContent","text","tokens","end","match","separate","str","_ref","token","restTokens","split","reduce","prevList","unitStr","filter","Boolean","slice"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/select/es/utils/valueUtil.js"],"sourcesContent":["import warning from \"@rc-component/util/es/warning\";\nfunction getKey(data, index) {\n  const {\n    key\n  } = data;\n  let value;\n  if ('value' in data) {\n    ({\n      value\n    } = data);\n  }\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n  if (value !== undefined) {\n    return value;\n  }\n  return `rc-index-key-${index}`;\n}\nexport function isValidCount(value) {\n  return typeof value !== 'undefined' && !Number.isNaN(value);\n}\nexport function fillFieldNames(fieldNames, childrenAsData) {\n  const {\n    label,\n    value,\n    options,\n    groupLabel\n  } = fieldNames || {};\n  const mergedLabel = label || (childrenAsData ? 'children' : 'label');\n  return {\n    label: mergedLabel,\n    value: value || 'value',\n    options: options || 'options',\n    groupLabel: groupLabel || mergedLabel\n  };\n}\n\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\nexport function flattenOptions(options, {\n  fieldNames,\n  childrenAsData\n} = {}) {\n  const flattenList = [];\n  const {\n    label: fieldLabel,\n    value: fieldValue,\n    options: fieldOptions,\n    groupLabel\n  } = fillFieldNames(fieldNames, false);\n  function dig(list, isGroupOption) {\n    if (!Array.isArray(list)) {\n      return;\n    }\n    list.forEach(data => {\n      if (isGroupOption || !(fieldOptions in data)) {\n        const value = data[fieldValue];\n\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data,\n          label: data[fieldLabel],\n          value\n        });\n      } else {\n        let grpLabel = data[groupLabel];\n        if (grpLabel === undefined && childrenAsData) {\n          grpLabel = data.label;\n        }\n\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data,\n          label: grpLabel\n        });\n        dig(data[fieldOptions], true);\n      }\n    });\n  }\n  dig(options, false);\n  return flattenList;\n}\n\n/**\n * Inject `props` into `option` for legacy usage\n */\nexport function injectPropsWithOption(option) {\n  const newOption = {\n    ...option\n  };\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n  return newOption;\n}\nexport const getSeparatedContent = (text, tokens, end) => {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n  let match = false;\n  const separate = (str, [token, ...restTokens]) => {\n    if (!token) {\n      return [str];\n    }\n    const list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(Boolean);\n  };\n  const list = separate(text, tokens);\n  if (match) {\n    return typeof end !== 'undefined' ? list.slice(0, end) : list;\n  } else {\n    return null;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}