{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"mode\", \"prefixCls\", \"className\", \"style\", \"classNames\", \"styles\", \"min\", \"max\", \"step\", \"defaultValue\", \"value\", \"disabled\", \"readOnly\", \"upHandler\", \"downHandler\", \"keyboard\", \"changeOnWheel\", \"controls\", \"prefix\", \"suffix\", \"stringMode\", \"parser\", \"formatter\", \"precision\", \"decimalSeparator\", \"onChange\", \"onInput\", \"onPressEnter\", \"onStep\", \"onMouseDown\", \"onClick\", \"onMouseUp\", \"onMouseLeave\", \"onMouseMove\", \"onMouseEnter\", \"onMouseOut\", \"changeOnBlur\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport getMiniDecimal, { getNumberPrecision, num2str, toFixed, validateNumber } from '@rc-component/mini-decimal';\nimport { useLayoutUpdateEffect } from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport proxyObject from \"@rc-component/util/es/proxyObject\";\nimport { clsx } from 'clsx';\nimport * as React from 'react';\nimport useCursor from \"./hooks/useCursor\";\nimport StepHandler from \"./StepHandler\";\nimport { getDecupleSteps } from \"./utils/numberUtil\";\nimport { useEvent } from '@rc-component/util';\nimport { triggerFocus } from \"@rc-component/util/es/Dom/focus\";\nimport useFrame from \"./hooks/useFrame\";\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\nconst getDecimalValue = (stringMode, decimalValue) => {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n  return decimalValue.toNumber();\n};\nconst getDecimalIfValidate = value => {\n  const decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\nconst InputNumber = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n      mode = 'input',\n      prefixCls = 'rc-input-number',\n      className,\n      style,\n      classNames,\n      styles,\n      min,\n      max,\n      step = 1,\n      defaultValue,\n      value,\n      disabled,\n      readOnly,\n      upHandler,\n      downHandler,\n      keyboard,\n      changeOnWheel = false,\n      controls = true,\n      prefix,\n      suffix,\n      stringMode,\n      parser,\n      formatter,\n      precision,\n      decimalSeparator,\n      onChange,\n      onInput,\n      onPressEnter,\n      onStep,\n      // Mouse Events\n      onMouseDown,\n      onClick,\n      onMouseUp,\n      onMouseLeave,\n      onMouseMove,\n      onMouseEnter,\n      onMouseOut,\n      changeOnBlur = true\n    } = props,\n    restProps = _objectWithoutProperties(props, _excluded);\n  const [focus, setFocus] = React.useState(false);\n  const userTypingRef = React.useRef(false);\n  const compositionRef = React.useRef(false);\n  const shiftKeyRef = React.useRef(false);\n\n  // ============================= Refs =============================\n  const rootRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => proxyObject(inputRef.current, {\n    focus: option => {\n      triggerFocus(inputRef.current, option);\n    },\n    blur: () => {\n      var _inputRef$current;\n      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();\n    },\n    nativeElement: rootRef.current\n  }));\n\n  // ============================ Value =============================\n  // Real value control\n  const [decimalValue, setDecimalValue] = React.useState(() => getMiniDecimal(value !== null && value !== void 0 ? value : defaultValue));\n  function setUncontrolledDecimalValue(newDecimal) {\n    if (value === undefined) {\n      setDecimalValue(newDecimal);\n    }\n  }\n\n  // ====================== Parser & Formatter ======================\n  /**\n   * `precision` is used for formatter & onChange.\n   * It will auto generate by `value` & `step`.\n   * But it will not block user typing.\n   *\n   * Note: Auto generate `precision` is used for legacy logic.\n   * We should remove this since we already support high precision with BigInt.\n   *\n   * @param number  Provide which number should calculate precision\n   * @param userTyping  Change by user typing\n   */\n  const getPrecision = React.useCallback((numStr, userTyping) => {\n    if (userTyping) {\n      return undefined;\n    }\n    if (precision >= 0) {\n      return precision;\n    }\n    return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));\n  }, [precision, step]);\n\n  // >>> Parser\n  const mergedParser = React.useCallback(num => {\n    const numStr = String(num);\n    if (parser) {\n      return parser(numStr);\n    }\n    let parsedStr = numStr;\n    if (decimalSeparator) {\n      parsedStr = parsedStr.replace(decimalSeparator, '.');\n    }\n\n    // [Legacy] We still support auto convert `$ 123,456` to `123456`\n    return parsedStr.replace(/[^\\w.-]+/g, '');\n  }, [parser, decimalSeparator]);\n\n  // >>> Formatter\n  const inputValueRef = React.useRef('');\n  const mergedFormatter = React.useCallback((number, userTyping) => {\n    if (formatter) {\n      return formatter(number, {\n        userTyping,\n        input: String(inputValueRef.current)\n      });\n    }\n    let str = typeof number === 'number' ? num2str(number) : number;\n\n    // User typing will not auto format with precision directly\n    if (!userTyping) {\n      const mergedPrecision = getPrecision(str, userTyping);\n      if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {\n        // Separator\n        const separatorStr = decimalSeparator || '.';\n        str = toFixed(str, separatorStr, mergedPrecision);\n      }\n    }\n    return str;\n  }, [formatter, getPrecision, decimalSeparator]);\n\n  // ========================== InputValue ==========================\n  /**\n   * Input text value control\n   *\n   * User can not update input content directly. It updates with follow rules by priority:\n   *  1. controlled `value` changed\n   *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n   *  2. User typing with format (not precision)\n   *  3. Blur or Enter trigger revalidate\n   */\n  const [inputValue, setInternalInputValue] = React.useState(() => {\n    const initValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : value;\n    if (decimalValue.isInvalidate() && ['string', 'number'].includes(typeof initValue)) {\n      return Number.isNaN(initValue) ? '' : initValue;\n    }\n    return mergedFormatter(decimalValue.toString(), false);\n  });\n  inputValueRef.current = inputValue;\n\n  // Should always be string\n  function setInputValue(newValue, userTyping) {\n    setInternalInputValue(mergedFormatter(\n    // Invalidate number is sometime passed by external control, we should let it go\n    // Otherwise is controlled by internal interactive logic which check by userTyping\n    // You can ref 'show limited value when input is not focused' test for more info.\n    newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping));\n  }\n\n  // >>> Max & Min limit\n  const maxDecimal = React.useMemo(() => getDecimalIfValidate(max), [max, precision]);\n  const minDecimal = React.useMemo(() => getDecimalIfValidate(min), [min, precision]);\n  const upDisabled = React.useMemo(() => {\n    if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {\n      return false;\n    }\n    return maxDecimal.lessEquals(decimalValue);\n  }, [maxDecimal, decimalValue]);\n  const downDisabled = React.useMemo(() => {\n    if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {\n      return false;\n    }\n    return decimalValue.lessEquals(minDecimal);\n  }, [minDecimal, decimalValue]);\n\n  // Cursor controller\n  const [recordCursor, restoreCursor] = useCursor(inputRef.current, focus);\n\n  // ============================= Data =============================\n  /**\n   * Find target value closet within range.\n   * e.g. [11, 28]:\n   *    3  => 11\n   *    23 => 23\n   *    99 => 28\n   */\n  const getRangeValue = target => {\n    // target > max\n    if (maxDecimal && !target.lessEquals(maxDecimal)) {\n      return maxDecimal;\n    }\n\n    // target < min\n    if (minDecimal && !minDecimal.lessEquals(target)) {\n      return minDecimal;\n    }\n    return null;\n  };\n\n  /**\n   * Check value is in [min, max] range\n   */\n  const isInRange = target => !getRangeValue(target);\n\n  /**\n   * Trigger `onChange` if value validated and not equals of origin.\n   * Return the value that re-align in range.\n   */\n  const triggerValueUpdate = (newValue, userTyping) => {\n    let updateValue = newValue;\n    let isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();\n\n    // Skip align value when trigger value is empty.\n    // We just trigger onChange(null)\n    // This should not block user typing\n    if (!updateValue.isEmpty() && !userTyping) {\n      // Revert value in range if needed\n      updateValue = getRangeValue(updateValue) || updateValue;\n      isRangeValidate = true;\n    }\n    if (!readOnly && !disabled && isRangeValidate) {\n      const numStr = updateValue.toString();\n      const mergedPrecision = getPrecision(numStr, userTyping);\n      if (mergedPrecision >= 0) {\n        updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n\n        // When to fixed. The value may out of min & max range.\n        // 4 in [0, 3.8] => 3.8 => 4 (toFixed)\n        if (!isInRange(updateValue)) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision, true));\n        }\n      }\n\n      // Trigger event\n      if (!updateValue.equals(decimalValue)) {\n        setUncontrolledDecimalValue(updateValue);\n        onChange === null || onChange === void 0 || onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));\n\n        // Reformat input if value is not controlled\n        if (value === undefined) {\n          setInputValue(updateValue, userTyping);\n        }\n      }\n      return updateValue;\n    }\n    return decimalValue;\n  };\n\n  // ========================== User Input ==========================\n  const onNextPromise = useFrame();\n\n  // >>> Collect input value\n  const collectInputValue = inputStr => {\n    recordCursor();\n\n    // Update inputValue in case input can not parse as number\n    // Refresh ref value immediately since it may used by formatter\n    inputValueRef.current = inputStr;\n    setInternalInputValue(inputStr);\n\n    // Parse number\n    if (!compositionRef.current) {\n      const finalValue = mergedParser(inputStr);\n      const finalDecimal = getMiniDecimal(finalValue);\n      if (!finalDecimal.isNaN()) {\n        triggerValueUpdate(finalDecimal, true);\n      }\n    }\n\n    // Trigger onInput later to let user customize value if they want to handle something after onChange\n    onInput === null || onInput === void 0 || onInput(inputStr);\n\n    // optimize for chinese input experience\n    // https://github.com/ant-design/ant-design/issues/8196\n    onNextPromise(() => {\n      let nextInputStr = inputStr;\n      if (!parser) {\n        nextInputStr = inputStr.replace(/。/g, '.');\n      }\n      if (nextInputStr !== inputStr) {\n        collectInputValue(nextInputStr);\n      }\n    });\n  };\n\n  // >>> Composition\n  const onCompositionStart = () => {\n    compositionRef.current = true;\n  };\n  const onCompositionEnd = () => {\n    compositionRef.current = false;\n    collectInputValue(inputRef.current.value);\n  };\n\n  // >>> Input\n  const onInternalInput = e => {\n    collectInputValue(e.target.value);\n  };\n\n  // ============================= Step =============================\n  const onInternalStep = useEvent((up, emitter) => {\n    var _inputRef$current2;\n    // Ignore step since out of range\n    if (up && upDisabled || !up && downDisabled) {\n      return;\n    }\n\n    // Clear typing status since it may be caused by up & down key.\n    // We should sync with input value.\n    userTypingRef.current = false;\n    let stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);\n    if (!up) {\n      stepDecimal = stepDecimal.negate();\n    }\n    const target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString());\n    const updatedValue = triggerValueUpdate(target, false);\n    onStep === null || onStep === void 0 || onStep(getDecimalValue(stringMode, updatedValue), {\n      offset: shiftKeyRef.current ? getDecupleSteps(step) : step,\n      type: up ? 'up' : 'down',\n      emitter\n    });\n    (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.focus();\n  });\n\n  // ============================ Flush =============================\n  /**\n   * Flush current input content to trigger value change & re-formatter input if needed.\n   * This will always flush input value for update.\n   * If it's invalidate, will fallback to last validate value.\n   */\n  const flushInputValue = userTyping => {\n    const parsedValue = getMiniDecimal(mergedParser(inputValue));\n    let formatValue;\n    if (!parsedValue.isNaN()) {\n      // Only validate value or empty value can be re-fill to inputValue\n      // Reassign the formatValue within ranged of trigger control\n      formatValue = triggerValueUpdate(parsedValue, userTyping);\n    } else {\n      formatValue = triggerValueUpdate(decimalValue, userTyping);\n    }\n    if (value !== undefined) {\n      // Reset back with controlled value first\n      setInputValue(decimalValue, false);\n    } else if (!formatValue.isNaN()) {\n      // Reset input back since no validate value\n      setInputValue(formatValue, false);\n    }\n  };\n\n  // Solve the issue of the event triggering sequence when entering numbers in chinese input (Safari)\n  const onBeforeInput = () => {\n    userTypingRef.current = true;\n  };\n  const onKeyDown = event => {\n    const {\n      key,\n      shiftKey\n    } = event;\n    userTypingRef.current = true;\n    shiftKeyRef.current = shiftKey;\n    if (key === 'Enter') {\n      if (!compositionRef.current) {\n        userTypingRef.current = false;\n      }\n      flushInputValue(false);\n      onPressEnter === null || onPressEnter === void 0 || onPressEnter(event);\n    }\n    if (keyboard === false) {\n      return;\n    }\n\n    // Do step\n    if (!compositionRef.current && ['Up', 'ArrowUp', 'Down', 'ArrowDown'].includes(key)) {\n      onInternalStep(key === 'Up' || key === 'ArrowUp', 'keyboard');\n      event.preventDefault();\n    }\n  };\n  const onKeyUp = () => {\n    userTypingRef.current = false;\n    shiftKeyRef.current = false;\n  };\n  React.useEffect(() => {\n    if (changeOnWheel && focus) {\n      const onWheel = event => {\n        // moving mouse wheel rises wheel event with deltaY < 0\n        // scroll value grows from top to bottom, as screen Y coordinate\n        onInternalStep(event.deltaY < 0, 'wheel');\n        event.preventDefault();\n      };\n      const input = inputRef.current;\n      if (input) {\n        // React onWheel is passive and we can't preventDefault() in it.\n        // That's why we should subscribe with DOM listener\n        // https://stackoverflow.com/questions/63663025/react-onwheel-handler-cant-preventdefault-because-its-a-passive-event-listenev\n        input.addEventListener('wheel', onWheel, {\n          passive: false\n        });\n        return () => input.removeEventListener('wheel', onWheel);\n      }\n    }\n  });\n\n  // >>> Focus & Blur\n  const onBlur = () => {\n    if (changeOnBlur) {\n      flushInputValue(false);\n    }\n    setFocus(false);\n    userTypingRef.current = false;\n  };\n\n  // >>> Mouse events\n  const onInternalMouseDown = event => {\n    if (inputRef.current && event.target !== inputRef.current) {\n      inputRef.current.focus();\n      event.preventDefault();\n    }\n    onMouseDown === null || onMouseDown === void 0 || onMouseDown(event);\n  };\n\n  // ========================== Controlled ==========================\n  // Input by precision & formatter\n  useLayoutUpdateEffect(() => {\n    if (!decimalValue.isInvalidate()) {\n      setInputValue(decimalValue, false);\n    }\n  }, [precision, formatter]);\n\n  // Input by value\n  useLayoutUpdateEffect(() => {\n    const newValue = getMiniDecimal(value);\n    setDecimalValue(newValue);\n    const currentParsedValue = getMiniDecimal(mergedParser(inputValue));\n\n    // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n    // But let it go if user set `formatter`\n    if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {\n      // Update value as effect\n      setInputValue(newValue, userTypingRef.current);\n    }\n  }, [value]);\n\n  // ============================ Cursor ============================\n  useLayoutUpdateEffect(() => {\n    if (formatter) {\n      restoreCursor();\n    }\n  }, [inputValue]);\n\n  // ============================ Render ============================\n  // >>>>>> Handler\n  const sharedHandlerProps = {\n    prefixCls,\n    onStep: onInternalStep,\n    className: classNames === null || classNames === void 0 ? void 0 : classNames.action,\n    style: styles === null || styles === void 0 ? void 0 : styles.action\n  };\n  const upNode = /*#__PURE__*/React.createElement(StepHandler, _extends({}, sharedHandlerProps, {\n    action: \"up\",\n    disabled: upDisabled\n  }), upHandler);\n  const downNode = /*#__PURE__*/React.createElement(StepHandler, _extends({}, sharedHandlerProps, {\n    action: \"down\",\n    disabled: downDisabled\n  }), downHandler);\n\n  // >>>>>> Render\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: rootRef,\n    className: clsx(prefixCls, \"\".concat(prefixCls, \"-mode-\").concat(mode), className, classNames === null || classNames === void 0 ? void 0 : classNames.root, {\n      [\"\".concat(prefixCls, \"-focused\")]: focus,\n      [\"\".concat(prefixCls, \"-disabled\")]: disabled,\n      [\"\".concat(prefixCls, \"-readonly\")]: readOnly,\n      [\"\".concat(prefixCls, \"-not-a-number\")]: decimalValue.isNaN(),\n      [\"\".concat(prefixCls, \"-out-of-range\")]: !decimalValue.isInvalidate() && !isInRange(decimalValue)\n    }),\n    style: _objectSpread(_objectSpread({}, styles === null || styles === void 0 ? void 0 : styles.root), style),\n    onMouseDown: onInternalMouseDown,\n    onMouseUp: onMouseUp,\n    onMouseLeave: onMouseLeave,\n    onMouseMove: onMouseMove,\n    onMouseEnter: onMouseEnter,\n    onMouseOut: onMouseOut,\n    onClick: onClick,\n    onFocus: () => {\n      setFocus(true);\n    },\n    onBlur: onBlur,\n    onKeyDown: onKeyDown,\n    onKeyUp: onKeyUp,\n    onCompositionStart: onCompositionStart,\n    onCompositionEnd: onCompositionEnd,\n    onBeforeInput: onBeforeInput\n  }, mode === 'spinner' && controls && downNode, prefix !== undefined && /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(\"\".concat(prefixCls, \"-prefix\"), classNames === null || classNames === void 0 ? void 0 : classNames.prefix),\n    style: styles === null || styles === void 0 ? void 0 : styles.prefix\n  }, prefix), /*#__PURE__*/React.createElement(\"input\", _extends({\n    autoComplete: \"off\",\n    role: \"spinbutton\",\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-valuenow\": decimalValue.isInvalidate() ? null : decimalValue.toString(),\n    step: step,\n    ref: inputRef,\n    className: clsx(\"\".concat(prefixCls, \"-input\"), classNames === null || classNames === void 0 ? void 0 : classNames.input),\n    style: styles === null || styles === void 0 ? void 0 : styles.input,\n    value: inputValue,\n    onChange: onInternalInput,\n    disabled: disabled,\n    readOnly: readOnly\n  }, restProps)), suffix !== undefined && /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(\"\".concat(prefixCls, \"-suffix\"), classNames === null || classNames === void 0 ? void 0 : classNames.suffix),\n    style: styles === null || styles === void 0 ? void 0 : styles.suffix\n  }, suffix), mode === 'spinner' && controls && upNode, mode === 'input' && controls && /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(\"\".concat(prefixCls, \"-actions\"), classNames === null || classNames === void 0 ? void 0 : classNames.actions),\n    style: styles === null || styles === void 0 ? void 0 : styles.actions\n  }, upNode, downNode));\n});\nif (process.env.NODE_ENV !== 'production') {\n  InputNumber.displayName = 'InputNumber';\n}\nexport default InputNumber;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","getMiniDecimal","getNumberPrecision","num2str","toFixed","validateNumber","useLayoutUpdateEffect","proxyObject","clsx","React","useCursor","StepHandler","getDecupleSteps","useEvent","triggerFocus","useFrame","getDecimalValue","stringMode","decimalValue","isEmpty","toString","toNumber","getDecimalIfValidate","value","decimal","isInvalidate","InputNumber","forwardRef","props","ref","mode","prefixCls","className","style","classNames","styles","min","max","step","defaultValue","disabled","readOnly","upHandler","downHandler","keyboard","changeOnWheel","controls","prefix","suffix","parser","formatter","precision","decimalSeparator","onChange","onInput","onPressEnter","onStep","onMouseDown","onClick","onMouseUp","onMouseLeave","onMouseMove","onMouseEnter","onMouseOut","changeOnBlur","restProps","_objectWithoutProperties","_excluded","focus","setFocus","useState","userTypingRef","useRef","compositionRef","shiftKeyRef","rootRef","inputRef","useImperativeHandle","current","option","blur","_inputRef$current","nativeElement","setDecimalValue","setUncontrolledDecimalValue","newDecimal","undefined","getPrecision","useCallback","numStr","userTyping","Math","mergedParser","num","String","parsedStr","replace","inputValueRef","mergedFormatter","number","input","str","mergedPrecision","separatorStr","inputValue","setInternalInputValue","initValue","includes","Number","isNaN","setInputValue","newValue","maxDecimal","useMemo","minDecimal","upDisabled","lessEquals","downDisabled","recordCursor","restoreCursor","getRangeValue","isInRange","triggerValueUpdate","updateValue","isRangeValidate","equals","onNextPromise","collectInputValue","inputStr","finalValue","finalDecimal","nextInputStr","onCompositionStart","onCompositionEnd","onInternalInput","e","onInternalStep","up","emitter","_inputRef$current2","stepDecimal","negate","add","updatedValue","offset","type","flushInputValue","parsedValue","formatValue","onBeforeInput","onKeyDown","event","shiftKey","preventDefault","onKeyUp","useEffect","onWheel","deltaY","addEventListener","passive","removeEventListener","onBlur","onInternalMouseDown","currentParsedValue","sharedHandlerProps","action","upNode","createElement","downNode","concat","root","_objectSpread","onFocus","autoComplete","role","actions","process","env","NODE_ENV","displayName"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/input-number/es/InputNumber.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport getMiniDecimal, { getNumberPrecision, num2str, toFixed, validateNumber } from '@rc-component/mini-decimal';\nimport { useLayoutUpdateEffect } from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport proxyObject from \"@rc-component/util/es/proxyObject\";\nimport { clsx } from 'clsx';\nimport * as React from 'react';\nimport useCursor from \"./hooks/useCursor\";\nimport StepHandler from \"./StepHandler\";\nimport { getDecupleSteps } from \"./utils/numberUtil\";\nimport { useEvent } from '@rc-component/util';\nimport { triggerFocus } from \"@rc-component/util/es/Dom/focus\";\nimport useFrame from \"./hooks/useFrame\";\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\nconst getDecimalValue = (stringMode, decimalValue) => {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n  return decimalValue.toNumber();\n};\nconst getDecimalIfValidate = value => {\n  const decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\nconst InputNumber = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    mode = 'input',\n    prefixCls = 'rc-input-number',\n    className,\n    style,\n    classNames,\n    styles,\n    min,\n    max,\n    step = 1,\n    defaultValue,\n    value,\n    disabled,\n    readOnly,\n    upHandler,\n    downHandler,\n    keyboard,\n    changeOnWheel = false,\n    controls = true,\n    prefix,\n    suffix,\n    stringMode,\n    parser,\n    formatter,\n    precision,\n    decimalSeparator,\n    onChange,\n    onInput,\n    onPressEnter,\n    onStep,\n    // Mouse Events\n    onMouseDown,\n    onClick,\n    onMouseUp,\n    onMouseLeave,\n    onMouseMove,\n    onMouseEnter,\n    onMouseOut,\n    changeOnBlur = true,\n    ...restProps\n  } = props;\n  const [focus, setFocus] = React.useState(false);\n  const userTypingRef = React.useRef(false);\n  const compositionRef = React.useRef(false);\n  const shiftKeyRef = React.useRef(false);\n\n  // ============================= Refs =============================\n  const rootRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => proxyObject(inputRef.current, {\n    focus: option => {\n      triggerFocus(inputRef.current, option);\n    },\n    blur: () => {\n      inputRef.current?.blur();\n    },\n    nativeElement: rootRef.current\n  }));\n\n  // ============================ Value =============================\n  // Real value control\n  const [decimalValue, setDecimalValue] = React.useState(() => getMiniDecimal(value ?? defaultValue));\n  function setUncontrolledDecimalValue(newDecimal) {\n    if (value === undefined) {\n      setDecimalValue(newDecimal);\n    }\n  }\n\n  // ====================== Parser & Formatter ======================\n  /**\n   * `precision` is used for formatter & onChange.\n   * It will auto generate by `value` & `step`.\n   * But it will not block user typing.\n   *\n   * Note: Auto generate `precision` is used for legacy logic.\n   * We should remove this since we already support high precision with BigInt.\n   *\n   * @param number  Provide which number should calculate precision\n   * @param userTyping  Change by user typing\n   */\n  const getPrecision = React.useCallback((numStr, userTyping) => {\n    if (userTyping) {\n      return undefined;\n    }\n    if (precision >= 0) {\n      return precision;\n    }\n    return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));\n  }, [precision, step]);\n\n  // >>> Parser\n  const mergedParser = React.useCallback(num => {\n    const numStr = String(num);\n    if (parser) {\n      return parser(numStr);\n    }\n    let parsedStr = numStr;\n    if (decimalSeparator) {\n      parsedStr = parsedStr.replace(decimalSeparator, '.');\n    }\n\n    // [Legacy] We still support auto convert `$ 123,456` to `123456`\n    return parsedStr.replace(/[^\\w.-]+/g, '');\n  }, [parser, decimalSeparator]);\n\n  // >>> Formatter\n  const inputValueRef = React.useRef('');\n  const mergedFormatter = React.useCallback((number, userTyping) => {\n    if (formatter) {\n      return formatter(number, {\n        userTyping,\n        input: String(inputValueRef.current)\n      });\n    }\n    let str = typeof number === 'number' ? num2str(number) : number;\n\n    // User typing will not auto format with precision directly\n    if (!userTyping) {\n      const mergedPrecision = getPrecision(str, userTyping);\n      if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {\n        // Separator\n        const separatorStr = decimalSeparator || '.';\n        str = toFixed(str, separatorStr, mergedPrecision);\n      }\n    }\n    return str;\n  }, [formatter, getPrecision, decimalSeparator]);\n\n  // ========================== InputValue ==========================\n  /**\n   * Input text value control\n   *\n   * User can not update input content directly. It updates with follow rules by priority:\n   *  1. controlled `value` changed\n   *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n   *  2. User typing with format (not precision)\n   *  3. Blur or Enter trigger revalidate\n   */\n  const [inputValue, setInternalInputValue] = React.useState(() => {\n    const initValue = defaultValue ?? value;\n    if (decimalValue.isInvalidate() && ['string', 'number'].includes(typeof initValue)) {\n      return Number.isNaN(initValue) ? '' : initValue;\n    }\n    return mergedFormatter(decimalValue.toString(), false);\n  });\n  inputValueRef.current = inputValue;\n\n  // Should always be string\n  function setInputValue(newValue, userTyping) {\n    setInternalInputValue(mergedFormatter(\n    // Invalidate number is sometime passed by external control, we should let it go\n    // Otherwise is controlled by internal interactive logic which check by userTyping\n    // You can ref 'show limited value when input is not focused' test for more info.\n    newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping));\n  }\n\n  // >>> Max & Min limit\n  const maxDecimal = React.useMemo(() => getDecimalIfValidate(max), [max, precision]);\n  const minDecimal = React.useMemo(() => getDecimalIfValidate(min), [min, precision]);\n  const upDisabled = React.useMemo(() => {\n    if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {\n      return false;\n    }\n    return maxDecimal.lessEquals(decimalValue);\n  }, [maxDecimal, decimalValue]);\n  const downDisabled = React.useMemo(() => {\n    if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {\n      return false;\n    }\n    return decimalValue.lessEquals(minDecimal);\n  }, [minDecimal, decimalValue]);\n\n  // Cursor controller\n  const [recordCursor, restoreCursor] = useCursor(inputRef.current, focus);\n\n  // ============================= Data =============================\n  /**\n   * Find target value closet within range.\n   * e.g. [11, 28]:\n   *    3  => 11\n   *    23 => 23\n   *    99 => 28\n   */\n  const getRangeValue = target => {\n    // target > max\n    if (maxDecimal && !target.lessEquals(maxDecimal)) {\n      return maxDecimal;\n    }\n\n    // target < min\n    if (minDecimal && !minDecimal.lessEquals(target)) {\n      return minDecimal;\n    }\n    return null;\n  };\n\n  /**\n   * Check value is in [min, max] range\n   */\n  const isInRange = target => !getRangeValue(target);\n\n  /**\n   * Trigger `onChange` if value validated and not equals of origin.\n   * Return the value that re-align in range.\n   */\n  const triggerValueUpdate = (newValue, userTyping) => {\n    let updateValue = newValue;\n    let isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();\n\n    // Skip align value when trigger value is empty.\n    // We just trigger onChange(null)\n    // This should not block user typing\n    if (!updateValue.isEmpty() && !userTyping) {\n      // Revert value in range if needed\n      updateValue = getRangeValue(updateValue) || updateValue;\n      isRangeValidate = true;\n    }\n    if (!readOnly && !disabled && isRangeValidate) {\n      const numStr = updateValue.toString();\n      const mergedPrecision = getPrecision(numStr, userTyping);\n      if (mergedPrecision >= 0) {\n        updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n\n        // When to fixed. The value may out of min & max range.\n        // 4 in [0, 3.8] => 3.8 => 4 (toFixed)\n        if (!isInRange(updateValue)) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision, true));\n        }\n      }\n\n      // Trigger event\n      if (!updateValue.equals(decimalValue)) {\n        setUncontrolledDecimalValue(updateValue);\n        onChange?.(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));\n\n        // Reformat input if value is not controlled\n        if (value === undefined) {\n          setInputValue(updateValue, userTyping);\n        }\n      }\n      return updateValue;\n    }\n    return decimalValue;\n  };\n\n  // ========================== User Input ==========================\n  const onNextPromise = useFrame();\n\n  // >>> Collect input value\n  const collectInputValue = inputStr => {\n    recordCursor();\n\n    // Update inputValue in case input can not parse as number\n    // Refresh ref value immediately since it may used by formatter\n    inputValueRef.current = inputStr;\n    setInternalInputValue(inputStr);\n\n    // Parse number\n    if (!compositionRef.current) {\n      const finalValue = mergedParser(inputStr);\n      const finalDecimal = getMiniDecimal(finalValue);\n      if (!finalDecimal.isNaN()) {\n        triggerValueUpdate(finalDecimal, true);\n      }\n    }\n\n    // Trigger onInput later to let user customize value if they want to handle something after onChange\n    onInput?.(inputStr);\n\n    // optimize for chinese input experience\n    // https://github.com/ant-design/ant-design/issues/8196\n    onNextPromise(() => {\n      let nextInputStr = inputStr;\n      if (!parser) {\n        nextInputStr = inputStr.replace(/。/g, '.');\n      }\n      if (nextInputStr !== inputStr) {\n        collectInputValue(nextInputStr);\n      }\n    });\n  };\n\n  // >>> Composition\n  const onCompositionStart = () => {\n    compositionRef.current = true;\n  };\n  const onCompositionEnd = () => {\n    compositionRef.current = false;\n    collectInputValue(inputRef.current.value);\n  };\n\n  // >>> Input\n  const onInternalInput = e => {\n    collectInputValue(e.target.value);\n  };\n\n  // ============================= Step =============================\n  const onInternalStep = useEvent((up, emitter) => {\n    // Ignore step since out of range\n    if (up && upDisabled || !up && downDisabled) {\n      return;\n    }\n\n    // Clear typing status since it may be caused by up & down key.\n    // We should sync with input value.\n    userTypingRef.current = false;\n    let stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);\n    if (!up) {\n      stepDecimal = stepDecimal.negate();\n    }\n    const target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString());\n    const updatedValue = triggerValueUpdate(target, false);\n    onStep?.(getDecimalValue(stringMode, updatedValue), {\n      offset: shiftKeyRef.current ? getDecupleSteps(step) : step,\n      type: up ? 'up' : 'down',\n      emitter\n    });\n    inputRef.current?.focus();\n  });\n\n  // ============================ Flush =============================\n  /**\n   * Flush current input content to trigger value change & re-formatter input if needed.\n   * This will always flush input value for update.\n   * If it's invalidate, will fallback to last validate value.\n   */\n  const flushInputValue = userTyping => {\n    const parsedValue = getMiniDecimal(mergedParser(inputValue));\n    let formatValue;\n    if (!parsedValue.isNaN()) {\n      // Only validate value or empty value can be re-fill to inputValue\n      // Reassign the formatValue within ranged of trigger control\n      formatValue = triggerValueUpdate(parsedValue, userTyping);\n    } else {\n      formatValue = triggerValueUpdate(decimalValue, userTyping);\n    }\n    if (value !== undefined) {\n      // Reset back with controlled value first\n      setInputValue(decimalValue, false);\n    } else if (!formatValue.isNaN()) {\n      // Reset input back since no validate value\n      setInputValue(formatValue, false);\n    }\n  };\n\n  // Solve the issue of the event triggering sequence when entering numbers in chinese input (Safari)\n  const onBeforeInput = () => {\n    userTypingRef.current = true;\n  };\n  const onKeyDown = event => {\n    const {\n      key,\n      shiftKey\n    } = event;\n    userTypingRef.current = true;\n    shiftKeyRef.current = shiftKey;\n    if (key === 'Enter') {\n      if (!compositionRef.current) {\n        userTypingRef.current = false;\n      }\n      flushInputValue(false);\n      onPressEnter?.(event);\n    }\n    if (keyboard === false) {\n      return;\n    }\n\n    // Do step\n    if (!compositionRef.current && ['Up', 'ArrowUp', 'Down', 'ArrowDown'].includes(key)) {\n      onInternalStep(key === 'Up' || key === 'ArrowUp', 'keyboard');\n      event.preventDefault();\n    }\n  };\n  const onKeyUp = () => {\n    userTypingRef.current = false;\n    shiftKeyRef.current = false;\n  };\n  React.useEffect(() => {\n    if (changeOnWheel && focus) {\n      const onWheel = event => {\n        // moving mouse wheel rises wheel event with deltaY < 0\n        // scroll value grows from top to bottom, as screen Y coordinate\n        onInternalStep(event.deltaY < 0, 'wheel');\n        event.preventDefault();\n      };\n      const input = inputRef.current;\n      if (input) {\n        // React onWheel is passive and we can't preventDefault() in it.\n        // That's why we should subscribe with DOM listener\n        // https://stackoverflow.com/questions/63663025/react-onwheel-handler-cant-preventdefault-because-its-a-passive-event-listenev\n        input.addEventListener('wheel', onWheel, {\n          passive: false\n        });\n        return () => input.removeEventListener('wheel', onWheel);\n      }\n    }\n  });\n\n  // >>> Focus & Blur\n  const onBlur = () => {\n    if (changeOnBlur) {\n      flushInputValue(false);\n    }\n    setFocus(false);\n    userTypingRef.current = false;\n  };\n\n  // >>> Mouse events\n  const onInternalMouseDown = event => {\n    if (inputRef.current && event.target !== inputRef.current) {\n      inputRef.current.focus();\n      event.preventDefault();\n    }\n    onMouseDown?.(event);\n  };\n\n  // ========================== Controlled ==========================\n  // Input by precision & formatter\n  useLayoutUpdateEffect(() => {\n    if (!decimalValue.isInvalidate()) {\n      setInputValue(decimalValue, false);\n    }\n  }, [precision, formatter]);\n\n  // Input by value\n  useLayoutUpdateEffect(() => {\n    const newValue = getMiniDecimal(value);\n    setDecimalValue(newValue);\n    const currentParsedValue = getMiniDecimal(mergedParser(inputValue));\n\n    // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n    // But let it go if user set `formatter`\n    if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {\n      // Update value as effect\n      setInputValue(newValue, userTypingRef.current);\n    }\n  }, [value]);\n\n  // ============================ Cursor ============================\n  useLayoutUpdateEffect(() => {\n    if (formatter) {\n      restoreCursor();\n    }\n  }, [inputValue]);\n\n  // ============================ Render ============================\n  // >>>>>> Handler\n  const sharedHandlerProps = {\n    prefixCls,\n    onStep: onInternalStep,\n    className: classNames?.action,\n    style: styles?.action\n  };\n  const upNode = /*#__PURE__*/React.createElement(StepHandler, _extends({}, sharedHandlerProps, {\n    action: \"up\",\n    disabled: upDisabled\n  }), upHandler);\n  const downNode = /*#__PURE__*/React.createElement(StepHandler, _extends({}, sharedHandlerProps, {\n    action: \"down\",\n    disabled: downDisabled\n  }), downHandler);\n\n  // >>>>>> Render\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: rootRef,\n    className: clsx(prefixCls, `${prefixCls}-mode-${mode}`, className, classNames?.root, {\n      [`${prefixCls}-focused`]: focus,\n      [`${prefixCls}-disabled`]: disabled,\n      [`${prefixCls}-readonly`]: readOnly,\n      [`${prefixCls}-not-a-number`]: decimalValue.isNaN(),\n      [`${prefixCls}-out-of-range`]: !decimalValue.isInvalidate() && !isInRange(decimalValue)\n    }),\n    style: {\n      ...styles?.root,\n      ...style\n    },\n    onMouseDown: onInternalMouseDown,\n    onMouseUp: onMouseUp,\n    onMouseLeave: onMouseLeave,\n    onMouseMove: onMouseMove,\n    onMouseEnter: onMouseEnter,\n    onMouseOut: onMouseOut,\n    onClick: onClick,\n    onFocus: () => {\n      setFocus(true);\n    },\n    onBlur: onBlur,\n    onKeyDown: onKeyDown,\n    onKeyUp: onKeyUp,\n    onCompositionStart: onCompositionStart,\n    onCompositionEnd: onCompositionEnd,\n    onBeforeInput: onBeforeInput\n  }, mode === 'spinner' && controls && downNode, prefix !== undefined && /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(`${prefixCls}-prefix`, classNames?.prefix),\n    style: styles?.prefix\n  }, prefix), /*#__PURE__*/React.createElement(\"input\", _extends({\n    autoComplete: \"off\",\n    role: \"spinbutton\",\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-valuenow\": decimalValue.isInvalidate() ? null : decimalValue.toString(),\n    step: step,\n    ref: inputRef,\n    className: clsx(`${prefixCls}-input`, classNames?.input),\n    style: styles?.input,\n    value: inputValue,\n    onChange: onInternalInput,\n    disabled: disabled,\n    readOnly: readOnly\n  }, restProps)), suffix !== undefined && /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(`${prefixCls}-suffix`, classNames?.suffix),\n    style: styles?.suffix\n  }, suffix), mode === 'spinner' && controls && upNode, mode === 'input' && controls && /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(`${prefixCls}-actions`, classNames?.actions),\n    style: styles?.actions\n  }, upNode, downNode));\n});\nif (process.env.NODE_ENV !== 'production') {\n  InputNumber.displayName = 'InputNumber';\n}\nexport default InputNumber;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}