{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport { clsx } from 'clsx';\nimport * as React from 'react';\nimport Handles from \"./Handles\";\nimport Marks from \"./Marks\";\nimport Steps from \"./Steps\";\nimport Tracks from \"./Tracks\";\nimport SliderContext from \"./context\";\nimport useDrag from \"./hooks/useDrag\";\nimport useOffset from \"./hooks/useOffset\";\nimport useRange from \"./hooks/useRange\";\n\n/**\n * New:\n * - click mark to update range value\n * - handleRender\n * - Fix handle with count not correct\n * - Fix pushable not work in some case\n * - No more FindDOMNode\n * - Move all position related style into inline style\n * - Key: up is plus, down is minus\n * - fix Key with step = null not align with marks\n * - Change range should not trigger onChange\n * - keyboard support pushable\n */\n\nconst Slider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    prefixCls = 'rc-slider',\n    className,\n    style,\n    classNames,\n    styles,\n    id,\n    // Status\n    disabled = false,\n    keyboard = true,\n    autoFocus,\n    onFocus,\n    onBlur,\n    // Value\n    min = 0,\n    max = 100,\n    step = 1,\n    value,\n    defaultValue,\n    range,\n    count,\n    onChange,\n    onBeforeChange,\n    onAfterChange,\n    onChangeComplete,\n    // Cross\n    allowCross = true,\n    pushable = false,\n    // Direction\n    reverse,\n    vertical,\n    // Style\n    included = true,\n    startPoint,\n    trackStyle,\n    handleStyle,\n    railStyle,\n    dotStyle,\n    activeDotStyle,\n    // Decorations\n    marks,\n    dots,\n    // Components\n    handleRender,\n    activeHandleRender,\n    track,\n    // Accessibility\n    tabIndex = 0,\n    ariaLabelForHandle,\n    ariaLabelledByForHandle,\n    ariaRequired,\n    ariaValueTextFormatterForHandle\n  } = props;\n  const handlesRef = React.useRef(null);\n  const containerRef = React.useRef(null);\n  const direction = React.useMemo(() => {\n    if (vertical) {\n      return reverse ? 'ttb' : 'btt';\n    }\n    return reverse ? 'rtl' : 'ltr';\n  }, [reverse, vertical]);\n\n  // ============================ Range =============================\n  const [rangeEnabled, rangeEditable, rangeDraggableTrack, minCount, maxCount] = useRange(range);\n  const mergedMin = React.useMemo(() => isFinite(min) ? min : 0, [min]);\n  const mergedMax = React.useMemo(() => isFinite(max) ? max : 100, [max]);\n\n  // ============================= Step =============================\n  const mergedStep = React.useMemo(() => step !== null && step <= 0 ? 1 : step, [step]);\n\n  // ============================= Push =============================\n  const mergedPush = React.useMemo(() => {\n    if (typeof pushable === 'boolean') {\n      return pushable ? mergedStep : false;\n    }\n    return pushable >= 0 ? pushable : false;\n  }, [pushable, mergedStep]);\n\n  // ============================ Marks =============================\n  const markList = React.useMemo(() => {\n    return Object.keys(marks || {}).map(key => {\n      const mark = marks[key];\n      const markObj = {\n        value: Number(key)\n      };\n      if (mark && typeof mark === 'object' && ! /*#__PURE__*/React.isValidElement(mark) && ('label' in mark || 'style' in mark)) {\n        markObj.style = mark.style;\n        markObj.label = mark.label;\n      } else {\n        markObj.label = mark;\n      }\n      return markObj;\n    }).filter(_ref => {\n      let {\n        label\n      } = _ref;\n      return label || typeof label === 'number';\n    }).sort((a, b) => a.value - b.value);\n  }, [marks]);\n\n  // ============================ Format ============================\n  const [formatValue, offsetValues] = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush);\n\n  // ============================ Values ============================\n  const [mergedValue, setValue] = useControlledState(defaultValue, value);\n  const rawValues = React.useMemo(() => {\n    const valueList = mergedValue === null || mergedValue === undefined ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];\n    const [val0 = mergedMin] = valueList;\n    let returnValues = mergedValue === null ? [] : [val0];\n\n    // Format as range\n    if (rangeEnabled) {\n      returnValues = [...valueList];\n\n      // When count provided or value is `undefined`, we fill values\n      if (count || mergedValue === undefined) {\n        const pointCount = count >= 0 ? count + 1 : 2;\n        returnValues = returnValues.slice(0, pointCount);\n\n        // Fill with count\n        while (returnValues.length < pointCount) {\n          var _returnValues;\n          returnValues.push((_returnValues = returnValues[returnValues.length - 1]) !== null && _returnValues !== void 0 ? _returnValues : mergedMin);\n        }\n      }\n      returnValues.sort((a, b) => a - b);\n    }\n\n    // Align in range\n    returnValues.forEach((val, index) => {\n      returnValues[index] = formatValue(val);\n    });\n    return returnValues;\n  }, [mergedValue, rangeEnabled, mergedMin, count, formatValue]);\n\n  // =========================== onChange ===========================\n  const getTriggerValue = triggerValues => rangeEnabled ? triggerValues : triggerValues[0];\n  const triggerChange = useEvent(nextValues => {\n    // Order first\n    const cloneNextValues = [...nextValues].sort((a, b) => a - b);\n\n    // Trigger event if needed\n    if (onChange && !isEqual(cloneNextValues, rawValues, true)) {\n      onChange(getTriggerValue(cloneNextValues));\n    }\n\n    // We set this later since it will re-render component immediately\n    setValue(cloneNextValues);\n  });\n  const finishChange = useEvent(draggingDelete => {\n    // Trigger from `useDrag` will tell if it's a delete action\n    if (draggingDelete) {\n      handlesRef.current.hideHelp();\n    }\n    const finishValue = getTriggerValue(rawValues);\n    onAfterChange === null || onAfterChange === void 0 || onAfterChange(finishValue);\n    warning(!onAfterChange, '[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.');\n    onChangeComplete === null || onChangeComplete === void 0 || onChangeComplete(finishValue);\n  });\n  const onDelete = index => {\n    if (disabled || !rangeEditable || rawValues.length <= minCount) {\n      return;\n    }\n    const cloneNextValues = [...rawValues];\n    cloneNextValues.splice(index, 1);\n    onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(getTriggerValue(cloneNextValues));\n    triggerChange(cloneNextValues);\n    const nextFocusIndex = Math.max(0, index - 1);\n    handlesRef.current.hideHelp();\n    handlesRef.current.focus(nextFocusIndex);\n  };\n  const [draggingIndex, draggingValue, draggingDelete, cacheValues, onStartDrag] = useDrag(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue, triggerChange, finishChange, offsetValues, rangeEditable, minCount);\n\n  /**\n   * When `rangeEditable` will insert a new value in the values array.\n   * Else it will replace the value in the values array.\n   */\n  const changeToCloseValue = (newValue, e) => {\n    if (!disabled) {\n      // Create new values\n      const cloneNextValues = [...rawValues];\n      let valueIndex = 0;\n      let valueBeforeIndex = 0; // Record the index which value < newValue\n      let valueDist = mergedMax - mergedMin;\n      rawValues.forEach((val, index) => {\n        const dist = Math.abs(newValue - val);\n        if (dist <= valueDist) {\n          valueDist = dist;\n          valueIndex = index;\n        }\n        if (val < newValue) {\n          valueBeforeIndex = index;\n        }\n      });\n      let focusIndex = valueIndex;\n      if (rangeEditable && valueDist !== 0 && (!maxCount || rawValues.length < maxCount)) {\n        cloneNextValues.splice(valueBeforeIndex + 1, 0, newValue);\n        focusIndex = valueBeforeIndex + 1;\n      } else {\n        cloneNextValues[valueIndex] = newValue;\n      }\n\n      // Fill value to match default 2 (only when `rawValues` is empty)\n      if (rangeEnabled && !rawValues.length && count === undefined) {\n        cloneNextValues.push(newValue);\n      }\n      const nextValue = getTriggerValue(cloneNextValues);\n      onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(nextValue);\n      triggerChange(cloneNextValues);\n      if (e) {\n        var _document$activeEleme, _document$activeEleme2;\n        (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 || (_document$activeEleme2 = _document$activeEleme.blur) === null || _document$activeEleme2 === void 0 || _document$activeEleme2.call(_document$activeEleme);\n        handlesRef.current.focus(focusIndex);\n        onStartDrag(e, focusIndex, cloneNextValues);\n      } else {\n        // https://github.com/ant-design/ant-design/issues/49997\n        onAfterChange === null || onAfterChange === void 0 || onAfterChange(nextValue);\n        warning(!onAfterChange, '[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.');\n        onChangeComplete === null || onChangeComplete === void 0 || onChangeComplete(nextValue);\n      }\n    }\n  };\n\n  // ============================ Click =============================\n  const onSliderMouseDown = e => {\n    e.preventDefault();\n    const {\n      width,\n      height,\n      left,\n      top,\n      bottom,\n      right\n    } = containerRef.current.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = e;\n    let percent;\n    switch (direction) {\n      case 'btt':\n        percent = (bottom - clientY) / height;\n        break;\n      case 'ttb':\n        percent = (clientY - top) / height;\n        break;\n      case 'rtl':\n        percent = (right - clientX) / width;\n        break;\n      default:\n        percent = (clientX - left) / width;\n    }\n    const nextValue = mergedMin + percent * (mergedMax - mergedMin);\n    changeToCloseValue(formatValue(nextValue), e);\n  };\n\n  // =========================== Keyboard ===========================\n  const [keyboardValue, setKeyboardValue] = React.useState(null);\n  const onHandleOffsetChange = (offset, valueIndex) => {\n    if (!disabled) {\n      const next = offsetValues(rawValues, offset, valueIndex);\n      onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(getTriggerValue(rawValues));\n      triggerChange(next.values);\n      setKeyboardValue(next.value);\n    }\n  };\n  React.useEffect(() => {\n    if (keyboardValue !== null) {\n      const valueIndex = rawValues.indexOf(keyboardValue);\n      if (valueIndex >= 0) {\n        handlesRef.current.focus(valueIndex);\n      }\n    }\n    setKeyboardValue(null);\n  }, [keyboardValue]);\n\n  // ============================= Drag =============================\n  const mergedDraggableTrack = React.useMemo(() => {\n    if (rangeDraggableTrack && mergedStep === null) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(false, '`draggableTrack` is not supported when `step` is `null`.');\n      }\n      return false;\n    }\n    return rangeDraggableTrack;\n  }, [rangeDraggableTrack, mergedStep]);\n  const onStartMove = useEvent((e, valueIndex) => {\n    onStartDrag(e, valueIndex);\n    onBeforeChange === null || onBeforeChange === void 0 || onBeforeChange(getTriggerValue(rawValues));\n  });\n\n  // Auto focus for updated handle\n  const dragging = draggingIndex !== -1;\n  React.useEffect(() => {\n    if (!dragging) {\n      const valueIndex = rawValues.lastIndexOf(draggingValue);\n      handlesRef.current.focus(valueIndex);\n    }\n  }, [dragging]);\n\n  // =========================== Included ===========================\n  const sortedCacheValues = React.useMemo(() => [...cacheValues].sort((a, b) => a - b), [cacheValues]);\n\n  // Provide a range values with included [min, max]\n  // Used for Track, Mark & Dot\n  const [includedStart, includedEnd] = React.useMemo(() => {\n    if (!rangeEnabled) {\n      return [mergedMin, sortedCacheValues[0]];\n    }\n    return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];\n  }, [sortedCacheValues, rangeEnabled, mergedMin]);\n\n  // ============================= Refs =============================\n  React.useImperativeHandle(ref, () => ({\n    focus: () => {\n      handlesRef.current.focus(0);\n    },\n    blur: () => {\n      var _containerRef$current;\n      const {\n        activeElement\n      } = document;\n      if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(activeElement)) {\n        activeElement === null || activeElement === void 0 || activeElement.blur();\n      }\n    }\n  }));\n\n  // ========================== Auto Focus ==========================\n  React.useEffect(() => {\n    if (autoFocus) {\n      handlesRef.current.focus(0);\n    }\n  }, []);\n\n  // =========================== Context ============================\n  const context = React.useMemo(() => ({\n    min: mergedMin,\n    max: mergedMax,\n    direction,\n    disabled,\n    keyboard,\n    step: mergedStep,\n    included,\n    includedStart,\n    includedEnd,\n    range: rangeEnabled,\n    tabIndex,\n    ariaLabelForHandle,\n    ariaLabelledByForHandle,\n    ariaRequired,\n    ariaValueTextFormatterForHandle,\n    styles: styles || {},\n    classNames: classNames || {}\n  }), [mergedMin, mergedMax, direction, disabled, keyboard, mergedStep, included, includedStart, includedEnd, rangeEnabled, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaRequired, ariaValueTextFormatterForHandle, styles, classNames]);\n\n  // ============================ Render ============================\n  return /*#__PURE__*/React.createElement(SliderContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: clsx(prefixCls, className, {\n      [\"\".concat(prefixCls, \"-disabled\")]: disabled,\n      [\"\".concat(prefixCls, \"-vertical\")]: vertical,\n      [\"\".concat(prefixCls, \"-horizontal\")]: !vertical,\n      [\"\".concat(prefixCls, \"-with-marks\")]: markList.length\n    }),\n    style: style,\n    onMouseDown: onSliderMouseDown,\n    id: id\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(\"\".concat(prefixCls, \"-rail\"), classNames === null || classNames === void 0 ? void 0 : classNames.rail),\n    style: _objectSpread(_objectSpread({}, railStyle), styles === null || styles === void 0 ? void 0 : styles.rail)\n  }), track !== false && /*#__PURE__*/React.createElement(Tracks, {\n    prefixCls: prefixCls,\n    style: trackStyle,\n    values: rawValues,\n    startPoint: startPoint,\n    onStartMove: mergedDraggableTrack ? onStartMove : undefined\n  }), /*#__PURE__*/React.createElement(Steps, {\n    prefixCls: prefixCls,\n    marks: markList,\n    dots: dots,\n    style: dotStyle,\n    activeStyle: activeDotStyle\n  }), /*#__PURE__*/React.createElement(Handles, {\n    ref: handlesRef,\n    prefixCls: prefixCls,\n    style: handleStyle,\n    values: cacheValues,\n    draggingIndex: draggingIndex,\n    draggingDelete: draggingDelete,\n    onStartMove: onStartMove,\n    onOffsetChange: onHandleOffsetChange,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    handleRender: handleRender,\n    activeHandleRender: activeHandleRender,\n    onChangeComplete: finishChange,\n    onDelete: rangeEditable ? onDelete : undefined\n  }), /*#__PURE__*/React.createElement(Marks, {\n    prefixCls: prefixCls,\n    marks: markList,\n    onClick: changeToCloseValue\n  })));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Slider.displayName = 'Slider';\n}\nexport default Slider;","map":{"version":3,"names":["useControlledState","useEvent","isEqual","warning","clsx","React","Handles","Marks","Steps","Tracks","SliderContext","useDrag","useOffset","useRange","Slider","forwardRef","props","ref","prefixCls","className","style","classNames","styles","id","disabled","keyboard","autoFocus","onFocus","onBlur","min","max","step","value","defaultValue","range","count","onChange","onBeforeChange","onAfterChange","onChangeComplete","allowCross","pushable","reverse","vertical","included","startPoint","trackStyle","handleStyle","railStyle","dotStyle","activeDotStyle","marks","dots","handleRender","activeHandleRender","track","tabIndex","ariaLabelForHandle","ariaLabelledByForHandle","ariaRequired","ariaValueTextFormatterForHandle","handlesRef","useRef","containerRef","direction","useMemo","rangeEnabled","rangeEditable","rangeDraggableTrack","minCount","maxCount","mergedMin","isFinite","mergedMax","mergedStep","mergedPush","markList","Object","keys","map","key","mark","markObj","Number","isValidElement","label","filter","_ref","sort","a","b","formatValue","offsetValues","mergedValue","setValue","rawValues","valueList","undefined","Array","isArray","val0","returnValues","pointCount","slice","length","_returnValues","push","forEach","val","index","getTriggerValue","triggerValues","triggerChange","nextValues","cloneNextValues","finishChange","draggingDelete","current","hideHelp","finishValue","onDelete","splice","nextFocusIndex","Math","focus","draggingIndex","draggingValue","cacheValues","onStartDrag","changeToCloseValue","newValue","e","valueIndex","valueBeforeIndex","valueDist","dist","abs","focusIndex","nextValue","_document$activeEleme","_document$activeEleme2","document","activeElement","blur","call","onSliderMouseDown","preventDefault","width","height","left","top","bottom","right","getBoundingClientRect","clientX","clientY","percent","keyboardValue","setKeyboardValue","useState","onHandleOffsetChange","offset","next","values","useEffect","indexOf","mergedDraggableTrack","process","env","NODE_ENV","onStartMove","dragging","lastIndexOf","sortedCacheValues","includedStart","includedEnd","useImperativeHandle","_containerRef$current","contains","context","createElement","Provider","concat","onMouseDown","rail","_objectSpread","activeStyle","onOffsetChange","onClick","displayName"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/slider/es/Slider.js"],"sourcesContent":["import useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport { clsx } from 'clsx';\nimport * as React from 'react';\nimport Handles from \"./Handles\";\nimport Marks from \"./Marks\";\nimport Steps from \"./Steps\";\nimport Tracks from \"./Tracks\";\nimport SliderContext from \"./context\";\nimport useDrag from \"./hooks/useDrag\";\nimport useOffset from \"./hooks/useOffset\";\nimport useRange from \"./hooks/useRange\";\n\n/**\n * New:\n * - click mark to update range value\n * - handleRender\n * - Fix handle with count not correct\n * - Fix pushable not work in some case\n * - No more FindDOMNode\n * - Move all position related style into inline style\n * - Key: up is plus, down is minus\n * - fix Key with step = null not align with marks\n * - Change range should not trigger onChange\n * - keyboard support pushable\n */\n\nconst Slider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    prefixCls = 'rc-slider',\n    className,\n    style,\n    classNames,\n    styles,\n    id,\n    // Status\n    disabled = false,\n    keyboard = true,\n    autoFocus,\n    onFocus,\n    onBlur,\n    // Value\n    min = 0,\n    max = 100,\n    step = 1,\n    value,\n    defaultValue,\n    range,\n    count,\n    onChange,\n    onBeforeChange,\n    onAfterChange,\n    onChangeComplete,\n    // Cross\n    allowCross = true,\n    pushable = false,\n    // Direction\n    reverse,\n    vertical,\n    // Style\n    included = true,\n    startPoint,\n    trackStyle,\n    handleStyle,\n    railStyle,\n    dotStyle,\n    activeDotStyle,\n    // Decorations\n    marks,\n    dots,\n    // Components\n    handleRender,\n    activeHandleRender,\n    track,\n    // Accessibility\n    tabIndex = 0,\n    ariaLabelForHandle,\n    ariaLabelledByForHandle,\n    ariaRequired,\n    ariaValueTextFormatterForHandle\n  } = props;\n  const handlesRef = React.useRef(null);\n  const containerRef = React.useRef(null);\n  const direction = React.useMemo(() => {\n    if (vertical) {\n      return reverse ? 'ttb' : 'btt';\n    }\n    return reverse ? 'rtl' : 'ltr';\n  }, [reverse, vertical]);\n\n  // ============================ Range =============================\n  const [rangeEnabled, rangeEditable, rangeDraggableTrack, minCount, maxCount] = useRange(range);\n  const mergedMin = React.useMemo(() => isFinite(min) ? min : 0, [min]);\n  const mergedMax = React.useMemo(() => isFinite(max) ? max : 100, [max]);\n\n  // ============================= Step =============================\n  const mergedStep = React.useMemo(() => step !== null && step <= 0 ? 1 : step, [step]);\n\n  // ============================= Push =============================\n  const mergedPush = React.useMemo(() => {\n    if (typeof pushable === 'boolean') {\n      return pushable ? mergedStep : false;\n    }\n    return pushable >= 0 ? pushable : false;\n  }, [pushable, mergedStep]);\n\n  // ============================ Marks =============================\n  const markList = React.useMemo(() => {\n    return Object.keys(marks || {}).map(key => {\n      const mark = marks[key];\n      const markObj = {\n        value: Number(key)\n      };\n      if (mark && typeof mark === 'object' && ! /*#__PURE__*/React.isValidElement(mark) && ('label' in mark || 'style' in mark)) {\n        markObj.style = mark.style;\n        markObj.label = mark.label;\n      } else {\n        markObj.label = mark;\n      }\n      return markObj;\n    }).filter(({\n      label\n    }) => label || typeof label === 'number').sort((a, b) => a.value - b.value);\n  }, [marks]);\n\n  // ============================ Format ============================\n  const [formatValue, offsetValues] = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush);\n\n  // ============================ Values ============================\n  const [mergedValue, setValue] = useControlledState(defaultValue, value);\n  const rawValues = React.useMemo(() => {\n    const valueList = mergedValue === null || mergedValue === undefined ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];\n    const [val0 = mergedMin] = valueList;\n    let returnValues = mergedValue === null ? [] : [val0];\n\n    // Format as range\n    if (rangeEnabled) {\n      returnValues = [...valueList];\n\n      // When count provided or value is `undefined`, we fill values\n      if (count || mergedValue === undefined) {\n        const pointCount = count >= 0 ? count + 1 : 2;\n        returnValues = returnValues.slice(0, pointCount);\n\n        // Fill with count\n        while (returnValues.length < pointCount) {\n          returnValues.push(returnValues[returnValues.length - 1] ?? mergedMin);\n        }\n      }\n      returnValues.sort((a, b) => a - b);\n    }\n\n    // Align in range\n    returnValues.forEach((val, index) => {\n      returnValues[index] = formatValue(val);\n    });\n    return returnValues;\n  }, [mergedValue, rangeEnabled, mergedMin, count, formatValue]);\n\n  // =========================== onChange ===========================\n  const getTriggerValue = triggerValues => rangeEnabled ? triggerValues : triggerValues[0];\n  const triggerChange = useEvent(nextValues => {\n    // Order first\n    const cloneNextValues = [...nextValues].sort((a, b) => a - b);\n\n    // Trigger event if needed\n    if (onChange && !isEqual(cloneNextValues, rawValues, true)) {\n      onChange(getTriggerValue(cloneNextValues));\n    }\n\n    // We set this later since it will re-render component immediately\n    setValue(cloneNextValues);\n  });\n  const finishChange = useEvent(draggingDelete => {\n    // Trigger from `useDrag` will tell if it's a delete action\n    if (draggingDelete) {\n      handlesRef.current.hideHelp();\n    }\n    const finishValue = getTriggerValue(rawValues);\n    onAfterChange?.(finishValue);\n    warning(!onAfterChange, '[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.');\n    onChangeComplete?.(finishValue);\n  });\n  const onDelete = index => {\n    if (disabled || !rangeEditable || rawValues.length <= minCount) {\n      return;\n    }\n    const cloneNextValues = [...rawValues];\n    cloneNextValues.splice(index, 1);\n    onBeforeChange?.(getTriggerValue(cloneNextValues));\n    triggerChange(cloneNextValues);\n    const nextFocusIndex = Math.max(0, index - 1);\n    handlesRef.current.hideHelp();\n    handlesRef.current.focus(nextFocusIndex);\n  };\n  const [draggingIndex, draggingValue, draggingDelete, cacheValues, onStartDrag] = useDrag(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue, triggerChange, finishChange, offsetValues, rangeEditable, minCount);\n\n  /**\n   * When `rangeEditable` will insert a new value in the values array.\n   * Else it will replace the value in the values array.\n   */\n  const changeToCloseValue = (newValue, e) => {\n    if (!disabled) {\n      // Create new values\n      const cloneNextValues = [...rawValues];\n      let valueIndex = 0;\n      let valueBeforeIndex = 0; // Record the index which value < newValue\n      let valueDist = mergedMax - mergedMin;\n      rawValues.forEach((val, index) => {\n        const dist = Math.abs(newValue - val);\n        if (dist <= valueDist) {\n          valueDist = dist;\n          valueIndex = index;\n        }\n        if (val < newValue) {\n          valueBeforeIndex = index;\n        }\n      });\n      let focusIndex = valueIndex;\n      if (rangeEditable && valueDist !== 0 && (!maxCount || rawValues.length < maxCount)) {\n        cloneNextValues.splice(valueBeforeIndex + 1, 0, newValue);\n        focusIndex = valueBeforeIndex + 1;\n      } else {\n        cloneNextValues[valueIndex] = newValue;\n      }\n\n      // Fill value to match default 2 (only when `rawValues` is empty)\n      if (rangeEnabled && !rawValues.length && count === undefined) {\n        cloneNextValues.push(newValue);\n      }\n      const nextValue = getTriggerValue(cloneNextValues);\n      onBeforeChange?.(nextValue);\n      triggerChange(cloneNextValues);\n      if (e) {\n        document.activeElement?.blur?.();\n        handlesRef.current.focus(focusIndex);\n        onStartDrag(e, focusIndex, cloneNextValues);\n      } else {\n        // https://github.com/ant-design/ant-design/issues/49997\n        onAfterChange?.(nextValue);\n        warning(!onAfterChange, '[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.');\n        onChangeComplete?.(nextValue);\n      }\n    }\n  };\n\n  // ============================ Click =============================\n  const onSliderMouseDown = e => {\n    e.preventDefault();\n    const {\n      width,\n      height,\n      left,\n      top,\n      bottom,\n      right\n    } = containerRef.current.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = e;\n    let percent;\n    switch (direction) {\n      case 'btt':\n        percent = (bottom - clientY) / height;\n        break;\n      case 'ttb':\n        percent = (clientY - top) / height;\n        break;\n      case 'rtl':\n        percent = (right - clientX) / width;\n        break;\n      default:\n        percent = (clientX - left) / width;\n    }\n    const nextValue = mergedMin + percent * (mergedMax - mergedMin);\n    changeToCloseValue(formatValue(nextValue), e);\n  };\n\n  // =========================== Keyboard ===========================\n  const [keyboardValue, setKeyboardValue] = React.useState(null);\n  const onHandleOffsetChange = (offset, valueIndex) => {\n    if (!disabled) {\n      const next = offsetValues(rawValues, offset, valueIndex);\n      onBeforeChange?.(getTriggerValue(rawValues));\n      triggerChange(next.values);\n      setKeyboardValue(next.value);\n    }\n  };\n  React.useEffect(() => {\n    if (keyboardValue !== null) {\n      const valueIndex = rawValues.indexOf(keyboardValue);\n      if (valueIndex >= 0) {\n        handlesRef.current.focus(valueIndex);\n      }\n    }\n    setKeyboardValue(null);\n  }, [keyboardValue]);\n\n  // ============================= Drag =============================\n  const mergedDraggableTrack = React.useMemo(() => {\n    if (rangeDraggableTrack && mergedStep === null) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(false, '`draggableTrack` is not supported when `step` is `null`.');\n      }\n      return false;\n    }\n    return rangeDraggableTrack;\n  }, [rangeDraggableTrack, mergedStep]);\n  const onStartMove = useEvent((e, valueIndex) => {\n    onStartDrag(e, valueIndex);\n    onBeforeChange?.(getTriggerValue(rawValues));\n  });\n\n  // Auto focus for updated handle\n  const dragging = draggingIndex !== -1;\n  React.useEffect(() => {\n    if (!dragging) {\n      const valueIndex = rawValues.lastIndexOf(draggingValue);\n      handlesRef.current.focus(valueIndex);\n    }\n  }, [dragging]);\n\n  // =========================== Included ===========================\n  const sortedCacheValues = React.useMemo(() => [...cacheValues].sort((a, b) => a - b), [cacheValues]);\n\n  // Provide a range values with included [min, max]\n  // Used for Track, Mark & Dot\n  const [includedStart, includedEnd] = React.useMemo(() => {\n    if (!rangeEnabled) {\n      return [mergedMin, sortedCacheValues[0]];\n    }\n    return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];\n  }, [sortedCacheValues, rangeEnabled, mergedMin]);\n\n  // ============================= Refs =============================\n  React.useImperativeHandle(ref, () => ({\n    focus: () => {\n      handlesRef.current.focus(0);\n    },\n    blur: () => {\n      const {\n        activeElement\n      } = document;\n      if (containerRef.current?.contains(activeElement)) {\n        activeElement?.blur();\n      }\n    }\n  }));\n\n  // ========================== Auto Focus ==========================\n  React.useEffect(() => {\n    if (autoFocus) {\n      handlesRef.current.focus(0);\n    }\n  }, []);\n\n  // =========================== Context ============================\n  const context = React.useMemo(() => ({\n    min: mergedMin,\n    max: mergedMax,\n    direction,\n    disabled,\n    keyboard,\n    step: mergedStep,\n    included,\n    includedStart,\n    includedEnd,\n    range: rangeEnabled,\n    tabIndex,\n    ariaLabelForHandle,\n    ariaLabelledByForHandle,\n    ariaRequired,\n    ariaValueTextFormatterForHandle,\n    styles: styles || {},\n    classNames: classNames || {}\n  }), [mergedMin, mergedMax, direction, disabled, keyboard, mergedStep, included, includedStart, includedEnd, rangeEnabled, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaRequired, ariaValueTextFormatterForHandle, styles, classNames]);\n\n  // ============================ Render ============================\n  return /*#__PURE__*/React.createElement(SliderContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: clsx(prefixCls, className, {\n      [`${prefixCls}-disabled`]: disabled,\n      [`${prefixCls}-vertical`]: vertical,\n      [`${prefixCls}-horizontal`]: !vertical,\n      [`${prefixCls}-with-marks`]: markList.length\n    }),\n    style: style,\n    onMouseDown: onSliderMouseDown,\n    id: id\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: clsx(`${prefixCls}-rail`, classNames?.rail),\n    style: {\n      ...railStyle,\n      ...styles?.rail\n    }\n  }), track !== false && /*#__PURE__*/React.createElement(Tracks, {\n    prefixCls: prefixCls,\n    style: trackStyle,\n    values: rawValues,\n    startPoint: startPoint,\n    onStartMove: mergedDraggableTrack ? onStartMove : undefined\n  }), /*#__PURE__*/React.createElement(Steps, {\n    prefixCls: prefixCls,\n    marks: markList,\n    dots: dots,\n    style: dotStyle,\n    activeStyle: activeDotStyle\n  }), /*#__PURE__*/React.createElement(Handles, {\n    ref: handlesRef,\n    prefixCls: prefixCls,\n    style: handleStyle,\n    values: cacheValues,\n    draggingIndex: draggingIndex,\n    draggingDelete: draggingDelete,\n    onStartMove: onStartMove,\n    onOffsetChange: onHandleOffsetChange,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    handleRender: handleRender,\n    activeHandleRender: activeHandleRender,\n    onChangeComplete: finishChange,\n    onDelete: rangeEditable ? onDelete : undefined\n  }), /*#__PURE__*/React.createElement(Marks, {\n    prefixCls: prefixCls,\n    marks: markList,\n    onClick: changeToCloseValue\n  })));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Slider.displayName = 'Slider';\n}\nexport default Slider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}