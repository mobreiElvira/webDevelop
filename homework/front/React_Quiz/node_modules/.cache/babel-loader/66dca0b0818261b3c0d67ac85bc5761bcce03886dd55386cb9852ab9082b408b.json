{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getClientSize } from \"../util\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport raf from \"@rc-component/util/es/raf\";\nimport { useRef, useState } from 'react';\nconst initialTransform = {\n  x: 0,\n  y: 0,\n  rotate: 0,\n  scale: 1,\n  flipX: false,\n  flipY: false\n};\nexport default function useImageTransform(imgRef, minScale, maxScale, onTransform) {\n  const frame = useRef(null);\n  const queue = useRef([]);\n  const [transform, setTransform] = useState(initialTransform);\n  const resetTransform = action => {\n    setTransform(initialTransform);\n    if (!isEqual(initialTransform, transform)) {\n      onTransform === null || onTransform === void 0 || onTransform({\n        transform: initialTransform,\n        action\n      });\n    }\n  };\n\n  /** Direct update transform */\n  const updateTransform = (newTransform, action) => {\n    if (frame.current === null) {\n      queue.current = [];\n      frame.current = raf(() => {\n        setTransform(preState => {\n          let memoState = preState;\n          queue.current.forEach(queueState => {\n            memoState = _objectSpread(_objectSpread({}, memoState), queueState);\n          });\n          frame.current = null;\n          onTransform === null || onTransform === void 0 || onTransform({\n            transform: memoState,\n            action\n          });\n          return memoState;\n        });\n      });\n    }\n    queue.current.push(_objectSpread(_objectSpread({}, transform), newTransform));\n  };\n\n  /** Scale according to the position of centerX and centerY */\n  const dispatchZoomChange = (ratio, action, centerX, centerY, isTouch) => {\n    const {\n      width,\n      height,\n      offsetWidth,\n      offsetHeight,\n      offsetLeft,\n      offsetTop\n    } = imgRef.current;\n    let newRatio = ratio;\n    let newScale = transform.scale * ratio;\n    if (newScale > maxScale) {\n      newScale = maxScale;\n      newRatio = maxScale / transform.scale;\n    } else if (newScale < minScale) {\n      // For mobile interactions, allow scaling down to the minimum scale.\n      newScale = isTouch ? newScale : minScale;\n      newRatio = newScale / transform.scale;\n    }\n\n    /** Default center point scaling */\n    const mergedCenterX = centerX !== null && centerX !== void 0 ? centerX : innerWidth / 2;\n    const mergedCenterY = centerY !== null && centerY !== void 0 ? centerY : innerHeight / 2;\n    const diffRatio = newRatio - 1;\n    /** Deviation calculated from image size */\n    const diffImgX = diffRatio * width * 0.5;\n    const diffImgY = diffRatio * height * 0.5;\n    /** The difference between the click position and the edge of the document */\n    const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);\n    const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);\n    /** Final positioning */\n    let newX = transform.x - (diffOffsetLeft - diffImgX);\n    let newY = transform.y - (diffOffsetTop - diffImgY);\n\n    /**\n     * When zooming the image\n     * When the image size is smaller than the width and height of the window, the position is initialized\n     */\n    if (ratio < 1 && newScale === 1) {\n      const mergedWidth = offsetWidth * newScale;\n      const mergedHeight = offsetHeight * newScale;\n      const {\n        width: clientWidth,\n        height: clientHeight\n      } = getClientSize();\n      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {\n        newX = 0;\n        newY = 0;\n      }\n    }\n    updateTransform({\n      x: newX,\n      y: newY,\n      scale: newScale\n    }, action);\n  };\n  return {\n    transform,\n    resetTransform,\n    updateTransform,\n    dispatchZoomChange\n  };\n}","map":{"version":3,"names":["getClientSize","isEqual","raf","useRef","useState","initialTransform","x","y","rotate","scale","flipX","flipY","useImageTransform","imgRef","minScale","maxScale","onTransform","frame","queue","transform","setTransform","resetTransform","action","updateTransform","newTransform","current","preState","memoState","forEach","queueState","_objectSpread","push","dispatchZoomChange","ratio","centerX","centerY","isTouch","width","height","offsetWidth","offsetHeight","offsetLeft","offsetTop","newRatio","newScale","mergedCenterX","innerWidth","mergedCenterY","innerHeight","diffRatio","diffImgX","diffImgY","diffOffsetLeft","diffOffsetTop","newX","newY","mergedWidth","mergedHeight","clientWidth","clientHeight"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/image/es/hooks/useImageTransform.js"],"sourcesContent":["import { getClientSize } from \"../util\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport raf from \"@rc-component/util/es/raf\";\nimport { useRef, useState } from 'react';\nconst initialTransform = {\n  x: 0,\n  y: 0,\n  rotate: 0,\n  scale: 1,\n  flipX: false,\n  flipY: false\n};\nexport default function useImageTransform(imgRef, minScale, maxScale, onTransform) {\n  const frame = useRef(null);\n  const queue = useRef([]);\n  const [transform, setTransform] = useState(initialTransform);\n  const resetTransform = action => {\n    setTransform(initialTransform);\n    if (!isEqual(initialTransform, transform)) {\n      onTransform?.({\n        transform: initialTransform,\n        action\n      });\n    }\n  };\n\n  /** Direct update transform */\n  const updateTransform = (newTransform, action) => {\n    if (frame.current === null) {\n      queue.current = [];\n      frame.current = raf(() => {\n        setTransform(preState => {\n          let memoState = preState;\n          queue.current.forEach(queueState => {\n            memoState = {\n              ...memoState,\n              ...queueState\n            };\n          });\n          frame.current = null;\n          onTransform?.({\n            transform: memoState,\n            action\n          });\n          return memoState;\n        });\n      });\n    }\n    queue.current.push({\n      ...transform,\n      ...newTransform\n    });\n  };\n\n  /** Scale according to the position of centerX and centerY */\n  const dispatchZoomChange = (ratio, action, centerX, centerY, isTouch) => {\n    const {\n      width,\n      height,\n      offsetWidth,\n      offsetHeight,\n      offsetLeft,\n      offsetTop\n    } = imgRef.current;\n    let newRatio = ratio;\n    let newScale = transform.scale * ratio;\n    if (newScale > maxScale) {\n      newScale = maxScale;\n      newRatio = maxScale / transform.scale;\n    } else if (newScale < minScale) {\n      // For mobile interactions, allow scaling down to the minimum scale.\n      newScale = isTouch ? newScale : minScale;\n      newRatio = newScale / transform.scale;\n    }\n\n    /** Default center point scaling */\n    const mergedCenterX = centerX ?? innerWidth / 2;\n    const mergedCenterY = centerY ?? innerHeight / 2;\n    const diffRatio = newRatio - 1;\n    /** Deviation calculated from image size */\n    const diffImgX = diffRatio * width * 0.5;\n    const diffImgY = diffRatio * height * 0.5;\n    /** The difference between the click position and the edge of the document */\n    const diffOffsetLeft = diffRatio * (mergedCenterX - transform.x - offsetLeft);\n    const diffOffsetTop = diffRatio * (mergedCenterY - transform.y - offsetTop);\n    /** Final positioning */\n    let newX = transform.x - (diffOffsetLeft - diffImgX);\n    let newY = transform.y - (diffOffsetTop - diffImgY);\n\n    /**\n     * When zooming the image\n     * When the image size is smaller than the width and height of the window, the position is initialized\n     */\n    if (ratio < 1 && newScale === 1) {\n      const mergedWidth = offsetWidth * newScale;\n      const mergedHeight = offsetHeight * newScale;\n      const {\n        width: clientWidth,\n        height: clientHeight\n      } = getClientSize();\n      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {\n        newX = 0;\n        newY = 0;\n      }\n    }\n    updateTransform({\n      x: newX,\n      y: newY,\n      scale: newScale\n    }, action);\n  };\n  return {\n    transform,\n    resetTransform,\n    updateTransform,\n    dispatchZoomChange\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}