{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport { supportRef, useComposeRef, getNodeRef } from \"@rc-component/util/es/ref\";\nimport * as React from 'react';\nimport { CollectionContext } from \"../Collection\";\nimport { observe, unobserve } from \"../utils/observerUtil\";\nfunction SingleObserver(props, ref) {\n  const {\n    children,\n    disabled\n  } = props;\n  const elementRef = React.useRef(null);\n  const onCollectionResize = React.useContext(CollectionContext);\n\n  // =========================== Children ===========================\n  const isRenderProps = typeof children === 'function';\n  const mergedChildren = isRenderProps ? children(elementRef) : children;\n\n  // ============================= Size =============================\n  const sizeRef = React.useRef({\n    width: -1,\n    height: -1,\n    offsetWidth: -1,\n    offsetHeight: -1\n  });\n\n  // ============================= Ref ==============================\n  const canRef = !isRenderProps && /*#__PURE__*/React.isValidElement(mergedChildren) && supportRef(mergedChildren);\n  const originRef = canRef ? getNodeRef(mergedChildren) : null;\n  const mergedRef = useComposeRef(originRef, elementRef);\n  const getDomElement = () => {\n    return getDOM(elementRef.current);\n  };\n  React.useImperativeHandle(ref, () => getDomElement());\n\n  // =========================== Observe ============================\n  const propsRef = React.useRef(props);\n  propsRef.current = props;\n\n  // Handler\n  const onInternalResize = React.useCallback(target => {\n    const {\n      onResize,\n      data\n    } = propsRef.current;\n    const {\n      width,\n      height\n    } = target.getBoundingClientRect();\n    const {\n      offsetWidth,\n      offsetHeight\n    } = target;\n\n    /**\n     * Resize observer trigger when content size changed.\n     * In most case we just care about element size,\n     * let's use `boundary` instead of `contentRect` here to avoid shaking.\n     */\n    const fixedWidth = Math.floor(width);\n    const fixedHeight = Math.floor(height);\n    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {\n      const size = {\n        width: fixedWidth,\n        height: fixedHeight,\n        offsetWidth,\n        offsetHeight\n      };\n      sizeRef.current = size;\n\n      // IE is strange, right?\n      const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;\n      const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;\n      const sizeInfo = _objectSpread(_objectSpread({}, size), {}, {\n        offsetWidth: mergedOffsetWidth,\n        offsetHeight: mergedOffsetHeight\n      });\n\n      // Let collection know what happened\n      onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);\n      if (onResize) {\n        // defer the callback but not defer to next frame\n        Promise.resolve().then(() => {\n          onResize(sizeInfo, target);\n        });\n      }\n    }\n  }, []);\n\n  // Dynamic observe\n  React.useEffect(() => {\n    const currentElement = getDomElement();\n    if (currentElement && !disabled) {\n      observe(currentElement, onInternalResize);\n    }\n    return () => unobserve(currentElement, onInternalResize);\n  }, [elementRef.current, disabled]);\n\n  // ============================ Render ============================\n  return canRef ? /*#__PURE__*/React.cloneElement(mergedChildren, {\n    ref: mergedRef\n  }) : mergedChildren;\n}\nconst RefSingleObserver = /*#__PURE__*/React.forwardRef(SingleObserver);\nif (process.env.NODE_ENV !== 'production') {\n  RefSingleObserver.displayName = 'SingleObserver';\n}\nexport default RefSingleObserver;","map":{"version":3,"names":["getDOM","supportRef","useComposeRef","getNodeRef","React","CollectionContext","observe","unobserve","SingleObserver","props","ref","children","disabled","elementRef","useRef","onCollectionResize","useContext","isRenderProps","mergedChildren","sizeRef","width","height","offsetWidth","offsetHeight","canRef","isValidElement","originRef","mergedRef","getDomElement","current","useImperativeHandle","propsRef","onInternalResize","useCallback","target","onResize","data","getBoundingClientRect","fixedWidth","Math","floor","fixedHeight","size","mergedOffsetWidth","round","mergedOffsetHeight","sizeInfo","_objectSpread","Promise","resolve","then","useEffect","currentElement","cloneElement","RefSingleObserver","forwardRef","process","env","NODE_ENV","displayName"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/resize-observer/es/SingleObserver/index.js"],"sourcesContent":["import { getDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport { supportRef, useComposeRef, getNodeRef } from \"@rc-component/util/es/ref\";\nimport * as React from 'react';\nimport { CollectionContext } from \"../Collection\";\nimport { observe, unobserve } from \"../utils/observerUtil\";\nfunction SingleObserver(props, ref) {\n  const {\n    children,\n    disabled\n  } = props;\n  const elementRef = React.useRef(null);\n  const onCollectionResize = React.useContext(CollectionContext);\n\n  // =========================== Children ===========================\n  const isRenderProps = typeof children === 'function';\n  const mergedChildren = isRenderProps ? children(elementRef) : children;\n\n  // ============================= Size =============================\n  const sizeRef = React.useRef({\n    width: -1,\n    height: -1,\n    offsetWidth: -1,\n    offsetHeight: -1\n  });\n\n  // ============================= Ref ==============================\n  const canRef = !isRenderProps && /*#__PURE__*/React.isValidElement(mergedChildren) && supportRef(mergedChildren);\n  const originRef = canRef ? getNodeRef(mergedChildren) : null;\n  const mergedRef = useComposeRef(originRef, elementRef);\n  const getDomElement = () => {\n    return getDOM(elementRef.current);\n  };\n  React.useImperativeHandle(ref, () => getDomElement());\n\n  // =========================== Observe ============================\n  const propsRef = React.useRef(props);\n  propsRef.current = props;\n\n  // Handler\n  const onInternalResize = React.useCallback(target => {\n    const {\n      onResize,\n      data\n    } = propsRef.current;\n    const {\n      width,\n      height\n    } = target.getBoundingClientRect();\n    const {\n      offsetWidth,\n      offsetHeight\n    } = target;\n\n    /**\n     * Resize observer trigger when content size changed.\n     * In most case we just care about element size,\n     * let's use `boundary` instead of `contentRect` here to avoid shaking.\n     */\n    const fixedWidth = Math.floor(width);\n    const fixedHeight = Math.floor(height);\n    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {\n      const size = {\n        width: fixedWidth,\n        height: fixedHeight,\n        offsetWidth,\n        offsetHeight\n      };\n      sizeRef.current = size;\n\n      // IE is strange, right?\n      const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;\n      const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;\n      const sizeInfo = {\n        ...size,\n        offsetWidth: mergedOffsetWidth,\n        offsetHeight: mergedOffsetHeight\n      };\n\n      // Let collection know what happened\n      onCollectionResize?.(sizeInfo, target, data);\n      if (onResize) {\n        // defer the callback but not defer to next frame\n        Promise.resolve().then(() => {\n          onResize(sizeInfo, target);\n        });\n      }\n    }\n  }, []);\n\n  // Dynamic observe\n  React.useEffect(() => {\n    const currentElement = getDomElement();\n    if (currentElement && !disabled) {\n      observe(currentElement, onInternalResize);\n    }\n    return () => unobserve(currentElement, onInternalResize);\n  }, [elementRef.current, disabled]);\n\n  // ============================ Render ============================\n  return canRef ? /*#__PURE__*/React.cloneElement(mergedChildren, {\n    ref: mergedRef\n  }) : mergedChildren;\n}\nconst RefSingleObserver = /*#__PURE__*/React.forwardRef(SingleObserver);\nif (process.env.NODE_ENV !== 'production') {\n  RefSingleObserver.displayName = 'SingleObserver';\n}\nexport default RefSingleObserver;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}