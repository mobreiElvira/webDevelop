{"ast":null,"code":"import * as React from 'react';\n// recursion (flat tree structure)\nfunction fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index) {\n  const key = getRowKey(record, index);\n  list.push({\n    record,\n    indent,\n    index,\n    rowKey: key\n  });\n  const expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key);\n  if (record && Array.isArray(record[childrenColumnName]) && expanded) {\n    // expanded state, flat record\n    for (let i = 0; i < record[childrenColumnName].length; i += 1) {\n      fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);\n    }\n  }\n}\n/**\n * flat tree data on expanded state\n *\n * @export\n * @template T\n * @param {*} data : table data\n * @param {string} childrenColumnName : 指定树形结构的列名\n * @param {Set<Key>} expandedKeys : 展开的行对应的keys\n * @param {GetRowKey<T>} getRowKey  : 获取当前rowKey的方法\n * @returns flattened data\n */\nexport default function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {\n  const arr = React.useMemo(() => {\n    if (expandedKeys !== null && expandedKeys !== void 0 && expandedKeys.size) {\n      const list = [];\n\n      // collect flattened record\n      for (let i = 0; i < (data === null || data === void 0 ? void 0 : data.length); i += 1) {\n        const record = data[i];\n\n        // using array.push or spread operator may cause \"Maximum call stack size exceeded\" exception if array size is big enough.\n        fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);\n      }\n      return list;\n    }\n    return data === null || data === void 0 ? void 0 : data.map((item, index) => {\n      return {\n        record: item,\n        indent: 0,\n        index,\n        rowKey: getRowKey(item, index)\n      };\n    });\n  }, [data, childrenColumnName, expandedKeys, getRowKey]);\n  return arr;\n}","map":{"version":3,"names":["React","fillRecords","list","record","indent","childrenColumnName","expandedKeys","getRowKey","index","key","push","rowKey","expanded","has","Array","isArray","i","length","useFlattenRecords","data","arr","useMemo","size","map","item"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/table/es/hooks/useFlattenRecords.js"],"sourcesContent":["import * as React from 'react';\n// recursion (flat tree structure)\nfunction fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index) {\n  const key = getRowKey(record, index);\n  list.push({\n    record,\n    indent,\n    index,\n    rowKey: key\n  });\n  const expanded = expandedKeys?.has(key);\n  if (record && Array.isArray(record[childrenColumnName]) && expanded) {\n    // expanded state, flat record\n    for (let i = 0; i < record[childrenColumnName].length; i += 1) {\n      fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);\n    }\n  }\n}\n/**\n * flat tree data on expanded state\n *\n * @export\n * @template T\n * @param {*} data : table data\n * @param {string} childrenColumnName : 指定树形结构的列名\n * @param {Set<Key>} expandedKeys : 展开的行对应的keys\n * @param {GetRowKey<T>} getRowKey  : 获取当前rowKey的方法\n * @returns flattened data\n */\nexport default function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {\n  const arr = React.useMemo(() => {\n    if (expandedKeys?.size) {\n      const list = [];\n\n      // collect flattened record\n      for (let i = 0; i < data?.length; i += 1) {\n        const record = data[i];\n\n        // using array.push or spread operator may cause \"Maximum call stack size exceeded\" exception if array size is big enough.\n        fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);\n      }\n      return list;\n    }\n    return data?.map((item, index) => {\n      return {\n        record: item,\n        indent: 0,\n        index,\n        rowKey: getRowKey(item, index)\n      };\n    });\n  }, [data, childrenColumnName, expandedKeys, getRowKey]);\n  return arr;\n}"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B;AACA,SAASC,WAAWA,CAACC,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAEC,kBAAkB,EAAEC,YAAY,EAAEC,SAAS,EAAEC,KAAK,EAAE;EAC7F,MAAMC,GAAG,GAAGF,SAAS,CAACJ,MAAM,EAAEK,KAAK,CAAC;EACpCN,IAAI,CAACQ,IAAI,CAAC;IACRP,MAAM;IACNC,MAAM;IACNI,KAAK;IACLG,MAAM,EAAEF;EACV,CAAC,CAAC;EACF,MAAMG,QAAQ,GAAGN,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEO,GAAG,CAACJ,GAAG,CAAC;EACvC,IAAIN,MAAM,IAAIW,KAAK,CAACC,OAAO,CAACZ,MAAM,CAACE,kBAAkB,CAAC,CAAC,IAAIO,QAAQ,EAAE;IACnE;IACA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,MAAM,CAACE,kBAAkB,CAAC,CAACY,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MAC7Df,WAAW,CAACC,IAAI,EAAEC,MAAM,CAACE,kBAAkB,CAAC,CAACW,CAAC,CAAC,EAAEZ,MAAM,GAAG,CAAC,EAAEC,kBAAkB,EAAEC,YAAY,EAAEC,SAAS,EAAES,CAAC,CAAC;IAC9G;EACF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASE,iBAAiBA,CAACC,IAAI,EAAEd,kBAAkB,EAAEC,YAAY,EAAEC,SAAS,EAAE;EAC3F,MAAMa,GAAG,GAAGpB,KAAK,CAACqB,OAAO,CAAC,MAAM;IAC9B,IAAIf,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEgB,IAAI,EAAE;MACtB,MAAMpB,IAAI,GAAG,EAAE;;MAEf;MACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAGG,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEF,MAAM,GAAED,CAAC,IAAI,CAAC,EAAE;QACxC,MAAMb,MAAM,GAAGgB,IAAI,CAACH,CAAC,CAAC;;QAEtB;QACAf,WAAW,CAACC,IAAI,EAAEC,MAAM,EAAE,CAAC,EAAEE,kBAAkB,EAAEC,YAAY,EAAEC,SAAS,EAAES,CAAC,CAAC;MAC9E;MACA,OAAOd,IAAI;IACb;IACA,OAAOiB,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEI,GAAG,CAAC,CAACC,IAAI,EAAEhB,KAAK,KAAK;MAChC,OAAO;QACLL,MAAM,EAAEqB,IAAI;QACZpB,MAAM,EAAE,CAAC;QACTI,KAAK;QACLG,MAAM,EAAEJ,SAAS,CAACiB,IAAI,EAAEhB,KAAK;MAC/B,CAAC;IACH,CAAC,CAAC;EACJ,CAAC,EAAE,CAACW,IAAI,EAAEd,kBAAkB,EAAEC,YAAY,EAAEC,SAAS,CAAC,CAAC;EACvD,OAAOa,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}