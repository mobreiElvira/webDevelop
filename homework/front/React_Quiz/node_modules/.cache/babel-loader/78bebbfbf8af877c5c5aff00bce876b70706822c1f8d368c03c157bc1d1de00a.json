{"ast":null,"code":"import _objectSpread from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"F:/\\u7EFC\\u5408/\\u4E2A\\u4EBA/\\u4F5C\\u4E1A/\\u4E3B\\u8BFE/\\u5927\\u4E09/web\\u5F00\\u53D1/homework/front/React_Quiz/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"id\", \"prefixCls\", \"value\", \"defaultValue\", \"onChange\", \"onSelect\", \"onDeselect\", \"showSearch\", \"searchValue\", \"inputValue\", \"onSearch\", \"autoClearSearchValue\", \"filterTreeNode\", \"treeNodeFilterProp\", \"showCheckedStrategy\", \"treeNodeLabelProp\", \"multiple\", \"treeCheckable\", \"treeCheckStrictly\", \"labelInValue\", \"maxCount\", \"fieldNames\", \"treeDataSimpleMode\", \"treeData\", \"children\", \"loadData\", \"treeLoadedKeys\", \"onTreeLoad\", \"treeDefaultExpandAll\", \"treeExpandedKeys\", \"treeDefaultExpandedKeys\", \"onTreeExpand\", \"treeExpandAction\", \"virtual\", \"listHeight\", \"listItemHeight\", \"listItemScrollOffset\", \"onPopupVisibleChange\", \"popupMatchSelectWidth\", \"treeLine\", \"treeIcon\", \"showTreeIcon\", \"switcherIcon\", \"treeMotion\", \"treeTitleRender\", \"onPopupScroll\", \"classNames\", \"styles\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { BaseSelect } from '@rc-component/select';\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport { conductCheck } from \"@rc-component/tree/es/utils/conductUtil\";\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport * as React from 'react';\nimport useCache from \"./hooks/useCache\";\nimport useCheckedKeys from \"./hooks/useCheckedKeys\";\nimport useDataEntities from \"./hooks/useDataEntities\";\nimport useFilterTreeData from \"./hooks/useFilterTreeData\";\nimport useRefFunc from \"./hooks/useRefFunc\";\nimport useTreeData from \"./hooks/useTreeData\";\nimport LegacyContext from \"./LegacyContext\";\nimport OptionList from \"./OptionList\";\nimport TreeNode from \"./TreeNode\";\nimport TreeSelectContext from \"./TreeSelectContext\";\nimport { fillAdditionalInfo, fillLegacyProps } from \"./utils/legacyUtil\";\nimport { formatStrategyValues, SHOW_ALL, SHOW_CHILD, SHOW_PARENT } from \"./utils/strategyUtil\";\nimport { fillFieldNames, isNil, toArray } from \"./utils/valueUtil\";\nimport warningProps from \"./utils/warningPropsUtil\";\nimport useSearchConfig from \"./hooks/useSearchConfig\";\nfunction isRawValue(value) {\n  return !value || typeof value !== 'object';\n}\nconst TreeSelect = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n      id,\n      prefixCls = 'rc-tree-select',\n      // Value\n      value,\n      defaultValue,\n      onChange,\n      onSelect,\n      onDeselect,\n      // Search\n      showSearch,\n      searchValue: legacySearchValue,\n      inputValue: legacyinputValue,\n      onSearch: legacyOnSearch,\n      autoClearSearchValue: legacyAutoClearSearchValue,\n      filterTreeNode: legacyFilterTreeNode,\n      treeNodeFilterProp: legacytreeNodeFilterProp,\n      // Selector\n      showCheckedStrategy,\n      treeNodeLabelProp,\n      //  Mode\n      multiple,\n      treeCheckable,\n      treeCheckStrictly,\n      labelInValue,\n      maxCount,\n      // FieldNames\n      fieldNames,\n      // Data\n      treeDataSimpleMode,\n      treeData,\n      children,\n      loadData,\n      treeLoadedKeys,\n      onTreeLoad,\n      // Expanded\n      treeDefaultExpandAll,\n      treeExpandedKeys,\n      treeDefaultExpandedKeys,\n      onTreeExpand,\n      treeExpandAction,\n      // Options\n      virtual,\n      listHeight = 200,\n      listItemHeight = 20,\n      listItemScrollOffset = 0,\n      onPopupVisibleChange,\n      popupMatchSelectWidth = true,\n      // Tree\n      treeLine,\n      treeIcon,\n      showTreeIcon,\n      switcherIcon,\n      treeMotion,\n      treeTitleRender,\n      onPopupScroll,\n      classNames: treeSelectClassNames,\n      styles\n    } = props,\n    restProps = _objectWithoutProperties(props, _excluded);\n  const mergedId = useId(id);\n  const treeConduction = treeCheckable && !treeCheckStrictly;\n  const mergedCheckable = treeCheckable || treeCheckStrictly;\n  const mergedLabelInValue = treeCheckStrictly || labelInValue;\n  const mergedMultiple = mergedCheckable || multiple;\n  const searchProps = {\n    searchValue: legacySearchValue,\n    inputValue: legacyinputValue,\n    onSearch: legacyOnSearch,\n    autoClearSearchValue: legacyAutoClearSearchValue,\n    filterTreeNode: legacyFilterTreeNode,\n    treeNodeFilterProp: legacytreeNodeFilterProp\n  };\n  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, searchProps);\n  const {\n    searchValue,\n    onSearch,\n    autoClearSearchValue = true,\n    filterTreeNode,\n    treeNodeFilterProp = 'value'\n  } = searchConfig;\n  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);\n\n  // `multiple` && `!treeCheckable` should be show all\n  const mergedShowCheckedStrategy = React.useMemo(() => {\n    if (!treeCheckable) {\n      return SHOW_ALL;\n    }\n    return showCheckedStrategy || SHOW_CHILD;\n  }, [showCheckedStrategy, treeCheckable]);\n\n  // ========================== Warning ===========================\n  if (process.env.NODE_ENV !== 'production') {\n    warningProps(props);\n  }\n\n  // ========================= FieldNames =========================\n  const mergedFieldNames = React.useMemo(() => fillFieldNames(fieldNames), /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify(fieldNames)]\n  /* eslint-enable react-hooks/exhaustive-deps */);\n\n  // =========================== Search ===========================\n  const [internalSearchValue, setSearchValue] = useControlledState('', searchValue);\n  const mergedSearchValue = internalSearchValue || '';\n  const onInternalSearch = searchText => {\n    setSearchValue(searchText);\n    onSearch === null || onSearch === void 0 || onSearch(searchText);\n  };\n\n  // ============================ Data ============================\n  // `useTreeData` only do convert of `children` or `simpleMode`.\n  // Else will return origin `treeData` for perf consideration.\n  // Do not do anything to loop the data.\n  const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);\n  const {\n    keyEntities,\n    valueEntities\n  } = useDataEntities(mergedTreeData, mergedFieldNames);\n\n  /** Get `missingRawValues` which not exist in the tree yet */\n  const splitRawValues = React.useCallback(newRawValues => {\n    const missingRawValues = [];\n    const existRawValues = [];\n\n    // Keep missing value in the cache\n    newRawValues.forEach(val => {\n      if (valueEntities.has(val)) {\n        existRawValues.push(val);\n      } else {\n        missingRawValues.push(val);\n      }\n    });\n    return {\n      missingRawValues,\n      existRawValues\n    };\n  }, [valueEntities]);\n\n  // Filtered Tree\n  const filteredTreeData = useFilterTreeData(mergedTreeData, mergedSearchValue, {\n    fieldNames: mergedFieldNames,\n    treeNodeFilterProp,\n    filterTreeNode\n  });\n\n  // =========================== Label ============================\n  const getLabel = React.useCallback(item => {\n    if (item) {\n      if (treeNodeLabelProp) {\n        return item[treeNodeLabelProp];\n      }\n\n      // Loop from fieldNames\n      const {\n        _title: titleList\n      } = mergedFieldNames;\n      for (let i = 0; i < titleList.length; i += 1) {\n        const title = item[titleList[i]];\n        if (title !== undefined) {\n          return title;\n        }\n      }\n    }\n  }, [mergedFieldNames, treeNodeLabelProp]);\n\n  // ========================= Wrap Value =========================\n  const toLabeledValues = React.useCallback(draftValues => {\n    const values = toArray(draftValues);\n    return values.map(val => {\n      if (isRawValue(val)) {\n        return {\n          value: val\n        };\n      }\n      return val;\n    });\n  }, []);\n  const convert2LabelValues = React.useCallback(draftValues => {\n    const values = toLabeledValues(draftValues);\n    return values.map(item => {\n      let {\n        label: rawLabel\n      } = item;\n      const {\n        value: rawValue,\n        halfChecked: rawHalfChecked\n      } = item;\n      let rawDisabled;\n      const entity = valueEntities.get(rawValue);\n\n      // Fill missing label & status\n      if (entity) {\n        rawLabel = treeTitleRender ? treeTitleRender(entity.node) : rawLabel !== null && rawLabel !== void 0 ? rawLabel : getLabel(entity.node);\n        rawDisabled = entity.node.disabled;\n      } else if (rawLabel === undefined) {\n        // We try to find in current `labelInValue` value\n        const labelInValueItem = toLabeledValues(internalValue).find(labeledItem => labeledItem.value === rawValue);\n        rawLabel = labelInValueItem.label;\n      }\n      return {\n        label: rawLabel,\n        value: rawValue,\n        halfChecked: rawHalfChecked,\n        disabled: rawDisabled\n      };\n    });\n  }, [valueEntities, getLabel, toLabeledValues, internalValue]);\n\n  // =========================== Values ===========================\n  const rawMixedLabeledValues = React.useMemo(() => toLabeledValues(internalValue === null ? [] : internalValue), [toLabeledValues, internalValue]);\n\n  // Split value into full check and half check\n  const [rawLabeledValues, rawHalfLabeledValues] = React.useMemo(() => {\n    const fullCheckValues = [];\n    const halfCheckValues = [];\n    rawMixedLabeledValues.forEach(item => {\n      if (item.halfChecked) {\n        halfCheckValues.push(item);\n      } else {\n        fullCheckValues.push(item);\n      }\n    });\n    return [fullCheckValues, halfCheckValues];\n  }, [rawMixedLabeledValues]);\n\n  // const [mergedValues] = useCache(rawLabeledValues);\n  const rawValues = React.useMemo(() => rawLabeledValues.map(item => item.value), [rawLabeledValues]);\n\n  // Convert value to key. Will fill missed keys for conduct check.\n  const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities);\n\n  // Convert rawCheckedKeys to check strategy related values\n  const displayValues = React.useMemo(() => {\n    // Collect keys which need to show\n    const displayKeys = formatStrategyValues(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Convert to value and filled with label\n    const values = displayKeys.map(key => {\n      var _keyEntities$key$node, _keyEntities$key;\n      return (_keyEntities$key$node = (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.node) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key[mergedFieldNames.value]) !== null && _keyEntities$key$node !== void 0 ? _keyEntities$key$node : key;\n    });\n\n    // Back fill with origin label\n    const labeledValues = values.map(val => {\n      const targetItem = rawLabeledValues.find(item => item.value === val);\n      const label = labelInValue ? targetItem === null || targetItem === void 0 ? void 0 : targetItem.label : treeTitleRender === null || treeTitleRender === void 0 ? void 0 : treeTitleRender(targetItem);\n      return {\n        value: val,\n        label\n      };\n    });\n    const rawDisplayValues = convert2LabelValues(labeledValues);\n    const firstVal = rawDisplayValues[0];\n    if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {\n      return [];\n    }\n    return rawDisplayValues.map(item => {\n      var _item$label;\n      return _objectSpread(_objectSpread({}, item), {}, {\n        label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value\n      });\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [mergedFieldNames, mergedMultiple, rawCheckedValues, rawLabeledValues, convert2LabelValues, mergedShowCheckedStrategy, keyEntities]);\n  const [cachedDisplayValues] = useCache(displayValues);\n\n  // ========================== MaxCount ==========================\n  const mergedMaxCount = React.useMemo(() => {\n    if (mergedMultiple && (mergedShowCheckedStrategy === 'SHOW_CHILD' || treeCheckStrictly || !treeCheckable)) {\n      return maxCount;\n    }\n    return null;\n  }, [maxCount, mergedMultiple, treeCheckStrictly, mergedShowCheckedStrategy, treeCheckable]);\n\n  // =========================== Change ===========================\n  const triggerChange = useRefFunc((newRawValues, extra, source) => {\n    const formattedKeyList = formatStrategyValues(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Not allow pass with `maxCount`\n    if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) {\n      return;\n    }\n    const labeledValues = convert2LabelValues(newRawValues);\n    setInternalValue(labeledValues);\n\n    // Clean up if needed\n    if (autoClearSearchValue) {\n      setSearchValue('');\n    }\n\n    // Generate rest parameters is costly, so only do it when necessary\n    if (onChange) {\n      let eventValues = newRawValues;\n      if (treeConduction) {\n        eventValues = formattedKeyList.map(key => {\n          const entity = valueEntities.get(key);\n          return entity ? entity.node[mergedFieldNames.value] : key;\n        });\n      }\n      const {\n        triggerValue,\n        selected\n      } = extra || {\n        triggerValue: undefined,\n        selected: undefined\n      };\n      let returnRawValues = eventValues;\n\n      // We need fill half check back\n      if (treeCheckStrictly) {\n        const halfValues = rawHalfLabeledValues.filter(item => !eventValues.includes(item.value));\n        returnRawValues = [...returnRawValues, ...halfValues];\n      }\n      const returnLabeledValues = convert2LabelValues(returnRawValues);\n      const additionalInfo = {\n        // [Legacy] Always return as array contains label & value\n        preValue: rawLabeledValues,\n        triggerValue\n      };\n\n      // [Legacy] Fill legacy data if user query.\n      // This is expansive that we only fill when user query\n      // https://github.com/react-component/tree-select/blob/fe33eb7c27830c9ac70cd1fdb1ebbe7bc679c16a/src/Select.jsx\n      let showPosition = true;\n      if (treeCheckStrictly || source === 'selection' && !selected) {\n        showPosition = false;\n      }\n      fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);\n      if (mergedCheckable) {\n        additionalInfo.checked = selected;\n      } else {\n        additionalInfo.selected = selected;\n      }\n      const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map(item => item.value);\n      onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map(item => item.label), additionalInfo);\n    }\n  });\n\n  // ========================== Options ===========================\n  /** Trigger by option list */\n  const onOptionSelect = React.useCallback((selectedKey, _ref) => {\n    var _node$mergedFieldName;\n    let {\n      selected,\n      source\n    } = _ref;\n    const entity = keyEntities[selectedKey];\n    const node = entity === null || entity === void 0 ? void 0 : entity.node;\n    const selectedValue = (_node$mergedFieldName = node === null || node === void 0 ? void 0 : node[mergedFieldNames.value]) !== null && _node$mergedFieldName !== void 0 ? _node$mergedFieldName : selectedKey;\n\n    // Never be falsy but keep it safe\n    if (!mergedMultiple) {\n      // Single mode always set value\n      triggerChange([selectedValue], {\n        selected: true,\n        triggerValue: selectedValue\n      }, 'option');\n    } else {\n      let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter(v => v !== selectedValue);\n\n      // Add keys if tree conduction\n      if (treeConduction) {\n        // Should keep missing values\n        const {\n          missingRawValues,\n          existRawValues\n        } = splitRawValues(newRawValues);\n        const keyList = existRawValues.map(val => valueEntities.get(val).key);\n\n        // Conduction by selected or not\n        let checkedKeys;\n        if (selected) {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, true, keyEntities));\n        } else {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, {\n            checked: false,\n            halfCheckedKeys: rawHalfCheckedValues\n          }, keyEntities));\n        }\n\n        // Fill back of keys\n        newRawValues = [...missingRawValues, ...checkedKeys.map(key => keyEntities[key].node[mergedFieldNames.value])];\n      }\n      triggerChange(newRawValues, {\n        selected,\n        triggerValue: selectedValue\n      }, source || 'option');\n    }\n\n    // Trigger select event\n    if (selected || !mergedMultiple) {\n      onSelect === null || onSelect === void 0 || onSelect(selectedValue, fillLegacyProps(node));\n    } else {\n      onDeselect === null || onDeselect === void 0 || onDeselect(selectedValue, fillLegacyProps(node));\n    }\n  }, [splitRawValues, valueEntities, keyEntities, mergedFieldNames, mergedMultiple, rawValues, triggerChange, treeConduction, onSelect, onDeselect, rawCheckedValues, rawHalfCheckedValues, maxCount]);\n\n  // ========================== Dropdown ==========================\n  const onInternalPopupVisibleChange = React.useCallback(open => {\n    if (onPopupVisibleChange) {\n      onPopupVisibleChange(open);\n    }\n  }, [onPopupVisibleChange]);\n\n  // ====================== Display Change ========================\n  const onDisplayValuesChange = useRefFunc((newValues, info) => {\n    const newRawValues = newValues.map(item => item.value);\n    if (info.type === 'clear') {\n      triggerChange(newRawValues, {}, 'selection');\n      return;\n    }\n\n    // TreeSelect only have multiple mode which means display change only has remove\n    if (info.values.length) {\n      onOptionSelect(info.values[0].value, {\n        selected: false,\n        source: 'selection'\n      });\n    }\n  });\n\n  // ========================== Context ===========================\n  const treeSelectContext = React.useMemo(() => {\n    return {\n      virtual,\n      popupMatchSelectWidth,\n      listHeight,\n      listItemHeight,\n      listItemScrollOffset,\n      treeData: filteredTreeData,\n      fieldNames: mergedFieldNames,\n      onSelect: onOptionSelect,\n      treeExpandAction,\n      treeTitleRender,\n      onPopupScroll,\n      leftMaxCount: maxCount === undefined ? null : maxCount - cachedDisplayValues.length,\n      leafCountOnly: mergedShowCheckedStrategy === 'SHOW_CHILD' && !treeCheckStrictly && !!treeCheckable,\n      valueEntities,\n      classNames: treeSelectClassNames,\n      styles\n    };\n  }, [virtual, popupMatchSelectWidth, listHeight, listItemHeight, listItemScrollOffset, filteredTreeData, mergedFieldNames, onOptionSelect, treeExpandAction, treeTitleRender, onPopupScroll, maxCount, cachedDisplayValues.length, mergedShowCheckedStrategy, treeCheckStrictly, treeCheckable, valueEntities, treeSelectClassNames, styles]);\n\n  // ======================= Legacy Context =======================\n  const legacyContext = React.useMemo(() => ({\n    checkable: mergedCheckable,\n    loadData,\n    treeLoadedKeys,\n    onTreeLoad,\n    checkedKeys: rawCheckedValues,\n    halfCheckedKeys: rawHalfCheckedValues,\n    treeDefaultExpandAll,\n    treeExpandedKeys,\n    treeDefaultExpandedKeys,\n    onTreeExpand,\n    treeIcon,\n    treeMotion,\n    showTreeIcon,\n    switcherIcon,\n    treeLine,\n    treeNodeFilterProp,\n    keyEntities\n  }), [mergedCheckable, loadData, treeLoadedKeys, onTreeLoad, rawCheckedValues, rawHalfCheckedValues, treeDefaultExpandAll, treeExpandedKeys, treeDefaultExpandedKeys, onTreeExpand, treeIcon, treeMotion, showTreeIcon, switcherIcon, treeLine, treeNodeFilterProp, keyEntities]);\n\n  // =========================== Render ===========================\n  return /*#__PURE__*/React.createElement(TreeSelectContext.Provider, {\n    value: treeSelectContext\n  }, /*#__PURE__*/React.createElement(LegacyContext.Provider, {\n    value: legacyContext\n  }, /*#__PURE__*/React.createElement(BaseSelect, _extends({\n    ref: ref\n  }, restProps, {\n    classNames: treeSelectClassNames,\n    styles: styles\n    // >>> MISC\n    ,\n\n    id: mergedId,\n    prefixCls: prefixCls,\n    mode: mergedMultiple ? 'multiple' : undefined\n    // >>> Display Value\n    ,\n\n    displayValues: cachedDisplayValues,\n    onDisplayValuesChange: onDisplayValuesChange\n    // >>> Search\n    ,\n\n    autoClearSearchValue: autoClearSearchValue,\n    showSearch: mergedShowSearch,\n    searchValue: mergedSearchValue,\n    onSearch: onInternalSearch\n    // >>> Options\n    ,\n\n    OptionList: OptionList,\n    emptyOptions: !mergedTreeData.length,\n    onPopupVisibleChange: onInternalPopupVisibleChange,\n    popupMatchSelectWidth: popupMatchSelectWidth\n  }))));\n});\n\n// Assign name for Debug\nif (process.env.NODE_ENV !== 'production') {\n  TreeSelect.displayName = 'TreeSelect';\n}\nconst GenericTreeSelect = TreeSelect;\nGenericTreeSelect.TreeNode = TreeNode;\nGenericTreeSelect.SHOW_ALL = SHOW_ALL;\nGenericTreeSelect.SHOW_PARENT = SHOW_PARENT;\nGenericTreeSelect.SHOW_CHILD = SHOW_CHILD;\nexport default GenericTreeSelect;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","BaseSelect","useId","conductCheck","useControlledState","React","useCache","useCheckedKeys","useDataEntities","useFilterTreeData","useRefFunc","useTreeData","LegacyContext","OptionList","TreeNode","TreeSelectContext","fillAdditionalInfo","fillLegacyProps","formatStrategyValues","SHOW_ALL","SHOW_CHILD","SHOW_PARENT","fillFieldNames","isNil","toArray","warningProps","useSearchConfig","isRawValue","value","TreeSelect","forwardRef","props","ref","id","prefixCls","defaultValue","onChange","onSelect","onDeselect","showSearch","searchValue","legacySearchValue","inputValue","legacyinputValue","onSearch","legacyOnSearch","autoClearSearchValue","legacyAutoClearSearchValue","filterTreeNode","legacyFilterTreeNode","treeNodeFilterProp","legacytreeNodeFilterProp","showCheckedStrategy","treeNodeLabelProp","multiple","treeCheckable","treeCheckStrictly","labelInValue","maxCount","fieldNames","treeDataSimpleMode","treeData","children","loadData","treeLoadedKeys","onTreeLoad","treeDefaultExpandAll","treeExpandedKeys","treeDefaultExpandedKeys","onTreeExpand","treeExpandAction","virtual","listHeight","listItemHeight","listItemScrollOffset","onPopupVisibleChange","popupMatchSelectWidth","treeLine","treeIcon","showTreeIcon","switcherIcon","treeMotion","treeTitleRender","onPopupScroll","classNames","treeSelectClassNames","styles","restProps","_objectWithoutProperties","_excluded","mergedId","treeConduction","mergedCheckable","mergedLabelInValue","mergedMultiple","searchProps","mergedShowSearch","searchConfig","internalValue","setInternalValue","mergedShowCheckedStrategy","useMemo","process","env","NODE_ENV","mergedFieldNames","JSON","stringify","internalSearchValue","setSearchValue","mergedSearchValue","onInternalSearch","searchText","mergedTreeData","keyEntities","valueEntities","splitRawValues","useCallback","newRawValues","missingRawValues","existRawValues","forEach","val","has","push","filteredTreeData","getLabel","item","_title","titleList","title","undefined","toLabeledValues","draftValues","values","map","convert2LabelValues","label","rawLabel","rawValue","halfChecked","rawHalfChecked","rawDisabled","entity","get","node","disabled","labelInValueItem","find","labeledItem","rawMixedLabeledValues","rawLabeledValues","rawHalfLabeledValues","fullCheckValues","halfCheckValues","rawValues","rawCheckedValues","rawHalfCheckedValues","displayValues","displayKeys","_keyEntities$key$node","_keyEntities$key","labeledValues","targetItem","rawDisplayValues","firstVal","_item$label","_objectSpread","cachedDisplayValues","mergedMaxCount","triggerChange","extra","formattedKeyList","eventValues","triggerValue","selected","returnRawValues","halfValues","filter","includes","returnLabeledValues","additionalInfo","preValue","showPosition","checked","returnValues","onOptionSelect","selectedKey","_ref","_node$mergedFieldName","selectedValue","v","keyList","checkedKeys","halfCheckedKeys","onInternalPopupVisibleChange","open","onDisplayValuesChange","newValues","info","type","treeSelectContext","leftMaxCount","leafCountOnly","legacyContext","checkable","createElement","Provider","mode","emptyOptions","displayName","GenericTreeSelect"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/tree-select/es/TreeSelect.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport { BaseSelect } from '@rc-component/select';\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport { conductCheck } from \"@rc-component/tree/es/utils/conductUtil\";\nimport useControlledState from \"@rc-component/util/es/hooks/useControlledState\";\nimport * as React from 'react';\nimport useCache from \"./hooks/useCache\";\nimport useCheckedKeys from \"./hooks/useCheckedKeys\";\nimport useDataEntities from \"./hooks/useDataEntities\";\nimport useFilterTreeData from \"./hooks/useFilterTreeData\";\nimport useRefFunc from \"./hooks/useRefFunc\";\nimport useTreeData from \"./hooks/useTreeData\";\nimport LegacyContext from \"./LegacyContext\";\nimport OptionList from \"./OptionList\";\nimport TreeNode from \"./TreeNode\";\nimport TreeSelectContext from \"./TreeSelectContext\";\nimport { fillAdditionalInfo, fillLegacyProps } from \"./utils/legacyUtil\";\nimport { formatStrategyValues, SHOW_ALL, SHOW_CHILD, SHOW_PARENT } from \"./utils/strategyUtil\";\nimport { fillFieldNames, isNil, toArray } from \"./utils/valueUtil\";\nimport warningProps from \"./utils/warningPropsUtil\";\nimport useSearchConfig from \"./hooks/useSearchConfig\";\nfunction isRawValue(value) {\n  return !value || typeof value !== 'object';\n}\nconst TreeSelect = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    id,\n    prefixCls = 'rc-tree-select',\n    // Value\n    value,\n    defaultValue,\n    onChange,\n    onSelect,\n    onDeselect,\n    // Search\n    showSearch,\n    searchValue: legacySearchValue,\n    inputValue: legacyinputValue,\n    onSearch: legacyOnSearch,\n    autoClearSearchValue: legacyAutoClearSearchValue,\n    filterTreeNode: legacyFilterTreeNode,\n    treeNodeFilterProp: legacytreeNodeFilterProp,\n    // Selector\n    showCheckedStrategy,\n    treeNodeLabelProp,\n    //  Mode\n    multiple,\n    treeCheckable,\n    treeCheckStrictly,\n    labelInValue,\n    maxCount,\n    // FieldNames\n    fieldNames,\n    // Data\n    treeDataSimpleMode,\n    treeData,\n    children,\n    loadData,\n    treeLoadedKeys,\n    onTreeLoad,\n    // Expanded\n    treeDefaultExpandAll,\n    treeExpandedKeys,\n    treeDefaultExpandedKeys,\n    onTreeExpand,\n    treeExpandAction,\n    // Options\n    virtual,\n    listHeight = 200,\n    listItemHeight = 20,\n    listItemScrollOffset = 0,\n    onPopupVisibleChange,\n    popupMatchSelectWidth = true,\n    // Tree\n    treeLine,\n    treeIcon,\n    showTreeIcon,\n    switcherIcon,\n    treeMotion,\n    treeTitleRender,\n    onPopupScroll,\n    classNames: treeSelectClassNames,\n    styles,\n    ...restProps\n  } = props;\n  const mergedId = useId(id);\n  const treeConduction = treeCheckable && !treeCheckStrictly;\n  const mergedCheckable = treeCheckable || treeCheckStrictly;\n  const mergedLabelInValue = treeCheckStrictly || labelInValue;\n  const mergedMultiple = mergedCheckable || multiple;\n  const searchProps = {\n    searchValue: legacySearchValue,\n    inputValue: legacyinputValue,\n    onSearch: legacyOnSearch,\n    autoClearSearchValue: legacyAutoClearSearchValue,\n    filterTreeNode: legacyFilterTreeNode,\n    treeNodeFilterProp: legacytreeNodeFilterProp\n  };\n  const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, searchProps);\n  const {\n    searchValue,\n    onSearch,\n    autoClearSearchValue = true,\n    filterTreeNode,\n    treeNodeFilterProp = 'value'\n  } = searchConfig;\n  const [internalValue, setInternalValue] = useControlledState(defaultValue, value);\n\n  // `multiple` && `!treeCheckable` should be show all\n  const mergedShowCheckedStrategy = React.useMemo(() => {\n    if (!treeCheckable) {\n      return SHOW_ALL;\n    }\n    return showCheckedStrategy || SHOW_CHILD;\n  }, [showCheckedStrategy, treeCheckable]);\n\n  // ========================== Warning ===========================\n  if (process.env.NODE_ENV !== 'production') {\n    warningProps(props);\n  }\n\n  // ========================= FieldNames =========================\n  const mergedFieldNames = React.useMemo(() => fillFieldNames(fieldNames), /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify(fieldNames)]\n  /* eslint-enable react-hooks/exhaustive-deps */);\n\n  // =========================== Search ===========================\n  const [internalSearchValue, setSearchValue] = useControlledState('', searchValue);\n  const mergedSearchValue = internalSearchValue || '';\n  const onInternalSearch = searchText => {\n    setSearchValue(searchText);\n    onSearch?.(searchText);\n  };\n\n  // ============================ Data ============================\n  // `useTreeData` only do convert of `children` or `simpleMode`.\n  // Else will return origin `treeData` for perf consideration.\n  // Do not do anything to loop the data.\n  const mergedTreeData = useTreeData(treeData, children, treeDataSimpleMode);\n  const {\n    keyEntities,\n    valueEntities\n  } = useDataEntities(mergedTreeData, mergedFieldNames);\n\n  /** Get `missingRawValues` which not exist in the tree yet */\n  const splitRawValues = React.useCallback(newRawValues => {\n    const missingRawValues = [];\n    const existRawValues = [];\n\n    // Keep missing value in the cache\n    newRawValues.forEach(val => {\n      if (valueEntities.has(val)) {\n        existRawValues.push(val);\n      } else {\n        missingRawValues.push(val);\n      }\n    });\n    return {\n      missingRawValues,\n      existRawValues\n    };\n  }, [valueEntities]);\n\n  // Filtered Tree\n  const filteredTreeData = useFilterTreeData(mergedTreeData, mergedSearchValue, {\n    fieldNames: mergedFieldNames,\n    treeNodeFilterProp,\n    filterTreeNode\n  });\n\n  // =========================== Label ============================\n  const getLabel = React.useCallback(item => {\n    if (item) {\n      if (treeNodeLabelProp) {\n        return item[treeNodeLabelProp];\n      }\n\n      // Loop from fieldNames\n      const {\n        _title: titleList\n      } = mergedFieldNames;\n      for (let i = 0; i < titleList.length; i += 1) {\n        const title = item[titleList[i]];\n        if (title !== undefined) {\n          return title;\n        }\n      }\n    }\n  }, [mergedFieldNames, treeNodeLabelProp]);\n\n  // ========================= Wrap Value =========================\n  const toLabeledValues = React.useCallback(draftValues => {\n    const values = toArray(draftValues);\n    return values.map(val => {\n      if (isRawValue(val)) {\n        return {\n          value: val\n        };\n      }\n      return val;\n    });\n  }, []);\n  const convert2LabelValues = React.useCallback(draftValues => {\n    const values = toLabeledValues(draftValues);\n    return values.map(item => {\n      let {\n        label: rawLabel\n      } = item;\n      const {\n        value: rawValue,\n        halfChecked: rawHalfChecked\n      } = item;\n      let rawDisabled;\n      const entity = valueEntities.get(rawValue);\n\n      // Fill missing label & status\n      if (entity) {\n        rawLabel = treeTitleRender ? treeTitleRender(entity.node) : rawLabel ?? getLabel(entity.node);\n        rawDisabled = entity.node.disabled;\n      } else if (rawLabel === undefined) {\n        // We try to find in current `labelInValue` value\n        const labelInValueItem = toLabeledValues(internalValue).find(labeledItem => labeledItem.value === rawValue);\n        rawLabel = labelInValueItem.label;\n      }\n      return {\n        label: rawLabel,\n        value: rawValue,\n        halfChecked: rawHalfChecked,\n        disabled: rawDisabled\n      };\n    });\n  }, [valueEntities, getLabel, toLabeledValues, internalValue]);\n\n  // =========================== Values ===========================\n  const rawMixedLabeledValues = React.useMemo(() => toLabeledValues(internalValue === null ? [] : internalValue), [toLabeledValues, internalValue]);\n\n  // Split value into full check and half check\n  const [rawLabeledValues, rawHalfLabeledValues] = React.useMemo(() => {\n    const fullCheckValues = [];\n    const halfCheckValues = [];\n    rawMixedLabeledValues.forEach(item => {\n      if (item.halfChecked) {\n        halfCheckValues.push(item);\n      } else {\n        fullCheckValues.push(item);\n      }\n    });\n    return [fullCheckValues, halfCheckValues];\n  }, [rawMixedLabeledValues]);\n\n  // const [mergedValues] = useCache(rawLabeledValues);\n  const rawValues = React.useMemo(() => rawLabeledValues.map(item => item.value), [rawLabeledValues]);\n\n  // Convert value to key. Will fill missed keys for conduct check.\n  const [rawCheckedValues, rawHalfCheckedValues] = useCheckedKeys(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities);\n\n  // Convert rawCheckedKeys to check strategy related values\n  const displayValues = React.useMemo(() => {\n    // Collect keys which need to show\n    const displayKeys = formatStrategyValues(rawCheckedValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Convert to value and filled with label\n    const values = displayKeys.map(key => keyEntities[key]?.node?.[mergedFieldNames.value] ?? key);\n\n    // Back fill with origin label\n    const labeledValues = values.map(val => {\n      const targetItem = rawLabeledValues.find(item => item.value === val);\n      const label = labelInValue ? targetItem?.label : treeTitleRender?.(targetItem);\n      return {\n        value: val,\n        label\n      };\n    });\n    const rawDisplayValues = convert2LabelValues(labeledValues);\n    const firstVal = rawDisplayValues[0];\n    if (!mergedMultiple && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {\n      return [];\n    }\n    return rawDisplayValues.map(item => ({\n      ...item,\n      label: item.label ?? item.value\n    }));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [mergedFieldNames, mergedMultiple, rawCheckedValues, rawLabeledValues, convert2LabelValues, mergedShowCheckedStrategy, keyEntities]);\n  const [cachedDisplayValues] = useCache(displayValues);\n\n  // ========================== MaxCount ==========================\n  const mergedMaxCount = React.useMemo(() => {\n    if (mergedMultiple && (mergedShowCheckedStrategy === 'SHOW_CHILD' || treeCheckStrictly || !treeCheckable)) {\n      return maxCount;\n    }\n    return null;\n  }, [maxCount, mergedMultiple, treeCheckStrictly, mergedShowCheckedStrategy, treeCheckable]);\n\n  // =========================== Change ===========================\n  const triggerChange = useRefFunc((newRawValues, extra, source) => {\n    const formattedKeyList = formatStrategyValues(newRawValues, mergedShowCheckedStrategy, keyEntities, mergedFieldNames);\n\n    // Not allow pass with `maxCount`\n    if (mergedMaxCount && formattedKeyList.length > mergedMaxCount) {\n      return;\n    }\n    const labeledValues = convert2LabelValues(newRawValues);\n    setInternalValue(labeledValues);\n\n    // Clean up if needed\n    if (autoClearSearchValue) {\n      setSearchValue('');\n    }\n\n    // Generate rest parameters is costly, so only do it when necessary\n    if (onChange) {\n      let eventValues = newRawValues;\n      if (treeConduction) {\n        eventValues = formattedKeyList.map(key => {\n          const entity = valueEntities.get(key);\n          return entity ? entity.node[mergedFieldNames.value] : key;\n        });\n      }\n      const {\n        triggerValue,\n        selected\n      } = extra || {\n        triggerValue: undefined,\n        selected: undefined\n      };\n      let returnRawValues = eventValues;\n\n      // We need fill half check back\n      if (treeCheckStrictly) {\n        const halfValues = rawHalfLabeledValues.filter(item => !eventValues.includes(item.value));\n        returnRawValues = [...returnRawValues, ...halfValues];\n      }\n      const returnLabeledValues = convert2LabelValues(returnRawValues);\n      const additionalInfo = {\n        // [Legacy] Always return as array contains label & value\n        preValue: rawLabeledValues,\n        triggerValue\n      };\n\n      // [Legacy] Fill legacy data if user query.\n      // This is expansive that we only fill when user query\n      // https://github.com/react-component/tree-select/blob/fe33eb7c27830c9ac70cd1fdb1ebbe7bc679c16a/src/Select.jsx\n      let showPosition = true;\n      if (treeCheckStrictly || source === 'selection' && !selected) {\n        showPosition = false;\n      }\n      fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData, showPosition, mergedFieldNames);\n      if (mergedCheckable) {\n        additionalInfo.checked = selected;\n      } else {\n        additionalInfo.selected = selected;\n      }\n      const returnValues = mergedLabelInValue ? returnLabeledValues : returnLabeledValues.map(item => item.value);\n      onChange(mergedMultiple ? returnValues : returnValues[0], mergedLabelInValue ? null : returnLabeledValues.map(item => item.label), additionalInfo);\n    }\n  });\n\n  // ========================== Options ===========================\n  /** Trigger by option list */\n  const onOptionSelect = React.useCallback((selectedKey, {\n    selected,\n    source\n  }) => {\n    const entity = keyEntities[selectedKey];\n    const node = entity?.node;\n    const selectedValue = node?.[mergedFieldNames.value] ?? selectedKey;\n\n    // Never be falsy but keep it safe\n    if (!mergedMultiple) {\n      // Single mode always set value\n      triggerChange([selectedValue], {\n        selected: true,\n        triggerValue: selectedValue\n      }, 'option');\n    } else {\n      let newRawValues = selected ? [...rawValues, selectedValue] : rawCheckedValues.filter(v => v !== selectedValue);\n\n      // Add keys if tree conduction\n      if (treeConduction) {\n        // Should keep missing values\n        const {\n          missingRawValues,\n          existRawValues\n        } = splitRawValues(newRawValues);\n        const keyList = existRawValues.map(val => valueEntities.get(val).key);\n\n        // Conduction by selected or not\n        let checkedKeys;\n        if (selected) {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, true, keyEntities));\n        } else {\n          ({\n            checkedKeys\n          } = conductCheck(keyList, {\n            checked: false,\n            halfCheckedKeys: rawHalfCheckedValues\n          }, keyEntities));\n        }\n\n        // Fill back of keys\n        newRawValues = [...missingRawValues, ...checkedKeys.map(key => keyEntities[key].node[mergedFieldNames.value])];\n      }\n      triggerChange(newRawValues, {\n        selected,\n        triggerValue: selectedValue\n      }, source || 'option');\n    }\n\n    // Trigger select event\n    if (selected || !mergedMultiple) {\n      onSelect?.(selectedValue, fillLegacyProps(node));\n    } else {\n      onDeselect?.(selectedValue, fillLegacyProps(node));\n    }\n  }, [splitRawValues, valueEntities, keyEntities, mergedFieldNames, mergedMultiple, rawValues, triggerChange, treeConduction, onSelect, onDeselect, rawCheckedValues, rawHalfCheckedValues, maxCount]);\n\n  // ========================== Dropdown ==========================\n  const onInternalPopupVisibleChange = React.useCallback(open => {\n    if (onPopupVisibleChange) {\n      onPopupVisibleChange(open);\n    }\n  }, [onPopupVisibleChange]);\n\n  // ====================== Display Change ========================\n  const onDisplayValuesChange = useRefFunc((newValues, info) => {\n    const newRawValues = newValues.map(item => item.value);\n    if (info.type === 'clear') {\n      triggerChange(newRawValues, {}, 'selection');\n      return;\n    }\n\n    // TreeSelect only have multiple mode which means display change only has remove\n    if (info.values.length) {\n      onOptionSelect(info.values[0].value, {\n        selected: false,\n        source: 'selection'\n      });\n    }\n  });\n\n  // ========================== Context ===========================\n  const treeSelectContext = React.useMemo(() => {\n    return {\n      virtual,\n      popupMatchSelectWidth,\n      listHeight,\n      listItemHeight,\n      listItemScrollOffset,\n      treeData: filteredTreeData,\n      fieldNames: mergedFieldNames,\n      onSelect: onOptionSelect,\n      treeExpandAction,\n      treeTitleRender,\n      onPopupScroll,\n      leftMaxCount: maxCount === undefined ? null : maxCount - cachedDisplayValues.length,\n      leafCountOnly: mergedShowCheckedStrategy === 'SHOW_CHILD' && !treeCheckStrictly && !!treeCheckable,\n      valueEntities,\n      classNames: treeSelectClassNames,\n      styles\n    };\n  }, [virtual, popupMatchSelectWidth, listHeight, listItemHeight, listItemScrollOffset, filteredTreeData, mergedFieldNames, onOptionSelect, treeExpandAction, treeTitleRender, onPopupScroll, maxCount, cachedDisplayValues.length, mergedShowCheckedStrategy, treeCheckStrictly, treeCheckable, valueEntities, treeSelectClassNames, styles]);\n\n  // ======================= Legacy Context =======================\n  const legacyContext = React.useMemo(() => ({\n    checkable: mergedCheckable,\n    loadData,\n    treeLoadedKeys,\n    onTreeLoad,\n    checkedKeys: rawCheckedValues,\n    halfCheckedKeys: rawHalfCheckedValues,\n    treeDefaultExpandAll,\n    treeExpandedKeys,\n    treeDefaultExpandedKeys,\n    onTreeExpand,\n    treeIcon,\n    treeMotion,\n    showTreeIcon,\n    switcherIcon,\n    treeLine,\n    treeNodeFilterProp,\n    keyEntities\n  }), [mergedCheckable, loadData, treeLoadedKeys, onTreeLoad, rawCheckedValues, rawHalfCheckedValues, treeDefaultExpandAll, treeExpandedKeys, treeDefaultExpandedKeys, onTreeExpand, treeIcon, treeMotion, showTreeIcon, switcherIcon, treeLine, treeNodeFilterProp, keyEntities]);\n\n  // =========================== Render ===========================\n  return /*#__PURE__*/React.createElement(TreeSelectContext.Provider, {\n    value: treeSelectContext\n  }, /*#__PURE__*/React.createElement(LegacyContext.Provider, {\n    value: legacyContext\n  }, /*#__PURE__*/React.createElement(BaseSelect, _extends({\n    ref: ref\n  }, restProps, {\n    classNames: treeSelectClassNames,\n    styles: styles\n    // >>> MISC\n    ,\n    id: mergedId,\n    prefixCls: prefixCls,\n    mode: mergedMultiple ? 'multiple' : undefined\n    // >>> Display Value\n    ,\n    displayValues: cachedDisplayValues,\n    onDisplayValuesChange: onDisplayValuesChange\n    // >>> Search\n    ,\n    autoClearSearchValue: autoClearSearchValue,\n    showSearch: mergedShowSearch,\n    searchValue: mergedSearchValue,\n    onSearch: onInternalSearch\n    // >>> Options\n    ,\n    OptionList: OptionList,\n    emptyOptions: !mergedTreeData.length,\n    onPopupVisibleChange: onInternalPopupVisibleChange,\n    popupMatchSelectWidth: popupMatchSelectWidth\n  }))));\n});\n\n// Assign name for Debug\nif (process.env.NODE_ENV !== 'production') {\n  TreeSelect.displayName = 'TreeSelect';\n}\nconst GenericTreeSelect = TreeSelect;\nGenericTreeSelect.TreeNode = TreeNode;\nGenericTreeSelect.SHOW_ALL = SHOW_ALL;\nGenericTreeSelect.SHOW_PARENT = SHOW_PARENT;\nGenericTreeSelect.SHOW_CHILD = SHOW_CHILD;\nexport default GenericTreeSelect;"],"mappings":";;;AAAA,SAASA,QAAQA,CAAA,EAAG;EAAEA,QAAQ,GAAGC,MAAM,CAACC,MAAM,GAAGD,MAAM,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,GAAG,UAAUC,MAAM,EAAE;IAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;MAAE,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;QAAE,IAAIP,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;UAAEL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;QAAE;MAAE;IAAE;IAAE,OAAOL,MAAM;EAAE,CAAC;EAAE,OAAOJ,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEP,SAAS,CAAC;AAAE;AAClV,SAASQ,UAAU,QAAQ,sBAAsB;AACjD,OAAOC,KAAK,MAAM,mCAAmC;AACrD,SAASC,YAAY,QAAQ,yCAAyC;AACtE,OAAOC,kBAAkB,MAAM,gDAAgD;AAC/E,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAOC,QAAQ,MAAM,kBAAkB;AACvC,OAAOC,cAAc,MAAM,wBAAwB;AACnD,OAAOC,eAAe,MAAM,yBAAyB;AACrD,OAAOC,iBAAiB,MAAM,2BAA2B;AACzD,OAAOC,UAAU,MAAM,oBAAoB;AAC3C,OAAOC,WAAW,MAAM,qBAAqB;AAC7C,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,iBAAiB,MAAM,qBAAqB;AACnD,SAASC,kBAAkB,EAAEC,eAAe,QAAQ,oBAAoB;AACxE,SAASC,oBAAoB,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,WAAW,QAAQ,sBAAsB;AAC9F,SAASC,cAAc,EAAEC,KAAK,EAAEC,OAAO,QAAQ,mBAAmB;AAClE,OAAOC,YAAY,MAAM,0BAA0B;AACnD,OAAOC,eAAe,MAAM,yBAAyB;AACrD,SAASC,UAAUA,CAACC,KAAK,EAAE;EACzB,OAAO,CAACA,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ;AAC5C;AACA,MAAMC,UAAU,GAAG,aAAaxB,KAAK,CAACyB,UAAU,CAAC,CAACC,KAAK,EAAEC,GAAG,KAAK;EAC/D,MAAM;MACJC,EAAE;MACFC,SAAS,GAAG,gBAAgB;MAC5B;MACAN,KAAK;MACLO,YAAY;MACZC,QAAQ;MACRC,QAAQ;MACRC,UAAU;MACV;MACAC,UAAU;MACVC,WAAW,EAAEC,iBAAiB;MAC9BC,UAAU,EAAEC,gBAAgB;MAC5BC,QAAQ,EAAEC,cAAc;MACxBC,oBAAoB,EAAEC,0BAA0B;MAChDC,cAAc,EAAEC,oBAAoB;MACpCC,kBAAkB,EAAEC,wBAAwB;MAC5C;MACAC,mBAAmB;MACnBC,iBAAiB;MACjB;MACAC,QAAQ;MACRC,aAAa;MACbC,iBAAiB;MACjBC,YAAY;MACZC,QAAQ;MACR;MACAC,UAAU;MACV;MACAC,kBAAkB;MAClBC,QAAQ;MACRC,QAAQ;MACRC,QAAQ;MACRC,cAAc;MACdC,UAAU;MACV;MACAC,oBAAoB;MACpBC,gBAAgB;MAChBC,uBAAuB;MACvBC,YAAY;MACZC,gBAAgB;MAChB;MACAC,OAAO;MACPC,UAAU,GAAG,GAAG;MAChBC,cAAc,GAAG,EAAE;MACnBC,oBAAoB,GAAG,CAAC;MACxBC,oBAAoB;MACpBC,qBAAqB,GAAG,IAAI;MAC5B;MACAC,QAAQ;MACRC,QAAQ;MACRC,YAAY;MACZC,YAAY;MACZC,UAAU;MACVC,eAAe;MACfC,aAAa;MACbC,UAAU,EAAEC,oBAAoB;MAChCC;IAEF,CAAC,GAAGvD,KAAK;IADJwD,SAAS,GAAAC,wBAAA,CACVzD,KAAK,EAAA0D,SAAA;EACT,MAAMC,QAAQ,GAAGxF,KAAK,CAAC+B,EAAE,CAAC;EAC1B,MAAM0D,cAAc,GAAGpC,aAAa,IAAI,CAACC,iBAAiB;EAC1D,MAAMoC,eAAe,GAAGrC,aAAa,IAAIC,iBAAiB;EAC1D,MAAMqC,kBAAkB,GAAGrC,iBAAiB,IAAIC,YAAY;EAC5D,MAAMqC,cAAc,GAAGF,eAAe,IAAItC,QAAQ;EAClD,MAAMyC,WAAW,GAAG;IAClBvD,WAAW,EAAEC,iBAAiB;IAC9BC,UAAU,EAAEC,gBAAgB;IAC5BC,QAAQ,EAAEC,cAAc;IACxBC,oBAAoB,EAAEC,0BAA0B;IAChDC,cAAc,EAAEC,oBAAoB;IACpCC,kBAAkB,EAAEC;EACtB,CAAC;EACD,MAAM,CAAC6C,gBAAgB,EAAEC,YAAY,CAAC,GAAGvE,eAAe,CAACa,UAAU,EAAEwD,WAAW,CAAC;EACjF,MAAM;IACJvD,WAAW;IACXI,QAAQ;IACRE,oBAAoB,GAAG,IAAI;IAC3BE,cAAc;IACdE,kBAAkB,GAAG;EACvB,CAAC,GAAG+C,YAAY;EAChB,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAG/F,kBAAkB,CAAC+B,YAAY,EAAEP,KAAK,CAAC;;EAEjF;EACA,MAAMwE,yBAAyB,GAAG/F,KAAK,CAACgG,OAAO,CAAC,MAAM;IACpD,IAAI,CAAC9C,aAAa,EAAE;MAClB,OAAOpC,QAAQ;IACjB;IACA,OAAOiC,mBAAmB,IAAIhC,UAAU;EAC1C,CAAC,EAAE,CAACgC,mBAAmB,EAAEG,aAAa,CAAC,CAAC;;EAExC;EACA,IAAI+C,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC/E,YAAY,CAACM,KAAK,CAAC;EACrB;;EAEA;EACA,MAAM0E,gBAAgB,GAAGpG,KAAK,CAACgG,OAAO,CAAC,MAAM/E,cAAc,CAACqC,UAAU,CAAC,EAAE;EACzE,CAAC+C,IAAI,CAACC,SAAS,CAAChD,UAAU,CAAC;EAC3B,+CAA+C,CAAC;;EAEhD;EACA,MAAM,CAACiD,mBAAmB,EAAEC,cAAc,CAAC,GAAGzG,kBAAkB,CAAC,EAAE,EAAEoC,WAAW,CAAC;EACjF,MAAMsE,iBAAiB,GAAGF,mBAAmB,IAAI,EAAE;EACnD,MAAMG,gBAAgB,GAAGC,UAAU,IAAI;IACrCH,cAAc,CAACG,UAAU,CAAC;IAC1BpE,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAGoE,UAAU,CAAC;EACxB,CAAC;;EAED;EACA;EACA;EACA;EACA,MAAMC,cAAc,GAAGtG,WAAW,CAACkD,QAAQ,EAAEC,QAAQ,EAAEF,kBAAkB,CAAC;EAC1E,MAAM;IACJsD,WAAW;IACXC;EACF,CAAC,GAAG3G,eAAe,CAACyG,cAAc,EAAER,gBAAgB,CAAC;;EAErD;EACA,MAAMW,cAAc,GAAG/G,KAAK,CAACgH,WAAW,CAACC,YAAY,IAAI;IACvD,MAAMC,gBAAgB,GAAG,EAAE;IAC3B,MAAMC,cAAc,GAAG,EAAE;;IAEzB;IACAF,YAAY,CAACG,OAAO,CAACC,GAAG,IAAI;MAC1B,IAAIP,aAAa,CAACQ,GAAG,CAACD,GAAG,CAAC,EAAE;QAC1BF,cAAc,CAACI,IAAI,CAACF,GAAG,CAAC;MAC1B,CAAC,MAAM;QACLH,gBAAgB,CAACK,IAAI,CAACF,GAAG,CAAC;MAC5B;IACF,CAAC,CAAC;IACF,OAAO;MACLH,gBAAgB;MAChBC;IACF,CAAC;EACH,CAAC,EAAE,CAACL,aAAa,CAAC,CAAC;;EAEnB;EACA,MAAMU,gBAAgB,GAAGpH,iBAAiB,CAACwG,cAAc,EAAEH,iBAAiB,EAAE;IAC5EnD,UAAU,EAAE8C,gBAAgB;IAC5BvD,kBAAkB;IAClBF;EACF,CAAC,CAAC;;EAEF;EACA,MAAM8E,QAAQ,GAAGzH,KAAK,CAACgH,WAAW,CAACU,IAAI,IAAI;IACzC,IAAIA,IAAI,EAAE;MACR,IAAI1E,iBAAiB,EAAE;QACrB,OAAO0E,IAAI,CAAC1E,iBAAiB,CAAC;MAChC;;MAEA;MACA,MAAM;QACJ2E,MAAM,EAAEC;MACV,CAAC,GAAGxB,gBAAgB;MACpB,KAAK,IAAIjH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,SAAS,CAACvI,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAE;QAC5C,MAAM0I,KAAK,GAAGH,IAAI,CAACE,SAAS,CAACzI,CAAC,CAAC,CAAC;QAChC,IAAI0I,KAAK,KAAKC,SAAS,EAAE;UACvB,OAAOD,KAAK;QACd;MACF;IACF;EACF,CAAC,EAAE,CAACzB,gBAAgB,EAAEpD,iBAAiB,CAAC,CAAC;;EAEzC;EACA,MAAM+E,eAAe,GAAG/H,KAAK,CAACgH,WAAW,CAACgB,WAAW,IAAI;IACvD,MAAMC,MAAM,GAAG9G,OAAO,CAAC6G,WAAW,CAAC;IACnC,OAAOC,MAAM,CAACC,GAAG,CAACb,GAAG,IAAI;MACvB,IAAI/F,UAAU,CAAC+F,GAAG,CAAC,EAAE;QACnB,OAAO;UACL9F,KAAK,EAAE8F;QACT,CAAC;MACH;MACA,OAAOA,GAAG;IACZ,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,MAAMc,mBAAmB,GAAGnI,KAAK,CAACgH,WAAW,CAACgB,WAAW,IAAI;IAC3D,MAAMC,MAAM,GAAGF,eAAe,CAACC,WAAW,CAAC;IAC3C,OAAOC,MAAM,CAACC,GAAG,CAACR,IAAI,IAAI;MACxB,IAAI;QACFU,KAAK,EAAEC;MACT,CAAC,GAAGX,IAAI;MACR,MAAM;QACJnG,KAAK,EAAE+G,QAAQ;QACfC,WAAW,EAAEC;MACf,CAAC,GAAGd,IAAI;MACR,IAAIe,WAAW;MACf,MAAMC,MAAM,GAAG5B,aAAa,CAAC6B,GAAG,CAACL,QAAQ,CAAC;;MAE1C;MACA,IAAII,MAAM,EAAE;QACVL,QAAQ,GAAGxD,eAAe,GAAGA,eAAe,CAAC6D,MAAM,CAACE,IAAI,CAAC,GAAGP,QAAQ,aAARA,QAAQ,cAARA,QAAQ,GAAIZ,QAAQ,CAACiB,MAAM,CAACE,IAAI,CAAC;QAC7FH,WAAW,GAAGC,MAAM,CAACE,IAAI,CAACC,QAAQ;MACpC,CAAC,MAAM,IAAIR,QAAQ,KAAKP,SAAS,EAAE;QACjC;QACA,MAAMgB,gBAAgB,GAAGf,eAAe,CAAClC,aAAa,CAAC,CAACkD,IAAI,CAACC,WAAW,IAAIA,WAAW,CAACzH,KAAK,KAAK+G,QAAQ,CAAC;QAC3GD,QAAQ,GAAGS,gBAAgB,CAACV,KAAK;MACnC;MACA,OAAO;QACLA,KAAK,EAAEC,QAAQ;QACf9G,KAAK,EAAE+G,QAAQ;QACfC,WAAW,EAAEC,cAAc;QAC3BK,QAAQ,EAAEJ;MACZ,CAAC;IACH,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC3B,aAAa,EAAEW,QAAQ,EAAEM,eAAe,EAAElC,aAAa,CAAC,CAAC;;EAE7D;EACA,MAAMoD,qBAAqB,GAAGjJ,KAAK,CAACgG,OAAO,CAAC,MAAM+B,eAAe,CAAClC,aAAa,KAAK,IAAI,GAAG,EAAE,GAAGA,aAAa,CAAC,EAAE,CAACkC,eAAe,EAAElC,aAAa,CAAC,CAAC;;EAEjJ;EACA,MAAM,CAACqD,gBAAgB,EAAEC,oBAAoB,CAAC,GAAGnJ,KAAK,CAACgG,OAAO,CAAC,MAAM;IACnE,MAAMoD,eAAe,GAAG,EAAE;IAC1B,MAAMC,eAAe,GAAG,EAAE;IAC1BJ,qBAAqB,CAAC7B,OAAO,CAACM,IAAI,IAAI;MACpC,IAAIA,IAAI,CAACa,WAAW,EAAE;QACpBc,eAAe,CAAC9B,IAAI,CAACG,IAAI,CAAC;MAC5B,CAAC,MAAM;QACL0B,eAAe,CAAC7B,IAAI,CAACG,IAAI,CAAC;MAC5B;IACF,CAAC,CAAC;IACF,OAAO,CAAC0B,eAAe,EAAEC,eAAe,CAAC;EAC3C,CAAC,EAAE,CAACJ,qBAAqB,CAAC,CAAC;;EAE3B;EACA,MAAMK,SAAS,GAAGtJ,KAAK,CAACgG,OAAO,CAAC,MAAMkD,gBAAgB,CAAChB,GAAG,CAACR,IAAI,IAAIA,IAAI,CAACnG,KAAK,CAAC,EAAE,CAAC2H,gBAAgB,CAAC,CAAC;;EAEnG;EACA,MAAM,CAACK,gBAAgB,EAAEC,oBAAoB,CAAC,GAAGtJ,cAAc,CAACgJ,gBAAgB,EAAEC,oBAAoB,EAAE7D,cAAc,EAAEuB,WAAW,CAAC;;EAEpI;EACA,MAAM4C,aAAa,GAAGzJ,KAAK,CAACgG,OAAO,CAAC,MAAM;IACxC;IACA,MAAM0D,WAAW,GAAG7I,oBAAoB,CAAC0I,gBAAgB,EAAExD,yBAAyB,EAAEc,WAAW,EAAET,gBAAgB,CAAC;;IAEpH;IACA,MAAM6B,MAAM,GAAGyB,WAAW,CAACxB,GAAG,CAAC3I,GAAG;MAAA,IAAAoK,qBAAA,EAAAC,gBAAA;MAAA,QAAAD,qBAAA,IAAAC,gBAAA,GAAI/C,WAAW,CAACtH,GAAG,CAAC,cAAAqK,gBAAA,gBAAAA,gBAAA,GAAhBA,gBAAA,CAAkBhB,IAAI,cAAAgB,gBAAA,uBAAtBA,gBAAA,CAAyBxD,gBAAgB,CAAC7E,KAAK,CAAC,cAAAoI,qBAAA,cAAAA,qBAAA,GAAIpK,GAAG;IAAA,EAAC;;IAE9F;IACA,MAAMsK,aAAa,GAAG5B,MAAM,CAACC,GAAG,CAACb,GAAG,IAAI;MACtC,MAAMyC,UAAU,GAAGZ,gBAAgB,CAACH,IAAI,CAACrB,IAAI,IAAIA,IAAI,CAACnG,KAAK,KAAK8F,GAAG,CAAC;MACpE,MAAMe,KAAK,GAAGhF,YAAY,GAAG0G,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE1B,KAAK,GAAGvD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAGiF,UAAU,CAAC;MAC9E,OAAO;QACLvI,KAAK,EAAE8F,GAAG;QACVe;MACF,CAAC;IACH,CAAC,CAAC;IACF,MAAM2B,gBAAgB,GAAG5B,mBAAmB,CAAC0B,aAAa,CAAC;IAC3D,MAAMG,QAAQ,GAAGD,gBAAgB,CAAC,CAAC,CAAC;IACpC,IAAI,CAACtE,cAAc,IAAIuE,QAAQ,IAAI9I,KAAK,CAAC8I,QAAQ,CAACzI,KAAK,CAAC,IAAIL,KAAK,CAAC8I,QAAQ,CAAC5B,KAAK,CAAC,EAAE;MACjF,OAAO,EAAE;IACX;IACA,OAAO2B,gBAAgB,CAAC7B,GAAG,CAACR,IAAI;MAAA,IAAAuC,WAAA;MAAA,OAAAC,aAAA,CAAAA,aAAA,KAC3BxC,IAAI;QACPU,KAAK,GAAA6B,WAAA,GAAEvC,IAAI,CAACU,KAAK,cAAA6B,WAAA,cAAAA,WAAA,GAAIvC,IAAI,CAACnG;MAAK;IAAA,CAC/B,CAAC;IACH;EACF,CAAC,EAAE,CAAC6E,gBAAgB,EAAEX,cAAc,EAAE8D,gBAAgB,EAAEL,gBAAgB,EAAEf,mBAAmB,EAAEpC,yBAAyB,EAAEc,WAAW,CAAC,CAAC;EACvI,MAAM,CAACsD,mBAAmB,CAAC,GAAGlK,QAAQ,CAACwJ,aAAa,CAAC;;EAErD;EACA,MAAMW,cAAc,GAAGpK,KAAK,CAACgG,OAAO,CAAC,MAAM;IACzC,IAAIP,cAAc,KAAKM,yBAAyB,KAAK,YAAY,IAAI5C,iBAAiB,IAAI,CAACD,aAAa,CAAC,EAAE;MACzG,OAAOG,QAAQ;IACjB;IACA,OAAO,IAAI;EACb,CAAC,EAAE,CAACA,QAAQ,EAAEoC,cAAc,EAAEtC,iBAAiB,EAAE4C,yBAAyB,EAAE7C,aAAa,CAAC,CAAC;;EAE3F;EACA,MAAMmH,aAAa,GAAGhK,UAAU,CAAC,CAAC4G,YAAY,EAAEqD,KAAK,EAAEhL,MAAM,KAAK;IAChE,MAAMiL,gBAAgB,GAAG1J,oBAAoB,CAACoG,YAAY,EAAElB,yBAAyB,EAAEc,WAAW,EAAET,gBAAgB,CAAC;;IAErH;IACA,IAAIgE,cAAc,IAAIG,gBAAgB,CAAClL,MAAM,GAAG+K,cAAc,EAAE;MAC9D;IACF;IACA,MAAMP,aAAa,GAAG1B,mBAAmB,CAAClB,YAAY,CAAC;IACvDnB,gBAAgB,CAAC+D,aAAa,CAAC;;IAE/B;IACA,IAAIpH,oBAAoB,EAAE;MACxB+D,cAAc,CAAC,EAAE,CAAC;IACpB;;IAEA;IACA,IAAIzE,QAAQ,EAAE;MACZ,IAAIyI,WAAW,GAAGvD,YAAY;MAC9B,IAAI3B,cAAc,EAAE;QAClBkF,WAAW,GAAGD,gBAAgB,CAACrC,GAAG,CAAC3I,GAAG,IAAI;UACxC,MAAMmJ,MAAM,GAAG5B,aAAa,CAAC6B,GAAG,CAACpJ,GAAG,CAAC;UACrC,OAAOmJ,MAAM,GAAGA,MAAM,CAACE,IAAI,CAACxC,gBAAgB,CAAC7E,KAAK,CAAC,GAAGhC,GAAG;QAC3D,CAAC,CAAC;MACJ;MACA,MAAM;QACJkL,YAAY;QACZC;MACF,CAAC,GAAGJ,KAAK,IAAI;QACXG,YAAY,EAAE3C,SAAS;QACvB4C,QAAQ,EAAE5C;MACZ,CAAC;MACD,IAAI6C,eAAe,GAAGH,WAAW;;MAEjC;MACA,IAAIrH,iBAAiB,EAAE;QACrB,MAAMyH,UAAU,GAAGzB,oBAAoB,CAAC0B,MAAM,CAACnD,IAAI,IAAI,CAAC8C,WAAW,CAACM,QAAQ,CAACpD,IAAI,CAACnG,KAAK,CAAC,CAAC;QACzFoJ,eAAe,GAAG,CAAC,GAAGA,eAAe,EAAE,GAAGC,UAAU,CAAC;MACvD;MACA,MAAMG,mBAAmB,GAAG5C,mBAAmB,CAACwC,eAAe,CAAC;MAChE,MAAMK,cAAc,GAAG;QACrB;QACAC,QAAQ,EAAE/B,gBAAgB;QAC1BuB;MACF,CAAC;;MAED;MACA;MACA;MACA,IAAIS,YAAY,GAAG,IAAI;MACvB,IAAI/H,iBAAiB,IAAI7D,MAAM,KAAK,WAAW,IAAI,CAACoL,QAAQ,EAAE;QAC5DQ,YAAY,GAAG,KAAK;MACtB;MACAvK,kBAAkB,CAACqK,cAAc,EAAEP,YAAY,EAAExD,YAAY,EAAEL,cAAc,EAAEsE,YAAY,EAAE9E,gBAAgB,CAAC;MAC9G,IAAIb,eAAe,EAAE;QACnByF,cAAc,CAACG,OAAO,GAAGT,QAAQ;MACnC,CAAC,MAAM;QACLM,cAAc,CAACN,QAAQ,GAAGA,QAAQ;MACpC;MACA,MAAMU,YAAY,GAAG5F,kBAAkB,GAAGuF,mBAAmB,GAAGA,mBAAmB,CAAC7C,GAAG,CAACR,IAAI,IAAIA,IAAI,CAACnG,KAAK,CAAC;MAC3GQ,QAAQ,CAAC0D,cAAc,GAAG2F,YAAY,GAAGA,YAAY,CAAC,CAAC,CAAC,EAAE5F,kBAAkB,GAAG,IAAI,GAAGuF,mBAAmB,CAAC7C,GAAG,CAACR,IAAI,IAAIA,IAAI,CAACU,KAAK,CAAC,EAAE4C,cAAc,CAAC;IACpJ;EACF,CAAC,CAAC;;EAEF;EACA;EACA,MAAMK,cAAc,GAAGrL,KAAK,CAACgH,WAAW,CAAC,CAACsE,WAAW,EAAAC,IAAA,KAG/C;IAAA,IAAAC,qBAAA;IAAA,IAHiD;MACrDd,QAAQ;MACRpL;IACF,CAAC,GAAAiM,IAAA;IACC,MAAM7C,MAAM,GAAG7B,WAAW,CAACyE,WAAW,CAAC;IACvC,MAAM1C,IAAI,GAAGF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE,IAAI;IACzB,MAAM6C,aAAa,IAAAD,qBAAA,GAAG5C,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAGxC,gBAAgB,CAAC7E,KAAK,CAAC,cAAAiK,qBAAA,cAAAA,qBAAA,GAAIF,WAAW;;IAEnE;IACA,IAAI,CAAC7F,cAAc,EAAE;MACnB;MACA4E,aAAa,CAAC,CAACoB,aAAa,CAAC,EAAE;QAC7Bf,QAAQ,EAAE,IAAI;QACdD,YAAY,EAAEgB;MAChB,CAAC,EAAE,QAAQ,CAAC;IACd,CAAC,MAAM;MACL,IAAIxE,YAAY,GAAGyD,QAAQ,GAAG,CAAC,GAAGpB,SAAS,EAAEmC,aAAa,CAAC,GAAGlC,gBAAgB,CAACsB,MAAM,CAACa,CAAC,IAAIA,CAAC,KAAKD,aAAa,CAAC;;MAE/G;MACA,IAAInG,cAAc,EAAE;QAClB;QACA,MAAM;UACJ4B,gBAAgB;UAChBC;QACF,CAAC,GAAGJ,cAAc,CAACE,YAAY,CAAC;QAChC,MAAM0E,OAAO,GAAGxE,cAAc,CAACe,GAAG,CAACb,GAAG,IAAIP,aAAa,CAAC6B,GAAG,CAACtB,GAAG,CAAC,CAAC9H,GAAG,CAAC;;QAErE;QACA,IAAIqM,WAAW;QACf,IAAIlB,QAAQ,EAAE;UACZ,CAAC;YACCkB;UACF,CAAC,GAAG9L,YAAY,CAAC6L,OAAO,EAAE,IAAI,EAAE9E,WAAW,CAAC;QAC9C,CAAC,MAAM;UACL,CAAC;YACC+E;UACF,CAAC,GAAG9L,YAAY,CAAC6L,OAAO,EAAE;YACxBR,OAAO,EAAE,KAAK;YACdU,eAAe,EAAErC;UACnB,CAAC,EAAE3C,WAAW,CAAC;QACjB;;QAEA;QACAI,YAAY,GAAG,CAAC,GAAGC,gBAAgB,EAAE,GAAG0E,WAAW,CAAC1D,GAAG,CAAC3I,GAAG,IAAIsH,WAAW,CAACtH,GAAG,CAAC,CAACqJ,IAAI,CAACxC,gBAAgB,CAAC7E,KAAK,CAAC,CAAC,CAAC;MAChH;MACA8I,aAAa,CAACpD,YAAY,EAAE;QAC1ByD,QAAQ;QACRD,YAAY,EAAEgB;MAChB,CAAC,EAAEnM,MAAM,IAAI,QAAQ,CAAC;IACxB;;IAEA;IACA,IAAIoL,QAAQ,IAAI,CAACjF,cAAc,EAAE;MAC/BzD,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAGyJ,aAAa,EAAE7K,eAAe,CAACgI,IAAI,CAAC,CAAC;IAClD,CAAC,MAAM;MACL3G,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAGwJ,aAAa,EAAE7K,eAAe,CAACgI,IAAI,CAAC,CAAC;IACpD;EACF,CAAC,EAAE,CAAC7B,cAAc,EAAED,aAAa,EAAED,WAAW,EAAET,gBAAgB,EAAEX,cAAc,EAAE6D,SAAS,EAAEe,aAAa,EAAE/E,cAAc,EAAEtD,QAAQ,EAAEC,UAAU,EAAEsH,gBAAgB,EAAEC,oBAAoB,EAAEnG,QAAQ,CAAC,CAAC;;EAEpM;EACA,MAAMyI,4BAA4B,GAAG9L,KAAK,CAACgH,WAAW,CAAC+E,IAAI,IAAI;IAC7D,IAAIzH,oBAAoB,EAAE;MACxBA,oBAAoB,CAACyH,IAAI,CAAC;IAC5B;EACF,CAAC,EAAE,CAACzH,oBAAoB,CAAC,CAAC;;EAE1B;EACA,MAAM0H,qBAAqB,GAAG3L,UAAU,CAAC,CAAC4L,SAAS,EAAEC,IAAI,KAAK;IAC5D,MAAMjF,YAAY,GAAGgF,SAAS,CAAC/D,GAAG,CAACR,IAAI,IAAIA,IAAI,CAACnG,KAAK,CAAC;IACtD,IAAI2K,IAAI,CAACC,IAAI,KAAK,OAAO,EAAE;MACzB9B,aAAa,CAACpD,YAAY,EAAE,CAAC,CAAC,EAAE,WAAW,CAAC;MAC5C;IACF;;IAEA;IACA,IAAIiF,IAAI,CAACjE,MAAM,CAAC5I,MAAM,EAAE;MACtBgM,cAAc,CAACa,IAAI,CAACjE,MAAM,CAAC,CAAC,CAAC,CAAC1G,KAAK,EAAE;QACnCmJ,QAAQ,EAAE,KAAK;QACfpL,MAAM,EAAE;MACV,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;;EAEF;EACA,MAAM8M,iBAAiB,GAAGpM,KAAK,CAACgG,OAAO,CAAC,MAAM;IAC5C,OAAO;MACL9B,OAAO;MACPK,qBAAqB;MACrBJ,UAAU;MACVC,cAAc;MACdC,oBAAoB;MACpBb,QAAQ,EAAEgE,gBAAgB;MAC1BlE,UAAU,EAAE8C,gBAAgB;MAC5BpE,QAAQ,EAAEqJ,cAAc;MACxBpH,gBAAgB;MAChBY,eAAe;MACfC,aAAa;MACbuH,YAAY,EAAEhJ,QAAQ,KAAKyE,SAAS,GAAG,IAAI,GAAGzE,QAAQ,GAAG8G,mBAAmB,CAAC9K,MAAM;MACnFiN,aAAa,EAAEvG,yBAAyB,KAAK,YAAY,IAAI,CAAC5C,iBAAiB,IAAI,CAAC,CAACD,aAAa;MAClG4D,aAAa;MACb/B,UAAU,EAAEC,oBAAoB;MAChCC;IACF,CAAC;EACH,CAAC,EAAE,CAACf,OAAO,EAAEK,qBAAqB,EAAEJ,UAAU,EAAEC,cAAc,EAAEC,oBAAoB,EAAEmD,gBAAgB,EAAEpB,gBAAgB,EAAEiF,cAAc,EAAEpH,gBAAgB,EAAEY,eAAe,EAAEC,aAAa,EAAEzB,QAAQ,EAAE8G,mBAAmB,CAAC9K,MAAM,EAAE0G,yBAAyB,EAAE5C,iBAAiB,EAAED,aAAa,EAAE4D,aAAa,EAAE9B,oBAAoB,EAAEC,MAAM,CAAC,CAAC;;EAE5U;EACA,MAAMsH,aAAa,GAAGvM,KAAK,CAACgG,OAAO,CAAC,OAAO;IACzCwG,SAAS,EAAEjH,eAAe;IAC1B7B,QAAQ;IACRC,cAAc;IACdC,UAAU;IACVgI,WAAW,EAAErC,gBAAgB;IAC7BsC,eAAe,EAAErC,oBAAoB;IACrC3F,oBAAoB;IACpBC,gBAAgB;IAChBC,uBAAuB;IACvBC,YAAY;IACZS,QAAQ;IACRG,UAAU;IACVF,YAAY;IACZC,YAAY;IACZH,QAAQ;IACR3B,kBAAkB;IAClBgE;EACF,CAAC,CAAC,EAAE,CAACtB,eAAe,EAAE7B,QAAQ,EAAEC,cAAc,EAAEC,UAAU,EAAE2F,gBAAgB,EAAEC,oBAAoB,EAAE3F,oBAAoB,EAAEC,gBAAgB,EAAEC,uBAAuB,EAAEC,YAAY,EAAES,QAAQ,EAAEG,UAAU,EAAEF,YAAY,EAAEC,YAAY,EAAEH,QAAQ,EAAE3B,kBAAkB,EAAEgE,WAAW,CAAC,CAAC;;EAEhR;EACA,OAAO,aAAa7G,KAAK,CAACyM,aAAa,CAAC/L,iBAAiB,CAACgM,QAAQ,EAAE;IAClEnL,KAAK,EAAE6K;EACT,CAAC,EAAE,aAAapM,KAAK,CAACyM,aAAa,CAAClM,aAAa,CAACmM,QAAQ,EAAE;IAC1DnL,KAAK,EAAEgL;EACT,CAAC,EAAE,aAAavM,KAAK,CAACyM,aAAa,CAAC7M,UAAU,EAAEd,QAAQ,CAAC;IACvD6C,GAAG,EAAEA;EACP,CAAC,EAAEuD,SAAS,EAAE;IACZH,UAAU,EAAEC,oBAAoB;IAChCC,MAAM,EAAEA;IACR;IAAA;;IAEArD,EAAE,EAAEyD,QAAQ;IACZxD,SAAS,EAAEA,SAAS;IACpB8K,IAAI,EAAElH,cAAc,GAAG,UAAU,GAAGqC;IACpC;IAAA;;IAEA2B,aAAa,EAAEU,mBAAmB;IAClC6B,qBAAqB,EAAEA;IACvB;IAAA;;IAEAvJ,oBAAoB,EAAEA,oBAAoB;IAC1CP,UAAU,EAAEyD,gBAAgB;IAC5BxD,WAAW,EAAEsE,iBAAiB;IAC9BlE,QAAQ,EAAEmE;IACV;IAAA;;IAEAlG,UAAU,EAAEA,UAAU;IACtBoM,YAAY,EAAE,CAAChG,cAAc,CAACvH,MAAM;IACpCiF,oBAAoB,EAAEwH,4BAA4B;IAClDvH,qBAAqB,EAAEA;EACzB,CAAC,CAAC,CAAC,CAAC,CAAC;AACP,CAAC,CAAC;;AAEF;AACA,IAAI0B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;EACzC3E,UAAU,CAACqL,WAAW,GAAG,YAAY;AACvC;AACA,MAAMC,iBAAiB,GAAGtL,UAAU;AACpCsL,iBAAiB,CAACrM,QAAQ,GAAGA,QAAQ;AACrCqM,iBAAiB,CAAChM,QAAQ,GAAGA,QAAQ;AACrCgM,iBAAiB,CAAC9L,WAAW,GAAGA,WAAW;AAC3C8L,iBAAiB,CAAC/L,UAAU,GAAGA,UAAU;AACzC,eAAe+L,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}