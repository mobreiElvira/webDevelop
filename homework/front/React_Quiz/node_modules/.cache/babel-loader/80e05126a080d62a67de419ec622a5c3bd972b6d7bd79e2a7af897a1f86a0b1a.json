{"ast":null,"code":"import warning from \"@rc-component/util/es/warning\";\nimport getEntity from \"./keyUtil\";\nfunction removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {\n  const filteredKeys = new Set();\n  halfCheckedKeys.forEach(key => {\n    if (!checkedKeys.has(key)) {\n      filteredKeys.add(key);\n    }\n  });\n  return filteredKeys;\n}\nexport function isCheckDisabled(node) {\n  const {\n    disabled,\n    disableCheckbox,\n    checkable\n  } = node || {};\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n\n// Fill miss keys\nfunction fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  const halfCheckedKeys = new Set();\n\n  // Add checked keys top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.add(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Add checked keys from bottom to top\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(_ref => {\n        let {\n          key\n        } = _ref;\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (allChecked) {\n        checkedKeys.add(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n// Remove useless key\nfunction cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  let halfCheckedKeys = new Set(halfKeys);\n\n  // Remove checked keys from top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.delete(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Remove checked keys form bottom to top\n  halfCheckedKeys = new Set();\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(_ref2 => {\n        let {\n          key\n        } = _ref2;\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (!allChecked) {\n        checkedKeys.delete(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n/**\n * Conduct with keys.\n * @param keyList current key list\n * @param keyEntities key - dataEntity map\n * @param mode `fill` to fill missing key, `clean` to remove useless key\n */\nexport function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {\n  const warningMissKeys = [];\n  let syntheticGetCheckDisabled;\n  if (getCheckDisabled) {\n    syntheticGetCheckDisabled = getCheckDisabled;\n  } else {\n    syntheticGetCheckDisabled = isCheckDisabled;\n  }\n\n  // We only handle exist keys\n  const keys = new Set(keyList.filter(key => {\n    const hasEntity = !!getEntity(keyEntities, key);\n    if (!hasEntity) {\n      warningMissKeys.push(key);\n    }\n    return hasEntity;\n  }));\n  const levelEntities = new Map();\n  let maxLevel = 0;\n\n  // Convert entities by level for calculation\n  Object.keys(keyEntities).forEach(key => {\n    const entity = keyEntities[key];\n    const {\n      level\n    } = entity;\n    let levelSet = levelEntities.get(level);\n    if (!levelSet) {\n      levelSet = new Set();\n      levelEntities.set(level, levelSet);\n    }\n    levelSet.add(entity);\n    maxLevel = Math.max(maxLevel, level);\n  });\n  warning(!warningMissKeys.length, \"Tree missing follow keys: \".concat(warningMissKeys.slice(0, 100).map(key => \"'\".concat(key, \"'\")).join(', ')));\n  let result;\n  if (checked === true) {\n    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  } else {\n    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  }\n  return result;\n}","map":{"version":3,"names":["warning","getEntity","removeFromCheckedKeys","halfCheckedKeys","checkedKeys","filteredKeys","Set","forEach","key","has","add","isCheckDisabled","node","disabled","disableCheckbox","checkable","fillConductCheck","keys","levelEntities","maxLevel","syntheticGetCheckDisabled","level","entities","get","entity","children","filter","childEntity","visitedKeys","parent","allChecked","partialChecked","_ref","checked","Array","from","cleanConductCheck","halfKeys","delete","_ref2","conductCheck","keyList","keyEntities","getCheckDisabled","warningMissKeys","hasEntity","push","Map","Object","levelSet","set","Math","max","length","concat","slice","map","join","result"],"sources":["F:/综合/个人/作业/主课/大三/web开发/homework/front/React_Quiz/node_modules/@rc-component/tree/es/utils/conductUtil.js"],"sourcesContent":["import warning from \"@rc-component/util/es/warning\";\nimport getEntity from \"./keyUtil\";\nfunction removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {\n  const filteredKeys = new Set();\n  halfCheckedKeys.forEach(key => {\n    if (!checkedKeys.has(key)) {\n      filteredKeys.add(key);\n    }\n  });\n  return filteredKeys;\n}\nexport function isCheckDisabled(node) {\n  const {\n    disabled,\n    disableCheckbox,\n    checkable\n  } = node || {};\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n\n// Fill miss keys\nfunction fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  const halfCheckedKeys = new Set();\n\n  // Add checked keys top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.add(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Add checked keys from bottom to top\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(({\n        key\n      }) => {\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (allChecked) {\n        checkedKeys.add(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n// Remove useless key\nfunction cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {\n  const checkedKeys = new Set(keys);\n  let halfCheckedKeys = new Set(halfKeys);\n\n  // Remove checked keys from top to bottom\n  for (let level = 0; level <= maxLevel; level += 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        key,\n        node,\n        children = []\n      } = entity;\n      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {\n        children.filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(childEntity => {\n          checkedKeys.delete(childEntity.key);\n        });\n      }\n    });\n  }\n\n  // Remove checked keys form bottom to top\n  halfCheckedKeys = new Set();\n  const visitedKeys = new Set();\n  for (let level = maxLevel; level >= 0; level -= 1) {\n    const entities = levelEntities.get(level) || new Set();\n    entities.forEach(entity => {\n      const {\n        parent,\n        node\n      } = entity;\n\n      // Skip if no need to check\n      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {\n        return;\n      }\n\n      // Skip if parent is disabled\n      if (syntheticGetCheckDisabled(entity.parent.node)) {\n        visitedKeys.add(parent.key);\n        return;\n      }\n      let allChecked = true;\n      let partialChecked = false;\n      (parent.children || []).filter(childEntity => !syntheticGetCheckDisabled(childEntity.node)).forEach(({\n        key\n      }) => {\n        const checked = checkedKeys.has(key);\n        if (allChecked && !checked) {\n          allChecked = false;\n        }\n        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {\n          partialChecked = true;\n        }\n      });\n      if (!allChecked) {\n        checkedKeys.delete(parent.key);\n      }\n      if (partialChecked) {\n        halfCheckedKeys.add(parent.key);\n      }\n      visitedKeys.add(parent.key);\n    });\n  }\n  return {\n    checkedKeys: Array.from(checkedKeys),\n    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))\n  };\n}\n\n/**\n * Conduct with keys.\n * @param keyList current key list\n * @param keyEntities key - dataEntity map\n * @param mode `fill` to fill missing key, `clean` to remove useless key\n */\nexport function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {\n  const warningMissKeys = [];\n  let syntheticGetCheckDisabled;\n  if (getCheckDisabled) {\n    syntheticGetCheckDisabled = getCheckDisabled;\n  } else {\n    syntheticGetCheckDisabled = isCheckDisabled;\n  }\n\n  // We only handle exist keys\n  const keys = new Set(keyList.filter(key => {\n    const hasEntity = !!getEntity(keyEntities, key);\n    if (!hasEntity) {\n      warningMissKeys.push(key);\n    }\n    return hasEntity;\n  }));\n  const levelEntities = new Map();\n  let maxLevel = 0;\n\n  // Convert entities by level for calculation\n  Object.keys(keyEntities).forEach(key => {\n    const entity = keyEntities[key];\n    const {\n      level\n    } = entity;\n    let levelSet = levelEntities.get(level);\n    if (!levelSet) {\n      levelSet = new Set();\n      levelEntities.set(level, levelSet);\n    }\n    levelSet.add(entity);\n    maxLevel = Math.max(maxLevel, level);\n  });\n  warning(!warningMissKeys.length, `Tree missing follow keys: ${warningMissKeys.slice(0, 100).map(key => `'${key}'`).join(', ')}`);\n  let result;\n  if (checked === true) {\n    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  } else {\n    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);\n  }\n  return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}